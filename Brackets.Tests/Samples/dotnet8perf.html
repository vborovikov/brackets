<p>I look forward to summer every year. Sun, beach, warm nights, and putting the finishing touches on the next version of .NET. It‚Äôs also the time I get to continue a tradition I started for myself back in 2017 of writing about the performance improvements that have gone into the latest .NET incarnation. A year ago that was <a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/">Performance Improvements in .NET 7</a>, which followed similar posts for <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6">.NET 6</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5">.NET 5</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0">.NET Core 3.0</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1">.NET Core 2.1</a>, and <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core">.NET Core 2.0</a>.</p><p>Since <a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/">.NET 7</a> was released a year ago, you‚Äôve likely been inundated with news about AI and ChatGPT. You may have even invested effort in using AI and/or <a href="https://devblogs.microsoft.com/dotnet/demystifying-retrieval-augmented-generation-with-dotnet/">incorporated it into your applications</a>. And I got to wondering: could AI write this blog post for me? So I issued the following request to <a href="http://bing.com/chat">Bing Chat</a>:</p><blockquote><p>
‚ÄúYou are an expert .NET developer with a penchant for pedagogy and a love of details. Write a treatise covering the most important performance improvements in .NET 8. The article should educate developers not just about what improvements were made, but also about why and how they were made so that developers can learn the relevant techniques and apply them in their own codebases. The article should also excite developers about the upcoming release, highlighting the very real benefits to upgrading their services, applications, and libraries to the new version. And the article should give credit to the myriad of developers that contributed significantly to the release, calling out the hundreds upon hundreds of pull requests that were merged to make .NET 8 the fastest .NET to date. The article should follow the style of the post about .NET 7 performance at https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/. Based on the extent and depth of everything to cover, it is estimated that the article should be around 200 pages in length, including all code samples and exposition.‚Äù
</p></blockquote><p>And the response?</p><blockquote><p>‚ÄúI‚Äôm sorry, but I can‚Äôt write a 200-page treatise for you. That‚Äôs beyond the scope of my capabilities and my chat settings. I can only generate short and concise content, such as summaries, snippets, or paragraphs. If you want to learn more about the performance improvements in .NET 8, you can check out some of the web search results I found for you. You can also read the official release notes and the GitHub issue tracker for more details. I hope you understand and appreciate my limitations. Thank you for your interest in .NET 8. <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f60a.png" alt="üòä" class="wp-smiley" style="height: 1em; max-height: 1em;" />‚Äù</p></blockquote><p>Fair enough (especially since, after writing this post and measuring the token count, it‚Äôs north of 300,000). And I‚Äôm happy with that outcome, because it means I still get to have the fun of writing this myself.</p><p>Throughout the past year, as I was reviewing PRs in various .NET repos, I maintained a list of all the PRs that I might want to cover in this post (which is focused on the core runtime and libraries‚Ä¶ you can expect subsequent posts on other areas, like ASP.NET Core). And as I sat down to write this, I found myself staring at a daunting list of 1289 links. This post can‚Äôt cover all of them, but it does take a tour through more than 500 PRs, all of which have gone into making .NET 8 an irresistible release, one I hope you‚Äôll all upgrade to as soon as humanly possible.</p><p>.NET 7 was super fast. .NET 8 is faster.</p><h2 id="table-of-contents">Table of Contents</h2><ul><li><a href="#benchmarking-setup">Benchmarking Setup</a></li><li><a href="#jit">JIT</a><ul><li><a href="#tiering-and-dynamic-pgo">Tiering and Dynamic PGO</a></li><li><a href="#vectorization">Vectorization</a></li><li><a href="#branching">Branching</a></li><li><a href="#bounds-checking">Bounds Checking</a></li><li><a href="#constant-folding">Constant Folding</a></li><li><a href="#non-gc-heap">Non-GC Heap</a></li><li><a href="#zeroing">Zeroing</a></li><li><a href="#value-types">Value Types</a></li><li><a href="#casting">Casting</a></li><li><a href="#peephole-optimizations">Peephole Optimizations</a></li></ul></li><li><a href="#native-aot">Native AOT</a></li><li><a href="#vm">VM</a></li><li><a href="#gc">GC</a></li><li><a href="#mono">Mono</a></li><li><a href="#threading">Threading</a><ul><li><a href="#threadstatic">[ThreadStatic]</a></li><li><a href="#threadpool">ThreadPool</a></li><li><a href="#tasks">Tasks</a></li><li><a href="#parallel">Parallel</a></li></ul></li><li><a href="#reflection">Reflection</a></li><li><a href="#exceptions">Exceptions</a></li><li><a href="#primitives">Primitives</a><ul><li><a href="#enums">Enums</a></li><li><a href="#numbers">Numbers</a></li><li><a href="#datetime">DateTime</a></li><li><a href="#guid">Guid</a></li><li><a href="#random">Random</a></li></ul></li><li><a href="#strings-arrays-and-spans">Strings, Arrays, and Spans</a><ul><li><a href="#utf8">UTF8</a></li><li><a href="#ascii">ASCII</a></li><li><a href="#base64">Base64</a></li><li><a href="#hex">Hex</a></li><li><a href="#string-formatting">String Formatting</a></li><li><a href="#spans">Spans</a></li><li><a href="#searchvalues">SearchValues</a></li><li><a href="#regex">Regex</a></li><li><a href="#hashing">Hashing</a></li><li><a href="#initialization">Initialization</a></li><li><a href="#analyzers">Analyzers</a></li></ul></li><li><a href="#collections">Collections</a><ul><li><a href="#general">General</a></li><li><a href="#list">List</a></li><li><a href="#linq">LINQ</a></li><li><a href="#dictionary">Dictionary</a></li><li><a href="#frozen-collections">Frozen Collections</a></li><li><a href="#immutable-collections">Immutable Collections</a></li><li><a href="#bitarray">BitArray</a></li><li><a href="#collection-expressions">Collection Expressions</a></li></ul></li><li><a href="#file-i-o">File I/O</a></li><li><a href="#networking">Networking</a><ul><li><a href="#networking-primitives">Networking Primitives</a></li><li><a href="#sockets">Sockets</a></li><li><a href="#tls">TLS</a></li><li><a href="#http">HTTP</a></li></ul></li><li><a href="#json">JSON</a></li><li><a href="#cryptography">Cryptography</a></li><li><a href="#logging">Logging</a></li><li><a href="#configuration">Configuration</a></li><li><a href="#peanut-butter">Peanut Butter</a></li><li><a href="#whats-next">What‚Äôs Next?</a></li></ul><h2 id="benchmarking-setup">Benchmarking Setup</h2><p>Throughout this post, I include microbenchmarks to highlight various aspects of the improvements being discussed. Most of those benchmarks are implemented using <a href="https://benchmarkdotnet.org/">BenchmarkDotNet</a><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.8">v0.13.8</a>, and, unless otherwise noted, there is a simple setup for each of these benchmarks.</p><p>To follow along, first make sure you have <a href="https://dotnet.microsoft.com/download/dotnet/7.0?wt.mc_id=net8perf">.NET 7</a> and <a href="https://dotnet.microsoft.com/download/dotnet/8.0?wt.mc_id=net8perf">.NET 8</a> installed. For this post, I‚Äôve used the .NET 8 Release Candidate (8.0.0-rc.1.23419.4).</p><p>With those prerequisites taken care of, create a new C# project in a new <code>benchmarks</code> directory:</p><pre><code class="language-sh">dotnet new console -o benchmarks
cd benchmarks</code></pre><p>That directory will contain two files: <code>benchmarks.csproj</code> (the project file with information about how the application should be built) and <code>Program.cs</code> (the code for the application). Replace the entire contents of <code>benchmarks.csproj</code> with this:</p><pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFrameworks&gt;net8.0;net7.0&lt;/TargetFrameworks&gt;
    &lt;LangVersion&gt;Preview&lt;/LangVersion&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
    &lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;BenchmarkDotNet&quot; Version=&quot;0.13.8&quot; /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;</code></pre><p>The preceding project file tells the build system we want:</p><ul><li>to build a runnable application (as opposed to a library),</li><li>to be able to run on both .NET 8 and .NET 7 (so that BenchmarkDotNet can run multiple processes, one with .NET 7 and one with .NET 8, in order to be able to compare the results),</li><li>to be able to use all of the latest features from the C# language even though C# 12 hasn‚Äôt officially shipped yet,</li><li>to automatically import common namespaces,</li><li>to be able to use the <code>unsafe</code> keyword in the code,</li><li>and to configure the garbage collector (GC) into its ‚Äúserver‚Äù configuration, which impacts the tradeoffs it makes between memory consumption and throughput (this isn‚Äôt strictly necessary, I‚Äôm just in the habit of using it, and it‚Äôs the default for ASP.NET apps.)</li></ul><p>The <code>&lt;PackageReference/&gt;</code> at the end pulls in BenchmarkDotNet from <a href="https://www.nuget.org/">NuGet</a> so that we‚Äôre able to use the library in <code>Program.cs</code>. (A handful of benchmarks require additional packages be added; I‚Äôve noted those where applicable.)</p><p>For each benchmark, I‚Äôve then included the full <code>Program.cs</code> source; just copy and paste that code into <code>Program.cs</code>, replacing its entire contents. In each test, you‚Äôll notice several attributes may be applied to the <code>Tests</code> class. The <code>[MemoryDiagnoser]</code> attribute indicates I want it to track managed allocation, the <code>[DisassemblyDiagnoser]</code> attribute indicates I want it to report on the actual assembly code generated for the test (and by default one level deep of functions invoked by the test), and the <code>[HideColumns]</code> attribute simply suppresses some columns of data BenchmarkDotNet might otherwise emit by default but are unnecessary for our purposes here.</p><p>Running the benchmarks is then straightforward. Each shown test also includes a comment at the beginning for the <code>dotnet</code> command to run the benchmark. Typically, it‚Äôs something like this:</p><pre><code class="language-sh">dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0</code></pre><p>The preceding <code>dotnet run</code> command:</p><ul><li>builds the benchmarks in a Release build. This is important for performance testing, as most optimizations are disabled in Debug builds, in both the C# compiler and the JIT compiler.</li><li>targets .NET 7 for the host project. In general with BenchmarkDotNet, you want to target the lowest-common denominator of all runtimes you‚Äôll be executing against, so as to ensure that all of the APIs being used are available everywhere they‚Äôre needed.</li><li>runs all of the benchmarks in the whole program. The <code>--filter</code> argument can be refined to scope down to just a subset of benchmarks desired, but <code>&quot;*&quot;</code> says ‚Äúrun ‚Äôem all.‚Äù</li><li>runs the tests on both .NET 7 and .NET 8.</li></ul><p>Throughout the post, I‚Äôve shown many benchmarks and the results I received from running them. All of the code works well on all supported operating systems and architectures. Unless otherwise stated, the results shown for benchmarks are from running them on Linux (Ubuntu 22.04) on an x64 processor (the one bulk exception to this is when I‚Äôve used <code>[DisassemblyDiagnoser]</code> to show assembly code, in which case I‚Äôve run them on Windows 11 due to a sporadic issue on Unix with <code>[DisassemblyDiagnoser]</code> on .NET 7 not always producing the requested assembly). My standard caveat: these are <em>microbenchmarks</em>, often measuring operations that take very short periods of time, but where improvements to those times add up to be impactful when executed over and over and over. Different hardware, different operating systems, what else is running on your machine, your current mood, and what you ate for breakfast can all affect the numbers involved. In short, don‚Äôt expect the numbers you see to match exactly the numbers I report here, though I have chosen examples where the <em>magnitude</em> of differences cited is expected to be fully repeatable.</p><p>With all that out of the way, let‚Äôs dive in‚Ä¶</p><h2 id="jit">JIT</h2><p>Code generation permeates every single line of code we write, and it‚Äôs critical to the end-to-end performance of applications that the compiler doing that code generation achieves high code quality. In .NET, that‚Äôs the job of the Just-In-Time (JIT) compiler, which is used both ‚Äújust in time‚Äù as an application executes as well as in Ahead-Of-Time (AOT) scenarios as the workhorse to perform the codegen at build-time. Every release of .NET has seen significant improvements in the JIT, and .NET 8 is no exception. In fact, I dare say the improvements in .NET 8 in the JIT are an incredible leap beyond what was achieved in the past, in large part due to dynamic PGO‚Ä¶</p><h3 id="tiering-and-dynamic-pgo">Tiering and Dynamic PGO</h3><p>To understand dynamic PGO, we first need to understand ‚Äútiering.‚Äù For many years, a .NET method was only ever compiled once: on first invocation of the method, the JIT would kick in to generate code for that method, and then that invocation and every subsequent one would use that generated code. It was a simple time, but also one frought with conflict‚Ä¶ in particular, a conflict between how much the JIT should invest in code quality for the method and how much benefit would be gained from that enhanced code quality. Optimization is one of the most expensive things a compiler does; a compiler can spend an untold amount of time searching for additional ways to shave off an instruction here or improve the instruction sequence there. But none of us has an infinite amount of time to wait for the compiler to finish, especially in a ‚Äújust in time‚Äù scenario where the compilation is happening as the application is running. As such, in a world where a method is compiled once for that process, the JIT has to either pessimize code quality or pessimize how long it takes to run, which means a tradeoff between steady-state throughput and startup time.</p><p>As it turns out, however, the vast majority of methods invoked in an application are only ever invoked once or a small number of times. Spending a lot of time optimizing such methods would actually be a deoptimization, as likely it would take much more time to optimize them than those optimizations would gain. So, .NET Core 3.0 introduced a new feature of the JIT known as ‚Äútiered compilation.‚Äù With tiering, a method could end up being compiled multiple times. On first invocation, the method would be compiled in ‚Äútier 0,‚Äù in which the JIT prioritizes speed of compilation over code quality; in fact, the mode the JIT uses is often referred to as ‚Äúmin opts,‚Äù or minimal optimization, because it does as little optimization as it can muster (it still maintains a few optimizations, primarily the ones that result in less code to be compiled such that the JIT actually runs faster). In addition to minimizing optimizations, however, it also employs call counting ‚Äústubs‚Äù; when you invoke the method, the call goes through a little piece of code (the stub) that counts how many times the method was invoked, and once that count crosses a predetermined threshold (e.g. 30 calls), the method gets queued for re-compilation, this time at ‚Äútier 1,‚Äù in which the JIT throws every optimization it‚Äôs capable of at the method. Only a small subset of methods make it to tier 1, and those that do are the ones worthy of additional investment in code quality. Interestingly, there are things the JIT can learn about the method from tier 0 that can lead to even better tier 1 code quality than if the method had been compiled to tier 1 directly. For example, the JIT knows that a method ‚Äútiering up‚Äù from tier 0 to tier 1 has already been executed, and if it‚Äôs already been executed, then any <code>static readonly</code> fields it accesses are now already initialized, which means the JIT can look at the values of those fields and base the tier 1 code gen on what‚Äôs actually in the field (e.g. if it‚Äôs a <code>static readonly bool</code>, the JIT can now treat the value of that field as if it were <code>const bool</code>). If the method were instead compiled directly to tier 1, the JIT might not be able to make the same optimizations. Thus, with tiering, we can ‚Äúhave our cake and eat it, too.‚Äù We get both good startup and good throughput. Mostly‚Ä¶</p><p>One wrinkle to this scheme, however, is the presence of longer-running methods. Methods might be important because they‚Äôre invoked many times, but they might also be important because they‚Äôre invoked only a few times but end up running forever, in particular due to looping. As such, tiering was disabled by default for methods containing backward branches, such that those methods would go straight to tier 1. To address that, .NET 7 introduced On-Stack Replacement (OSR). With OSR, the code generated for loops also included a counting mechanism, and after a loop iterated to a certain threshold, the JIT would compile a new optimized version of the method and jump from the minimally-optimized code to continue execution in the optimized variant. Pretty slick, and with that, in .NET 7 tiering was also enabled for methods with loops.</p><p>But why is OSR important? If there are only a few such long-running methods, what‚Äôs the big deal if they just go straight to tier 1? Surely startup isn‚Äôt significantly negatively impacted? First, it can be: if you‚Äôre trying to trim milliseconds off startup time, every method counts. But second, as noted before, there are throughput benefits to going through tier 0, in that there are things the JIT can learn about a method from tier 0 which can then improve its tier 1 compilation. And the list of things the JIT can learn gets a whole lot bigger with dynamic PGO.</p><p>Profile-Guided Optimization (PGO) has been around for decades, for many languages and environments, including in .NET world. The typical flow is you build your application with some additional instrumentation, you then run your application on key scenarios, you gather up the results of that instrumentation, and then you rebuild your application, feeding that instrumentation data into the optimizer, allowing it to use the knowledge about how the code executed to impact how it‚Äôs optimized. This approach is often referred to as ‚Äústatic PGO.‚Äù ‚ÄúDynamic PGO‚Äù is similar, except there‚Äôs no effort required around how the application is built, scenarios it‚Äôs run on, or any of that. With tiering, the JIT is already generating a tier 0 version of the code and then a tier 1 version of the code‚Ä¶ why not sprinkle some instrumentation into the tier 0 code as well? Then the JIT can use the results of that instrumentation to better optimize tier 1. It‚Äôs the same basic ‚Äúbuild, run and collect, re-build‚Äù flow as with static PGO, but now on a per-method basis, entirely within the execution of the application, and handled automatically for you by the JIT, with zero additional dev effort required and zero additional investment needed in build automation or infrastructure.</p><p>Dynamic PGO first previewed in .NET 6, off by default. It was improved in .NET 7, but remained off by default. Now, in .NET 8, I‚Äôm thrilled to say it‚Äôs not only been significantly improved, it‚Äôs now on by default. This one-character PR to enable it might be the most valuable PR in all of .NET 8: <a href="https://github.com/dotnet/runtime/pull/86225">dotnet/runtime#86225</a>.</p><p>There have been a multitude of PRs to make all of this work better in .NET 8, both on tiering in general and then on dynamic PGO in particular. One of the more interesting changes is <a href="https://github.com/dotnet/runtime/pull/70941">dotnet/runtime#70941</a>, which added more tiers, though we still refer to the unoptimized as ‚Äútier 0‚Äù and the optimized as ‚Äútier 1.‚Äù This was done primarily for two reasons. First, instrumentation isn‚Äôt free; if the goal of tier 0 is to make compilation as cheap as possible, then we want to avoid adding yet more code to be compiled. So, the PR adds a new tier to address that. Most code first gets compiled to an unoptimized and uninstrumented tier (though methods with loops currently skip this tier). Then after a certain number of invocations, it gets recompiled unoptimized but instrumented. And then after a certain number of invocations, it gets compiled as optimized using the resulting instrumentation data. Second, <code>crossgen</code>/<code>ReadyToRun</code> (R2R) images were previously unable to participate in dynamic PGO. This was a <em>big</em> problem for taking full advantage of all that dynamic PGO offers, in particular because there‚Äôs a significant amount of code that every .NET application uses that‚Äôs already R2R‚Äôd: the core libraries. <code>ReadyToRun</code> is an AOT technology that enables most of the code generation work to be done at build-time, with just some minimal fix-ups applied when that precompiled code is prepared for execution. That code is optimized and not instrumented, or else the instrumentation would slow it down. So, this PR also adds a new tier for R2R. After an R2R method has been invoked some number of times, it‚Äôs recompiled, again with optimizations but this time also with instrumentation, and then when that‚Äôs been invoked sufficiently, it‚Äôs promoted again, this time to an optimized implementation utilizing the instrumentation data gathered in the previous tier.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/TierFlow.png" alt="Code flow between JIT tiers" /></p><p>There have also been multiple changes focused on doing more optimization in tier 0. As noted previously, the JIT wants to be able to compile tier 0 as quickly as possible, however some optimizations in code quality actually help it to do that. For example, <a href="https://github.com/dotnet/runtime/pull/82412">dotnet/runtime#82412</a> teaches it to do some amount of constant folding (evaluating constant expressions at compile time rather than at execution time), as that can enable it to generate much less code. Much of the time the JIT spends compiling in tier 0 is for interactions with the Virtual Machine (VM) layer of the .NET runtime, such as resolving types, and so if it can significantly trim away branches that won‚Äôt ever be used, it can actually speed up tier 0 compilation while also getting better code quality. We can see this with a simple repro app like the following:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0

MaybePrint(42.0);

static void MaybePrint&lt;T&gt;(T value)
{
    if (value is int)
        Console.WriteLine(value);
}</code></pre><p>I can set the <code>DOTNET_JitDisasm</code> environment variable to <code>*MaybePrint*</code>; that will result in the JIT printing out to the console the code it emits for this method. On .NET 7, when I run this (<code>dotnet run -c Release -f net7.0</code>), I get the following tier 0 code:</p><pre><code class="language-assembly">; Assembly listing for method Program:&lt;&lt;Main&gt;$&gt;g__MaybePrint|0_0[double](double)
; Emitting BLENDED_CODE for X64 CPU with AVX - Windows
; Tier-0 compilation
; MinOpts code
; rbp based frame
; partially interruptible

G_M000_IG01:                ;; offset=0000H
       55                   push     rbp
       4883EC30             sub      rsp, 48
       C5F877               vzeroupper
       488D6C2430           lea      rbp, [rsp+30H]
       33C0                 xor      eax, eax
       488945F8             mov      qword ptr [rbp-08H], rax
       C5FB114510           vmovsd   qword ptr [rbp+10H], xmm0

G_M000_IG02:                ;; offset=0018H
       33C9                 xor      ecx, ecx
       85C9                 test     ecx, ecx
       742D                 je       SHORT G_M000_IG03
       48B9B877CB99F97F0000 mov      rcx, 0x7FF999CB77B8
       E813C9AE5F           call     CORINFO_HELP_NEWSFAST
       488945F8             mov      gword ptr [rbp-08H], rax
       488B4DF8             mov      rcx, gword ptr [rbp-08H]
       C5FB104510           vmovsd   xmm0, qword ptr [rbp+10H]
       C5FB114108           vmovsd   qword ptr [rcx+08H], xmm0
       488B4DF8             mov      rcx, gword ptr [rbp-08H]
       FF15BFF72000         call     [System.Console:WriteLine(System.Object)]

G_M000_IG03:                ;; offset=0049H
       90                   nop

G_M000_IG04:                ;; offset=004AH
       4883C430             add      rsp, 48
       5D                   pop      rbp
       C3                   ret

; Total bytes of code 80</code></pre><p>The important thing to note here is that all of the code associated with the <code>Console.WriteLine</code> had to be emitted, including the JIT needing to resolve the method tokens involved (which is how it knew to print ‚ÄúSystem.Console:WriteLine‚Äù), even though that branch will provably never be taken (it‚Äôs only taken when <code>value is int</code> and the JIT can see that <code>value</code> is a <code>double</code>). Now in .NET 8, it applies the previously-reserved-for-tier-1 constant folding optimizations that recognize the value is not an <code>int</code> and generates tier 0 code accordingly (<code>dotnet run -c Release -f net8.0</code>):</p><pre><code class="language-assembly">; Assembly listing for method Program:&lt;&lt;Main&gt;$&gt;g__MaybePrint|0_0[double](double) (Tier0)
; Emitting BLENDED_CODE for X64 with AVX - Windows
; Tier0 code
; rbp based frame
; partially interruptible

G_M000_IG01:                ;; offset=0x0000
       push     rbp
       mov      rbp, rsp
       vmovsd   qword ptr [rbp+0x10], xmm0

G_M000_IG02:                ;; offset=0x0009

G_M000_IG03:                ;; offset=0x0009
       pop      rbp
       ret

; Total bytes of code 11</code></pre><p><a href="https://github.com/dotnet/runtime/pull/77357">dotnet/runtime#77357</a> and <a href="https://github.com/dotnet/runtime/pull/83002">dotnet/runtime#83002</a> also enable some JIT intrinsics to be employed in tier 0 (a JIT intrinsic is a method the JIT has some special knowledge of, either knowing about its behavior so it can optimize around it accordingly, or in many cases actually supplying its own implementation to replace the one in the method‚Äôs body). This is in part for the same reason; many intrinsics can result in better dead code elimination (e.g. <code>if (typeof(T).IsValueType) { ... }</code>). But more so, without recognizing intrinsics as being special, we might end up generating code for an intrinsic method that we would never otherwise need to generate code for, even in tier 1. <a href="https://github.com/dotnet/runtime/pull/88989">dotnet/runtime#88989</a> also eliminates some forms of boxing in tier 0.</p><p>Collecting all of this instrumentation in tier 0 instrumented code brings with it some of its own challenges. The JIT is augmenting a bunch of methods to track a lot of additional data; where and how does it track it? And how does it do so safely and correctly when multiple threads are potentially accessing all of this at the same time? For example, one of the things the JIT tracks in an instrumented method is which branches are followed and how frequently; that requires it to count each time code traverses that branch. You can imagine that happens, well, a lot. How can it do the counting in a thread-safe yet efficient way?</p><p>The answer previously was, it didn‚Äôt. It used racy, non-synchronized updates to a shared value, e.g. <code>_branches[branchNum]++</code>. This means that some updates might get lost in the presence of multithreaded access, but as the answer here only needs to be approximate, that was deemed ok. As it turns out, however, in some cases it was resulting in <em>a lot</em> of lost counts, which in turn caused the JIT to optimize for the wrong things. Another approach tried for comparison purposes in <a href="https://github.com/dotnet/runtime/pull/82775">dotnet/runtime#82775</a> was to use interlocked operations (e.g. if this were C#, <code>Interlocked.Increment</code>); that results in perfect accuracy, but that explicit synchronization represents a huge potential bottleneck when heavily contended. <a href="https://github.com/dotnet/runtime/pull/84427">dotnet/runtime#84427</a> provides the approach that‚Äôs now enabled by default in .NET 8. It‚Äôs an implementation of a scalable approximate counter that employs some amount of pseudo-randomness to decide how often to synchronize and by how much to increment the shared count. There‚Äôs a <a href="https://github.com/dotnet/runtime/blob/e641efb93d6fb6e82bc1aa01e3867ac06572ab93/docs/design/features/ScalableApproximateCounting.md">great description</a> of all of this in the <a href="https://github.com/dotnet/runtime">dotnet/runtime</a> repo; here is a C# implementation of the counting logic based on that discussion:</p><pre><code class="language-C#">static void Count(ref uint sharedCounter)
{
    uint currentCount = sharedCounter, delta = 1;
    if (currentCount &gt; 0)
    {
        int logCount = 31 - (int)uint.LeadingZeroCount(currentCount);
        if (logCount &gt;= 13)
        {
            delta = 1u &lt;&lt; (logCount - 12);
            uint random = (uint)Random.Shared.NextInt64(0, uint.MaxValue + 1L);
            if ((random &amp; (delta - 1)) != 0)
            {
                return;
            }
        }
    }

    Interlocked.Add(ref sharedCounter, delta);
}</code></pre><p>For current count values less than 8192, it ends up just doing the equivalent of an <code>Interlocked.Add(ref counter, 1)</code>. However, as the count increases to beyond that threshold, it starts only doing the add randomly half the time, and when it does, it adds 2. Then randomly a quarter of the time it adds 4. Then an eighth of the time it adds 8. And so on. In this way, as more and more increments are performed, it requires writing to the shared counter less and less frequently.</p><p>We can test this out with a little app like the following (if you want to try running it, just copy the above <code>Count</code> into the program as well):</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0

using System.Diagnostics;

uint counter = 0;
const int ItersPerThread = 100_000_000;

while (true)
{
    Run(&quot;Interlock&quot;, _ =&gt; { for (int i = 0; i &lt; ItersPerThread; i++) Interlocked.Increment(ref counter); });
    Run(&quot;Racy     &quot;, _ =&gt; { for (int i = 0; i &lt; ItersPerThread; i++) counter++; });
    Run(&quot;Scalable &quot;, _ =&gt; { for (int i = 0; i &lt; ItersPerThread; i++) Count(ref counter); });
    Console.WriteLine();
}

void Run(string name, Action&lt;int&gt; body)
{
    counter = 0;
    long start = Stopwatch.GetTimestamp();
    Parallel.For(0, Environment.ProcessorCount, body);
    long end = Stopwatch.GetTimestamp();
    Console.WriteLine($&quot;{name} =&gt; Expected: {Environment.ProcessorCount * ItersPerThread:N0}, Actual: {counter,13:N0}, Elapsed: {Stopwatch.GetElapsedTime(start, end).TotalMilliseconds}ms&quot;);
}</code></pre><p>When I run that, I get results like this:</p><pre><code class="language-text">Interlock =&gt; Expected: 1,200,000,000, Actual: 1,200,000,000, Elapsed: 20185.548ms
Racy      =&gt; Expected: 1,200,000,000, Actual:   138,526,798, Elapsed: 987.4997ms
Scalable  =&gt; Expected: 1,200,000,000, Actual: 1,193,541,836, Elapsed: 1082.8471ms</code></pre><p>I find these results fascinating. The interlocked approach gets the exact right count, but it‚Äôs super slow, ~20x slower than the other approaches. The fastest is the racy additions one, but its count is also wildly inaccurate: it was off by a factor of 8x! The scalable counters solution was only a hair slower than the racy solution, but its count was only off the expected value by 0.5%. This scalable approach then enables the JIT to track what it needs with the efficiency and approximate accuracy it needs. Other PRs like <a href="https://github.com/dotnet/runtime/pull/82014">dotnet/runtime#82014</a>, <a href="https://github.com/dotnet/runtime/pull/81731">dotnet/runtime#81731</a>, and <a href="https://github.com/dotnet/runtime/pull/81932">dotnet/runtime#81932</a> also went into improving the JIT‚Äôs efficiency around tracking this information.</p><p>As it turns out, this isn‚Äôt the only use of randomness in dynamic PGO. Another is used as part of determining which types are the most common targets of virtual and interface method calls. At a given call site, the JIT wants to know which type is most commonly used and by what percentage; if there‚Äôs a clear winner, it can then generate a fast path specific to that type. As in the previous example, tracking a count for every possible type that might come through is expensive. Instead, it uses an algorithm known as <a href="https://en.wikipedia.org/wiki/Reservoir_sampling">‚Äúreservoir sampling‚Äù</a>. Let‚Äôs say I have a <code>char[1_000_000]</code> containing ~60% <code>&#39;a&#39;</code>s, ~30% <code>&#39;b&#39;</code>s, and ~10% <code>&#39;c&#39;</code>s, and I want to know which is the most common. With reservoir sampling, I might do so like this:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0

// Create random input for testing, with 60% a, 30% b, 10% c
char[] chars = new char[1_000_000];
Array.Fill(chars, &#39;a&#39;, 0, 600_000);
Array.Fill(chars, &#39;b&#39;, 600_000, 300_000);
Array.Fill(chars, &#39;c&#39;, 900_000, 100_000);
Random.Shared.Shuffle(chars);

for (int trial = 0; trial &lt; 5; trial++)
{
    // Reservoir sampling
    char[] reservoir = new char[32]; // same reservoir size as the JIT
    int next = 0;
    for (int i = 0; i &lt; reservoir.Length &amp;&amp; next &lt; chars.Length; i++, next++)
    {
        reservoir[i] = chars[i];
    }
    for (; next &lt; chars.Length; next++)
    {
        int r = Random.Shared.Next(next + 1);
        if (r &lt; reservoir.Length)
        {
            reservoir[r] = chars[next];
        }
    }

    // Print resulting percentages
    Console.WriteLine($&quot;a: {reservoir.Count(c =&gt; c == &#39;a&#39;) * 100.0 / reservoir.Length}&quot;);
    Console.WriteLine($&quot;b: {reservoir.Count(c =&gt; c == &#39;b&#39;) * 100.0 / reservoir.Length}&quot;);
    Console.WriteLine($&quot;c: {reservoir.Count(c =&gt; c == &#39;c&#39;) * 100.0 / reservoir.Length}&quot;);
    Console.WriteLine();
}</code></pre><p>When I run this, I get results like the following:</p><pre><code class="language-text">a: 53.125
b: 31.25
c: 15.625

a: 65.625
b: 28.125
c: 6.25

a: 68.75
b: 25
c: 6.25

a: 40.625
b: 31.25
c: 28.125

a: 59.375
b: 25
c: 15.625</code></pre><p>Note that in the above example, I actually had all the data in advance; in contrast, the JIT likely has multiple threads all running instrumented code and overwriting elements in the reservoir. I also happened to choose the same size reservoir the JIT is using as of <a href="https://github.com/dotnet/runtime/pull/87332">dotnet/runtime#87332</a>, which highlights how that value was chosen for its use case and why it needed to be tweaked.</p><p>On all five runs above, it correctly found there to be more <code>&#39;a&#39;</code>s than <code>&#39;b&#39;</code>s and more <code>&#39;b&#39;</code>s than <code>&#39;c&#39;</code>s, and it was often reasonably close to the actual percentages. But, importantly, randomness is involved here, and every run produced slightly different results. I mention this because that means the JIT compiler now incorporates randomness, which means that the produced dynamic PGO instrumentation data is very likely to be slightly different from run to run. However, even without explicit use of randomness, there‚Äôs already non-determinism in such code, and in general there‚Äôs enough data produced that the overall behavior is quite stable and repeatable.</p><p>Interestingly, the JIT‚Äôs PGO-based optimizations aren‚Äôt just based on the data gathered during instrumented tier 0 execution. With <a href="https://github.com/dotnet/runtime/pull/82926">dotnet/runtime#82926</a> (and a handful of follow-on PRs like <a href="https://github.com/dotnet/runtime/pull/83068">dotnet/runtime#83068</a>, <a href="https://github.com/dotnet/runtime/pull/83567">dotnet/runtime#83567</a>, <a href="https://github.com/dotnet/runtime/pull/84312">dotnet/runtime#84312</a>, and <a href="https://github.com/dotnet/runtime/pull/84741">dotnet/runtime#84741</a>), the JIT will now create a synthetic profile based on statically analyzing the code and estimating a profile, such as with various approaches to static branch prediction. The JIT can then blend this data together with the instrumentation data, helping to fill in data where there are gaps (think ‚ÄúJurassic Park‚Äù and using modern reptile DNA to plug the gaps in the recovered dinosaur DNA).</p><p>Beyond the mechanisms used to enable tiering and dynamic PGO getting better (and, did I mention, being on by default?!) in .NET 8, the optimizations it performs also get better. One of the main optimizations dynamic PGO feeds is the ability to devirtualize virtual and interface calls per call site. As noted, the JIT tracks what concrete types are used, and then can generate a fast path for the most common type; this is known as guarded devirtualization (GDV). Consider this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    internal interface IValueProducer
    {
        int GetValue();
    }

    class Producer42 : IValueProducer
    {
        public int GetValue() =&gt; 42;
    }

    private IValueProducer _valueProducer;
    private int _factor = 2;

    [GlobalSetup]
    public void Setup() =&gt; _valueProducer = new Producer42();

    [Benchmark]
    public int GetValue() =&gt; _valueProducer.GetValue() * _factor;
}</code></pre><p>The <code>GetValue</code> method is doing:</p><pre><code class="language-C#">return _valueProducer.GetValue() * _factor;</code></pre><p>Without PGO, that‚Äôs just a normal interface dispatch. With PGO, however, the JIT will end up seeing that the actual type of <code>_valueProducer</code> is most commonly <code>Producer42</code>, and it will end up generating tier 1 code closer to if my benchmark was instead:</p><pre><code class="language-C#">int result = _valueProducer.GetType() == typeof(Producer42) ?
    Unsafe.As&lt;Producer42&gt;(_valueProducer).GetValue() :
    _valueProducer.GetValue();
return result * _factor;</code></pre><p>It can then in turn see that the <code>Producer42.GetValue()</code> method is really simple, and so not only is the <code>GetValue</code> call devirtualized, it‚Äôs also inlined, such that the code effectively becomes:</p><pre><code class="language-C#">int result = _valueProducer.GetType() == typeof(Producer42) ?
    42 :
    _valueProducer.GetValue();
return result * _factor;</code></pre><p>We can confirm this by running the above benchmark. The resulting numbers certainly show something going on:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>GetValue</td><td>.NET 7.0</td><td style="text-align: right">1.6430 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">35 B</td></tr><tr><td>GetValue</td><td>.NET 8.0</td><td style="text-align: right">0.0523 ns</td><td style="text-align: right">0.03</td><td style="text-align: right">57 B</td></tr></tbody></table><p>We see it‚Äôs both faster (which we expected) and more code (which we also expected). Now for the assembly. On .NET 7, we get this:</p><pre><code class="language-assembly">; Tests.GetValue()
       push      rsi
       sub       rsp,20
       mov       rsi,rcx
       mov       rcx,[rsi+8]
       mov       r11,7FF999B30498
       call      qword ptr [r11]
       imul      eax,[rsi+10]
       add       rsp,20
       pop       rsi
       ret
; Total bytes of code 35</code></pre><p>We can see it‚Äôs performing the interface call (the three <code>mov</code>s followed by the <code>call</code>) and then multiplying the result by <code>_factor</code> (<code>imul eax,[rsi+10]</code>). Now on .NET 8, we get this:</p><pre><code class="language-assembly">; Tests.GetValue()
       push      rbx
       sub       rsp,20
       mov       rbx,rcx
       mov       rcx,[rbx+8]
       mov       rax,offset MT_Tests+Producer42
       cmp       [rcx],rax
       jne       short M00_L01
       mov       eax,2A
M00_L00:
       imul      eax,[rbx+10]
       add       rsp,20
       pop       rbx
       ret
M00_L01:
       mov       r11,7FFA1FAB04D8
       call      qword ptr [r11]
       jmp       short M00_L00
; Total bytes of code 57</code></pre><p>We still see the <code>call</code>, but it‚Äôs buried in a cold section at the end. Instead, we see the type of the object being compared against <code>MT_Tests+Producer42</code>, and if it matches (the <code>cmp [rcx],rax</code> followed by the <code>jne</code>), we store <code>2A</code> into <code>eax</code>; <code>2A</code> is the hex representation of <code>42</code>, so this is the entirety of the inlined body of the devirtualized <code>Producer42.GetValue</code> call. .NET 8 is also capable of doing multiple GDVs, meaning it can generate fast paths for more than 1 type, thanks in large part to <a href="https://github.com/dotnet/runtime/pull/86551">dotnet/runtime#86551</a> and <a href="https://github.com/dotnet/runtime/pull/86809">dotnet/runtime#86809</a>. However, this is off by default and for now needs to be opted-into with a configuration setting (setting the <code>DOTNET_JitGuardedDevirtualizationMaxTypeChecks</code> environment variable to the desired maximum number of types for which to test). We can see the impact of that with this benchmark (note that because I‚Äôve explicitly specified the configs to use in the code itself, I‚Äôve omitted the <code>--runtimes</code> argument in the <code>dotnet</code> command):</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;ChecksOne&quot;).WithRuntime(CoreRuntime.Core80))
    .AddJob(Job.Default.WithId(&quot;ChecksThree&quot;).WithRuntime(CoreRuntime.Core80).WithEnvironmentVariable(&quot;DOTNET_JitGuardedDevirtualizationMaxTypeChecks&quot;, &quot;3&quot;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    private readonly A _a = new();
    private readonly B _b = new();
    private readonly C _c = new();

    [Benchmark]
    public void Multiple()
    {
        DoWork(_a);
        DoWork(_b);
        DoWork(_c);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int DoWork(IMyInterface i) =&gt; i.GetValue();

    private interface IMyInterface { int GetValue(); }
    private class A : IMyInterface { public int GetValue() =&gt; 123; }
    private class B : IMyInterface { public int GetValue() =&gt; 456; }
    private class C : IMyInterface { public int GetValue() =&gt; 789; }
}</code></pre><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>Multiple</td><td>ChecksOne</td><td style="text-align: right">7.463 ns</td><td style="text-align: right">90 B</td></tr><tr><td>Multiple</td><td>ChecksThree</td><td style="text-align: right">5.632 ns</td><td style="text-align: right">133 B</td></tr></tbody></table><p>And in the assembly code with the environment variable set, we can indeed see it doing multiple checks for three types before falling back to the general interface dispatch:</p><pre><code class="language-assembly">; Tests.DoWork(IMyInterface)
       sub       rsp,28
       mov       rax,offset MT_Tests+A
       cmp       [rcx],rax
       jne       short M01_L00
       mov       eax,7B
       jmp       short M01_L02
M01_L00:
       mov       rax,offset MT_Tests+B
       cmp       [rcx],rax
       jne       short M01_L01
       mov       eax,1C8
       jmp       short M01_L02
M01_L01:
       mov       rax,offset MT_Tests+C
       cmp       [rcx],rax
       jne       short M01_L03
       mov       eax,315
M01_L02:
       add       rsp,28
       ret
M01_L03:
       mov       r11,7FFA1FAC04D8
       call      qword ptr [r11]
       jmp       short M01_L02
; Total bytes of code 88</code></pre><p>(Interestingly, this optimization gets a bit better in Native AOT. There, with <a href="https://github.com/dotnet/runtime/pull/87055">dotnet/runtime#87055</a>, there can be no need for the fallback path. The compiler can see the entire program being optimized and can generate fast paths for all of the types that implement the target abstraction if it‚Äôs a small number.)</p><p><a href="https://github.com/dotnet/runtime/pull/75140">dotnet/runtime#75140</a> provides another really nice optimization, still related to GDV, but now for delegates and in relation to loop cloning. Take the following benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    private readonly Func&lt;int, int&gt; _func = i =&gt; i + 1;

    [Benchmark]
    public int Sum() =&gt; Sum(_func);

    private static int Sum(Func&lt;int, int&gt; func)
    {
        int sum = 0;
        for (int i = 0; i &lt; 10_000; i++)
        {
            sum += func(i);
        }

        return sum;
    }
}</code></pre><p>Dynamic PGO is capable of doing GDV with delegates just as it is with virtual and interface methods. The JIT‚Äôs profiling of this method will highlight that the function being invoked is always the same <code>i =&gt; i + 1</code> lambda, and as we saw, that can then be transformed into a method something like the following pseudo-code:</p><pre><code class="language-C#">private static int Sum(Func&lt;int, int&gt; func)
{
    int sum = 0;
    for (int i = 0; i &lt; 10_000; i++)
    {
        sum += func.Method == KnownLambda ? i + 1 : func(i);
    }

    return sum;
}</code></pre><p>It‚Äôs not very visible that inside our loop we‚Äôre performing the same check over and over and over. We‚Äôre also branching based on it. One common compiler optimization is ‚Äúhoisting,‚Äù where a computation that‚Äôs ‚Äúloop invariant‚Äù (meaning it doesn‚Äôt change per iteration) can be pulled out of the loop to be above it, e.g.</p><pre><code class="language-C#">private static int Sum(Func&lt;int, int&gt; func)
{
    int sum = 0;
    bool isAdd = func.Method == KnownLambda;
    for (int i = 0; i &lt; 10_000; i++)
    {
        sum += isAdd ? i + 1 : func(i);
    }

    return sum;
}</code></pre><p>but even with that, we still have the branch on each iteration. Wouldn‚Äôt it be nice if we could hoist that as well? What if we could ‚Äúclone‚Äù the loop, duplicating it once for when the method is the known target and once for when it‚Äôs not. That‚Äôs ‚Äúloop cloning,‚Äù an optimization the JIT is already capable of for other reasons, and now in .NET 8 the JIT is capable of that with this exact scenario, too. The code it‚Äôll produce ends up then being very similar to this:</p><pre><code class="language-C#">private static int Sum(Func&lt;int, int&gt; func)
{
    int sum = 0;
    if (func.Method == KnownLambda)
    {
        for (int i = 0; i &lt; 10_000; i++)
        {
            sum += i + 1;
        }
    }
    else
    {
        for (int i = 0; i &lt; 10_000; i++)
        {
            sum += func(i);
        }
    }
    return sum;
}</code></pre><p>Looking at the generated assembly on .NET 8 confirms this:</p><pre><code class="language-assembly">; Tests.Sum(System.Func`2&lt;Int32,Int32&gt;)
       push      rdi
       push      rsi
       push      rbx
       sub       rsp,20
       mov       rbx,rcx
       xor       esi,esi
       xor       edi,edi
       test      rbx,rbx
       je        short M01_L01
       mov       rax,7FFA2D630F78
       cmp       [rbx+18],rax
       jne       short M01_L01
M01_L00:
       inc       edi
       mov       eax,edi
       add       esi,eax
       cmp       edi,2710
       jl        short M01_L00
       jmp       short M01_L03
M01_L01:
       mov       rax,7FFA2D630F78
       cmp       [rbx+18],rax
       jne       short M01_L04
       lea       eax,[rdi+1]
M01_L02:
       add       esi,eax
       inc       edi
       cmp       edi,2710
       jl        short M01_L01
M01_L03:
       mov       eax,esi
       add       rsp,20
       pop       rbx
       pop       rsi
       pop       rdi
       ret
M01_L04:
       mov       edx,edi
       mov       rcx,[rbx+8]
       call      qword ptr [rbx+18]
       jmp       short M01_L02
; Total bytes of code 103</code></pre><p>Focus just on the <code>M01_L00</code> block: you can see it ends with a <code>jl short M01_L00</code> to loop back around to <code>M01_L00</code> if <code>edi</code> (which is storing <code>i</code>) is less than 0x2710, or 10,000 decimal, aka our loop‚Äôs upper bound. Note that there are just a few instructions in the middle, nothing at all resembling a <code>call</code>‚Ä¶ this is the optimized cloned loop, where our lambda has been inlined. There‚Äôs another loop that alternates between <code>M01_L02</code>, <code>M01_L01</code>, and <code>M01_L04</code>, and that one does have a <code>call</code>‚Ä¶ that‚Äôs the fallback loop. And if we run the benchmark, we see a huge resulting improvement:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>Sum</td><td>.NET 7.0</td><td style="text-align: right">16.546 us</td><td style="text-align: right">1.00</td><td style="text-align: right">55 B</td></tr><tr><td>Sum</td><td>.NET 8.0</td><td style="text-align: right">2.320 us</td><td style="text-align: right">0.14</td><td style="text-align: right">113 B</td></tr></tbody></table><p>As long as we‚Äôre discussing hoisting, it‚Äôs worth noting other improvements have also contributed. In particular, <a href="https://github.com/dotnet/runtime/pull/81635">dotnet/runtime#81635</a> enables the JIT to hoist more code used in generic method dispatch. We can see that in action with a benchmark like this:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    [Benchmark]
    public void Test() =&gt; Test&lt;string&gt;();

    static void Test&lt;T&gt;()
    {
        for (int i = 0; i &lt; 100; i++)
        {
            Callee&lt;T&gt;();
        }
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    static void Callee&lt;T&gt;() { }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Test</td><td>.NET 7.0</td><td style="text-align: right">170.8 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Test</td><td>.NET 8.0</td><td style="text-align: right">147.0 ns</td><td style="text-align: right">0.86</td></tr></tbody></table><p>Before moving on, one word of warning about dynamic PGO: it‚Äôs good at what it does, really good. Why is that a ‚Äúwarning?‚Äù Dynamic PGO is very good about seeing what your code is doing and optimizing for it, which is awesome when you‚Äôre talking about your production applications. But there‚Äôs a particular kind of coding where you might not want that to happen, or at least you need to be acutely aware of it happening, and you‚Äôre currently looking at it: benchmarks. Microbenchmarks are all about isolating a particular piece of functionality and running that over and over and over and over in order to get good measurements about its overhead. With dynamic PGO, however, the JIT will then optimize for the exact thing you‚Äôre testing. If the thing you‚Äôre testing is exactly how the code will execute in production, then awesome. But if your test isn‚Äôt fully representative, you can get a skewed understanding of the costs involved, which can lead to making less-than-ideal assumptions and decisions.</p><p>For example, consider this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;No PGO&quot;).WithRuntime(CoreRuntime.Core80).WithEnvironmentVariable(&quot;DOTNET_TieredPGO&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;PGO&quot;).WithRuntime(CoreRuntime.Core80));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;)]
public class Tests
{
    private static readonly Random s_rand = new();
    private readonly IEnumerable&lt;int&gt; _source = Enumerable.Repeat(0, 1024);

    [Params(1.0, 0.5)]
    public double Probability { get; set; }

    [Benchmark]
    public bool Any() =&gt; s_rand.NextDouble() &lt; Probability ?
        _source.Any(i =&gt; i == 42) :
        _source.Any(i =&gt; i == 43);
}</code></pre><p>This runs a benchmark with two different ‚ÄúProbability‚Äù values. Regardless of that value, the code that‚Äôs executed for the benchmark does exactly the same thing and should result in exactly the same assembly code (other than one path checking for the value <code>42</code> and the other for <code>43</code>). In a world without PGO, there should be close to zero difference in performance between the runs, and if we set the <code>DOTNET_TieredPGO</code> environment variable to <code>0</code> (to disable PGO), that‚Äôs exactly what we see, but with PGO, we observe a larger difference:</p><table><thead><tr><th>Method</th><th>Job</th><th>Probability</th><th style="text-align: right">Mean</th></tr></thead><tbody><tr><td>Any</td><td>No PGO</td><td>0.5</td><td style="text-align: right">5.354 us</td></tr><tr><td>Any</td><td>No PGO</td><td>1</td><td style="text-align: right">5.314 us</td></tr><tr><td>Any</td><td>PGO</td><td>0.5</td><td style="text-align: right">1.969 us</td></tr><tr><td>Any</td><td>PGO</td><td>1</td><td style="text-align: right">1.495 us</td></tr></tbody></table><p>When all of the calls use <code>i == 42</code> (because we set the probability to 1, all of the random values are less than that, and we always take the first branch), we see throughput ends up being 25% faster than when half of the calls use <code>i == 42</code> and half use <code>i == 43</code>. If your benchmark was only trying to measure the overhead of using <code>Enumerable.Any</code>, you might not realize that the resulting code was being optimized for calling <code>Any</code> with the same delegate every time, in which case you get different results than if <code>Any</code> is called with multiple delegates and all with reasonably equal chances of being used. (As an aside, the nice overall improvement between dynamic PGO being disabled and enabled comes in part from the use of <code>Random</code>, which internally makes a virtual call that <code>dynamic PGO</code> can help elide.)</p><p>Throughout the rest of this post, I‚Äôve kept this in mind and tried hard to show benchmarks where the resulting wins are due primarily to the cited improvements in the relevant code; where dynamic PGO plays a larger role in the improvements, I‚Äôve called that out, often showing the results with and without dynamic PGO. There are many more benchmarks I could have shown but have avoided where it would look like a particular method had massive improvements, yet in reality it‚Äôd all be due to dynamic PGO being its awesome self rather than some explicit change made to the method‚Äôs C# code.</p><p>One final note about dynamic PGO: it‚Äôs awesome, but it doesn‚Äôt obviate the need for thoughtful coding. If you know and can use something‚Äôs concrete type rather than an abstraction, from a performance perspective it‚Äôs better to do so rather than hoping the JIT will be able to see through it and devirtualize. To help with this, a new analyzer, <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1859">CA1859</a>, was added to the .NET SDK in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6370">dotnet/roslyn-analyzers#6370</a>. The analyzer looks for places where interfaces or base classes could be replaced by derived types in order to avoid interface and virtual dispatch.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1859.png" alt="CA1859" /><a href="https://github.com/dotnet/runtime/pull/80335">dotnet/runtime#80335</a> and <a href="https://github.com/dotnet/runtime/pull/80848">dotnet/runtime#80848</a> rolled this out across <a href="https://github.com/dotnet/runtime">dotnet/runtime</a>. As you can see from the first PR in particular, there were hundreds of places identified that with just an edit of one character (e.g. replacing <code>IList&lt;T&gt;</code> with <code>List&lt;T&gt;</code>), we could possibly reduce overheads.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;No PGO&quot;).WithRuntime(CoreRuntime.Core80).WithEnvironmentVariable(&quot;DOTNET_TieredPGO&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;PGO&quot;).WithRuntime(CoreRuntime.Core80));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;)]
public class Tests
{
    private readonly IList&lt;int&gt; _ilist = new List&lt;int&gt;();
    private readonly List&lt;int&gt; _list = new();

    [Benchmark]
    public void IList()
    {
        _ilist.Add(42);
        _ilist.Clear();
    }

    [Benchmark]
    public void List()
    {
        _list.Add(42);
        _list.Clear();
    }
}</code></pre><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th></tr></thead><tbody><tr><td>IList</td><td>No PGO</td><td style="text-align: right">2.876 ns</td></tr><tr><td>IList</td><td>PGO</td><td style="text-align: right">1.777 ns</td></tr><tr><td>List</td><td>No PGO</td><td style="text-align: right">1.718 ns</td></tr><tr><td>List</td><td>PGO</td><td style="text-align: right">1.476 ns</td></tr></tbody></table><h2 id="vectorization">Vectorization</h2><p>Another huge area of investment in code generation in .NET 8 is around vectorization. This is a continuation of a theme that‚Äôs been going for multiple .NET releases. Almost a decade ago, .NET gained the <code>Vector&lt;T&gt;</code> type. .NET Core 3.0 and .NET 5 added thousands of intrinsic methods for directly targeting specific hardware instructions. .NET 7 provided hundreds of cross-platform operations for <a href="https://github.com/dotnet/runtime/blob/8323e58d7b587deceb7ef39e61725bce7bfe86f8/docs/coding-guidelines/vectorization-guidelines.md"><code>Vector128&lt;T&gt;</code> and <code>Vector256&lt;T&gt;</code></a> to enable SIMD algorithms on fixed-width vectors. And now in .NET 8, .NET gains support for AVX512, both with new hardware intrinsics directly exposing AVX512 instructions and with the new <code>Vector512</code> and <code>Vector512&lt;T&gt;</code> types.</p><p>There were a plethora of changes that went into improving existing SIMD support, such as <a href="https://github.com/dotnet/runtime/pull/76221">dotnet/runtime#76221</a> that improves the handling of <code>Vector256&lt;T&gt;</code> when it‚Äôs not hardware accelerated by lowering it as two <code>Vector128&lt;T&gt;</code> operations. Or like <a href="https://github.com/dotnet/runtime/pull/87283">dotnet/runtime#87283</a>, which removed the generic constraint on the <code>T</code> in all of the vector types in order to make them easier to use in a larger set of contexts. But the bulk of the work in this area in this release is focused on AVX512.</p><p>Wikipedia has a good overview of <a href="https://en.wikipedia.org/wiki/AVX-512">AVX512</a>, which provides instructions for processing 512-bits at a time. In addition to providing wider versions of the 256-bit instructions seen in previous instruction sets, it also adds a variety of new operations, almost all of which are exposed via one of the new types in <code>System.Runtime.Intrinsics.X86</code>, like <code>Avx512BW</code>, <code>AVX512CD</code>, <code>Avx512DQ</code>, <code>Avx512F</code>, and <code>Avx512Vbmi</code>. <a href="https://github.com/dotnet/runtime/pull/83040">dotnet/runtime#83040</a> kicked things off by stubbing out the various files, followed by dozens of PRs that filled in the functionality, for example <a href="https://github.com/dotnet/runtime/pull/84909">dotnet/runtime#84909</a> that added the 512-bit variants of the SSE through SSE4.2 intrinsics that already exist; like <a href="https://github.com/dotnet/runtime/pull/75934">dotnet/runtime#75934</a> from <a href="https://github.com/DeepakRajendrakumaran">@DeepakRajendrakumaran</a> and <a href="https://github.com/dotnet/runtime/pull/77419">dotnet/runtime#77419</a> from <a href="https://github.com/DeepakRajendrakumaran">@DeepakRajendrakumaran</a> that added support for the EVEX encoding used by AVX512 instructions; like <a href="https://github.com/dotnet/runtime/pull/74113">dotnet/runtime#74113</a> from <a href="https://github.com/DeepakRajendrakumaran">@DeepakRajendrakumaran</a> that added the logic for detecting AVX512 support; like <a href="https://github.com/dotnet/runtime/pull/80960">dotnet/runtime#80960</a> from <a href="https://github.com/DeepakRajendrakumaran">@DeepakRajendrakumaran</a> and <a href="https://github.com/dotnet/runtime/pull/79544">dotnet/runtime#79544</a> from <a href="https://github.com/anthonycanino">@anthonycanino</a> that enlightened the register allocator and emitter about AVX512‚Äôs additional registers; and like <a href="https://github.com/dotnet/runtime/pull/87946">dotnet/runtime#87946</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a> and <a href="https://github.com/dotnet/runtime/pull/84937">dotnet/runtime#84937</a> from <a href="https://github.com/jkrishnavs">@jkrishnavs</a> that plumbed through knowledge of various intrinsics.</p><p>Let‚Äôs take it for a spin. The machine on which I‚Äôm writing this doesn‚Äôt have AVX512 support, but my <a href="https://azure.microsoft.com/products/dev-box/">Dev Box</a> does, so I‚Äôm using that for AVX512 comparisons (using <a href="https://learn.microsoft.com/windows/wsl/">WSL</a> with Ubuntu). In last year‚Äôs <a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/#vectorization">Performance Improvements in .NET 7</a>, we wrote a <code>Contains</code> method that used <code>Vector256&lt;T&gt;</code> if there was sufficient data available and it was accelerated, or else <code>Vector128&lt;T&gt;</code> if there was sufficient data available and it was accelerated, or else a scalar fallback. Tweaking that to also ‚Äúlight up‚Äù with AVX512 took me literally less than 30 seconds: copy/paste the code block for <code>Vector256</code> and then search and replace in that copy from ‚ÄúVector256‚Äù to ‚ÄúVector512‚Ä≥‚Ä¶ boom, done. Here it is in a benchmark, using environment variables to disable the JIT‚Äôs ability to use the various instruction sets so that we can try out this method with each acceleration path:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;Scalar&quot;).WithEnvironmentVariable(&quot;DOTNET_EnableHWIntrinsic&quot;, &quot;0&quot;).AsBaseline())
    .AddJob(Job.Default.WithId(&quot;Vector128&quot;).WithEnvironmentVariable(&quot;DOTNET_EnableAVX2&quot;, &quot;0&quot;).WithEnvironmentVariable(&quot;DOTNET_EnableAVX512F&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;Vector256&quot;).WithEnvironmentVariable(&quot;DOTNET_EnableAVX512F&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;Vector512&quot;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;, &quot;value&quot;)]
public class Tests
{
    private readonly byte[] _data = Enumerable.Repeat((byte)123, 999).Append((byte)42).ToArray();

    [Benchmark]
    [Arguments((byte)42)]
    public bool Find(byte value) =&gt; Contains(_data, value);

    private static unsafe bool Contains(ReadOnlySpan&lt;byte&gt; haystack, byte needle)
    {
        if (Vector128.IsHardwareAccelerated &amp;&amp; haystack.Length &gt;= Vector128&lt;byte&gt;.Count)
        {
            ref byte current = ref MemoryMarshal.GetReference(haystack);

            if (Vector512.IsHardwareAccelerated &amp;&amp; haystack.Length &gt;= Vector512&lt;byte&gt;.Count)
            {
                Vector512&lt;byte&gt; target = Vector512.Create(needle);
                ref byte endMinusOneVector = ref Unsafe.Add(ref current, haystack.Length - Vector512&lt;byte&gt;.Count);
                do
                {
                    if (Vector512.EqualsAny(target, Vector512.LoadUnsafe(ref current)))
                        return true;

                    current = ref Unsafe.Add(ref current, Vector512&lt;byte&gt;.Count);
                }
                while (Unsafe.IsAddressLessThan(ref current, ref endMinusOneVector));

                if (Vector512.EqualsAny(target, Vector512.LoadUnsafe(ref endMinusOneVector)))
                    return true;
            }
            else if (Vector256.IsHardwareAccelerated &amp;&amp; haystack.Length &gt;= Vector256&lt;byte&gt;.Count)
            {
                Vector256&lt;byte&gt; target = Vector256.Create(needle);
                ref byte endMinusOneVector = ref Unsafe.Add(ref current, haystack.Length - Vector256&lt;byte&gt;.Count);
                do
                {
                    if (Vector256.EqualsAny(target, Vector256.LoadUnsafe(ref current)))
                        return true;

                    current = ref Unsafe.Add(ref current, Vector256&lt;byte&gt;.Count);
                }
                while (Unsafe.IsAddressLessThan(ref current, ref endMinusOneVector));

                if (Vector256.EqualsAny(target, Vector256.LoadUnsafe(ref endMinusOneVector)))
                    return true;
            }
            else
            {
                Vector128&lt;byte&gt; target = Vector128.Create(needle);
                ref byte endMinusOneVector = ref Unsafe.Add(ref current, haystack.Length - Vector128&lt;byte&gt;.Count);
                do
                {
                    if (Vector128.EqualsAny(target, Vector128.LoadUnsafe(ref current)))
                        return true;

                    current = ref Unsafe.Add(ref current, Vector128&lt;byte&gt;.Count);
                }
                while (Unsafe.IsAddressLessThan(ref current, ref endMinusOneVector));

                if (Vector128.EqualsAny(target, Vector128.LoadUnsafe(ref endMinusOneVector)))
                    return true;
            }
        }
        else
        {
            for (int i = 0; i &lt; haystack.Length; i++)
                if (haystack[i] == needle)
                    return true;
        }

        return false;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Find</td><td>Scalar</td><td style="text-align: right">461.49 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Find</td><td>Vector128</td><td style="text-align: right">37.94 ns</td><td style="text-align: right">0.08</td></tr><tr><td>Find</td><td>Vector256</td><td style="text-align: right">22.98 ns</td><td style="text-align: right">0.05</td></tr><tr><td>Find</td><td>Vector512</td><td style="text-align: right">10.93 ns</td><td style="text-align: right">0.02</td></tr></tbody></table><p>Numerous PRs elsewhere in the JIT then take advantage of AVX512 support when it‚Äôs available. For example, separate from AVX512, <a href="https://github.com/dotnet/runtime/pull/83945">dotnet/runtime#83945</a> and <a href="https://github.com/dotnet/runtime/pull/84530">dotnet/runtime#84530</a> taught the JIT how to unroll <code>SequenceEqual</code> operations, such that the JIT can emit optimized, vectorized replacements when it can see a constant length for at least one of the inputs. ‚ÄúUnrolling‚Äù means that rather than emitting a loop for N iterations, each of which does the loop body once, a loop is emitted for N / M iterations, where every iteration does the loop body M times (and if N == M, there is no loop at all). So for a benchmark like this:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private byte[] _scheme = &quot;Transfer-Encoding&quot;u8.ToArray();

    [Benchmark]
    public bool SequenceEqual() =&gt; &quot;Transfer-Encoding&quot;u8.SequenceEqual(_scheme);
}</code></pre><p>we now get results like this:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>SequenceEqual</td><td>.NET 7.0</td><td style="text-align: right">3.0558 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">65 B</td></tr><tr><td>SequenceEqual</td><td>.NET 8.0</td><td style="text-align: right">0.8055 ns</td><td style="text-align: right">0.26</td><td style="text-align: right">91 B</td></tr></tbody></table><p>For .NET 7, we see assembly code like this (note the <code>call</code> instruction to the underlying <code>SequenceEqual</code> helper):</p><pre><code class="language-assembly">; Tests.SequenceEqual()
       sub       rsp,28
       mov       r8,1D7BB272E48
       mov       rcx,[rcx+8]
       test      rcx,rcx
       je        short M00_L03
       lea       rdx,[rcx+10]
       mov       eax,[rcx+8]
M00_L00:
       mov       rcx,r8
       cmp       eax,11
       je        short M00_L02
       xor       eax,eax
M00_L01:
       add       rsp,28
       ret
M00_L02:
       mov       r8d,11
       call      qword ptr [7FF9D33CF120]; System.SpanHelpers.SequenceEqual(Byte ByRef, Byte ByRef, UIntPtr)
       jmp       short M00_L01
M00_L03:
       xor       edx,edx
       xor       eax,eax
       jmp       short M00_L00
; Total bytes of code 65</code></pre><p>And now for .NET 8, we get assembly code like this:</p><pre><code class="language-assembly">; Tests.SequenceEqual()
       vzeroupper
       mov       rax,1EBDDA92D38
       mov       rcx,[rcx+8]
       test      rcx,rcx
       je        short M00_L01
       lea       rdx,[rcx+10]
       mov       r8d,[rcx+8]
M00_L00:
       cmp       r8d,11
       jne       short M00_L03
       vmovups   xmm0,[rax]
       vmovups   xmm1,[rdx]
       vmovups   xmm2,[rax+1]
       vmovups   xmm3,[rdx+1]
       vpxor     xmm0,xmm0,xmm1
       vpxor     xmm1,xmm2,xmm3
       vpor      xmm0,xmm0,xmm1
       vptest    xmm0,xmm0
       sete      al
       movzx     eax,al
       jmp       short M00_L02
M00_L01:
       xor       edx,edx
       xor       r8d,r8d
       jmp       short M00_L00
M00_L02:
       ret
M00_L03:
       xor       eax,eax
       jmp       short M00_L02
; Total bytes of code 91</code></pre><p>Now there‚Äôs no <code>call</code>, with the entire implementation provided by the JIT; we can see it making liberal use of the 128-bit <code>xmm</code> SIMD registers. However, those PRs only enabled the JIT to handle up to 64 bytes being compared (unrolling results in larger code, so at some length it no longer makes sense to unroll). With AVX512 support in the JIT, <a href="https://github.com/dotnet/runtime/pull/84854">dotnet/runtime#84854</a> then extends that up to 128 bytes. This is easily visible in a benchmark like this, which is similar to the previous example, but with larger data:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private byte[] _data1, _data2;

    [GlobalSetup]
    public void Setup()
    {
        _data1 = Enumerable.Repeat((byte)42, 200).ToArray();
        _data2 = (byte[])_data1.Clone();
    }

    [Benchmark]
    public bool SequenceEqual() =&gt; _data1.AsSpan(0, 128).SequenceEqual(_data2.AsSpan(128));
}</code></pre><p>On my Dev Box with AVX512 support, for .NET 8 we get:</p><pre><code class="language-assembly">; Tests.SequenceEqual()
       sub       rsp,28
       vzeroupper
       mov       rax,[rcx+8]
       test      rax,rax
       je        short M00_L01
       cmp       dword ptr [rax+8],80
       jb        short M00_L01
       add       rax,10
       mov       rcx,[rcx+10]
       test      rcx,rcx
       je        short M00_L01
       mov       edx,[rcx+8]
       cmp       edx,80
       jb        short M00_L01
       add       rcx,10
       add       rcx,80
       add       edx,0FFFFFF80
       cmp       edx,80
       je        short M00_L02
       xor       eax,eax
M00_L00:
       vzeroupper
       add       rsp,28
       ret
M00_L01:
       call      qword ptr [7FF820745F08]
       int       3
M00_L02:
       vmovups   zmm0,[rax]
       vmovups   zmm1,[rcx]
       vmovups   zmm2,[rax+40]
       vmovups   zmm3,[rcx+40]
       vpxorq    zmm0,zmm0,zmm1
       vpxorq    zmm1,zmm2,zmm3
       vporq     zmm0,zmm0,zmm1
       vxorps    ymm1,ymm1,ymm1
       vpcmpeqq  k1,zmm0,zmm1
       kortestb  k1,k1
       setb      al
       movzx     eax,al
       jmp       short M00_L00
; Total bytes of code 154</code></pre><p>Now instead of the 128-bit <code>xmm</code> registers, we see use of the 512-bit <code>zmm</code> registers from AVX512.</p><p>The JIT in .NET 8 also now unrolls <code>memmove</code>s (<code>CopyTo</code>, <code>ToArray</code>, etc.) for small-enough constant lengths, thanks to <a href="https://github.com/dotnet/runtime/pull/83638">dotnet/runtime#83638</a> and <a href="https://github.com/dotnet/runtime/pull/83740">dotnet/runtime#83740</a>. And then with <a href="https://github.com/dotnet/runtime/pull/84348">dotnet/runtime#84348</a> that unrolling takes advantage of AVX512 if it‚Äôs available. <a href="https://github.com/dotnet/runtime/pull/85501">dotnet/runtime#85501</a> extends this to <code>Span&lt;T&gt;.Fill</code>, too.</p><p><a href="https://github.com/dotnet/runtime/pull/84885">dotnet/runtime#84885</a> extended the unrolling and vectorization done as part of <code>string</code>/<code>ReadOnlySpan&lt;char&gt;</code><code>Equals</code> and <code>StartsWith</code> to utilize AVX512 when available, as well.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private readonly string _str = &quot;Let me not to the marriage of true minds admit impediments&quot;;

    [Benchmark]
    public bool Equals() =&gt; _str.AsSpan().Equals(
        &quot;LET ME NOT TO THE MARRIAGE OF TRUE MINDS ADMIT IMPEDIMENTS&quot;,
        StringComparison.OrdinalIgnoreCase);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>Equals</td><td>.NET 7.0</td><td style="text-align: right">30.995 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">101 B</td></tr><tr><td>Equals</td><td>.NET 8.0</td><td style="text-align: right">1.658 ns</td><td style="text-align: right">0.05</td><td style="text-align: right">116 B</td></tr></tbody></table><p>It‚Äôs so fast in .NET 8 because, whereas with .NET 7 it ends up calling through to the underlying helper:</p><pre><code class="language-assembly">; Tests.Equals()
       sub       rsp,48
       xor       eax,eax
       mov       [rsp+28],rax
       vxorps    xmm4,xmm4,xmm4
       vmovdqa   xmmword ptr [rsp+30],xmm4
       mov       [rsp+40],rax
       mov       rcx,[rcx+8]
       test      rcx,rcx
       je        short M00_L03
       lea       rdx,[rcx+0C]
       mov       ecx,[rcx+8]
M00_L00:
       mov       r8,21E57C058A0
       mov       r8,[r8]
       add       r8,0C
       cmp       ecx,3A
       jne       short M00_L02
       mov       rcx,rdx
       mov       rdx,r8
       mov       r8d,3A
       call      qword ptr [7FF8194B1A08]; System.Globalization.Ordinal.EqualsIgnoreCase(Char ByRef, Char ByRef, Int32)
M00_L01:
       nop
       add       rsp,48
       ret
M00_L02:
       xor       eax,eax
       jmp       short M00_L01
M00_L03:
       xor       ecx,ecx
       xor       edx,edx
       xchg      rcx,rdx
       jmp       short M00_L00
; Total bytes of code 101</code></pre><p>in .NET 8, the JIT generates code for the operation directly, taking advantage of AVX512‚Äôs greater width and thus able to process a larger input without significantly increasing code size:</p><pre><code class="language-assembly">; Tests.Equals()
       vzeroupper
       mov       rax,[rcx+8]
       test      rax,rax
       jne       short M00_L00
       xor       ecx,ecx
       xor       edx,edx
       jmp       short M00_L01
M00_L00:
       lea       rcx,[rax+0C]
       mov       edx,[rax+8]
M00_L01:
       cmp       edx,3A
       jne       short M00_L02
       vmovups   zmm0,[rcx]
       vmovups   zmm1,[7FF820495080]
       vpternlogq zmm0,zmm1,[7FF8204950C0],56
       vmovups   zmm1,[rcx+34]
       vporq     zmm1,zmm1,[7FF820495100]
       vpternlogq zmm0,zmm1,[7FF820495140],0F6
       vxorps    ymm1,ymm1,ymm1
       vpcmpeqq  k1,zmm0,zmm1
       kortestb  k1,k1
       setb      al
       movzx     eax,al
       jmp       short M00_L03
M00_L02:
       xor       eax,eax
M00_L03:
       vzeroupper
       ret
; Total bytes of code 116</code></pre><p>Even super simple operations get in on the action. Here we just have a cast from a <code>ulong</code> to a <code>double</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;val&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    [Benchmark]
    [Arguments(1234567891011121314ul)]
    public double UIntToDouble(ulong val) =&gt; val;
}</code></pre><p>Thanks to <a href="https://github.com/dotnet/runtime/pull/84384">dotnet/runtime#84384</a> from <a href="https://github.com/khushal1996">@khushal1996</a>, the code for that shrinks from this:</p><pre><code class="language-assembly">; Tests.UIntToDouble(UInt64)
       vzeroupper
       vxorps    xmm0,xmm0,xmm0
       vcvtsi2sd xmm0,xmm0,rdx
       test      rdx,rdx
       jge       short M00_L00
       vaddsd    xmm0,xmm0,qword ptr [7FF819E776C0]
M00_L00:
       ret
; Total bytes of code 26</code></pre><p>using the AVX <code>vcvtsi2sd</code> instruction, to this:</p><pre><code class="language-assembly">; Tests.UIntToDouble(UInt64)
       vzeroupper
       vcvtusi2sd xmm0,xmm0,rdx
       ret
; Total bytes of code 10</code></pre><p>using the AVX512 <code>vcvtusi2sd</code> instruction.</p><p>As yet another example, with <a href="https://github.com/dotnet/runtime/pull/87641">dotnet/runtime#87641</a> we see the JIT using AVX512 to accelerate various <code>Math</code> APIs:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;left&quot;, &quot;right&quot;)]
public class Tests
{
    [Benchmark]
    [Arguments(123456.789f, 23456.7890f)]
    public float Max(float left, float right) =&gt; MathF.Max(left, right);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Max</td><td>.NET 7.0</td><td style="text-align: right">1.1936 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Max</td><td>.NET 8.0</td><td style="text-align: right">0.2865 ns</td><td style="text-align: right">0.24</td></tr></tbody></table><h2 id="branching">Branching</h2><p>Branching is integral to all meaningful code; while some algorithms are written in a branch-free manner, branch-free algorithms typically are challenging to get right and complicated to read, and typically are isolated to only small regions of code. For everything else, branching is the name of the game. Loops, if/else blocks, ternaries‚Ä¶ it‚Äôs hard to imagine any real code without them. Yet they can also represent one of the more significant costs in an application. Modern hardware gets big speed boosts from pipelining, for example from being able to start reading and decoding the next instruction while the previous ones are still processing. That, of course, relies on the hardware knowing what the next instruction is. If there‚Äôs no branching, that‚Äôs easy, it‚Äôs whatever instruction comes next in the sequence. For when there is branching, CPUs have built-in support in the form of branch predictors, used to determine what the next instruction most likely will be, and they‚Äôre often right‚Ä¶ but when they‚Äôre wrong, the cost incurred from that incorrect branch prediction can be huge. Compilers thus strive to minimize branching.</p><p>One way the impact of branches is reduced is by removing them completely. Redundant branch optimizers look for places where the compiler can prove that all paths leading to that branch will lead to the same outcome, such that the compiler can remove the branch and everything in the path not taken. Consider the following example:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private static readonly Random s_rand = new();
    private readonly string _text = &quot;hello world!&quot;;

    [Params(1.0, 0.5)]
    public double Probability { get; set; }

    [Benchmark]
    public ReadOnlySpan&lt;char&gt; TrySlice() =&gt; SliceOrDefault(_text.AsSpan(), s_rand.NextDouble() &lt; Probability ? 3 : 20);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ReadOnlySpan&lt;char&gt; SliceOrDefault(ReadOnlySpan&lt;char&gt; span, int i)
    {
        if ((uint)i &lt; (uint)span.Length)
        {
            return span.Slice(i);
        }

        return default;
    }
}</code></pre><p>Running that on .NET 7, we can glimpse into the impact of failed branch prediction. When we always take the branch the same way, the throughput is 2.5x what it was when it was impossible for the branch predictor to determine where we were going next:</p><table><thead><tr><th>Method</th><th>Probability</th><th style="text-align: right">Mean</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>TrySlice</td><td>0.5</td><td style="text-align: right">8.845 ns</td><td style="text-align: right">136 B</td></tr><tr><td>TrySlice</td><td>1</td><td style="text-align: right">3.436 ns</td><td style="text-align: right">136 B</td></tr></tbody></table><p>We can also use this example for a .NET 8 improvement. That guarded <code>ReadOnlySpan&lt;char&gt;.Slice</code> call has its own branch to ensure that <code>i</code> is within the bounds of the span; we can see that very clearly by looking at the disassembly generated on .NET 7:</p><pre><code class="language-assembly">; Tests.TrySlice()
       push      rdi
       push      rsi
       push      rbp
       push      rbx
       sub       rsp,28
       vzeroupper
       mov       rdi,rcx
       mov       rsi,rdx
       mov       rcx,[rdi+8]
       test      rcx,rcx
       je        short M00_L01
       lea       rbx,[rcx+0C]
       mov       ebp,[rcx+8]
M00_L00:
       mov       rcx,1EBBFC01FA0
       mov       rcx,[rcx]
       mov       rcx,[rcx+8]
       mov       rax,[rcx]
       mov       rax,[rax+48]
       call      qword ptr [rax+20]
       vmovsd    xmm1,qword ptr [rdi+10]
       vucomisd  xmm1,xmm0
       ja        short M00_L02
       mov       eax,14
       jmp       short M00_L03
M00_L01:
       xor       ebx,ebx
       xor       ebp,ebp
       jmp       short M00_L00
M00_L02:
       mov       eax,3
M00_L03:
       cmp       eax,ebp
       jae       short M00_L04
       cmp       eax,ebp
       ja        short M00_L06
       mov       edx,eax
       lea       rdx,[rbx+rdx*2]
       sub       ebp,eax
       jmp       short M00_L05
M00_L04:
       xor       edx,edx
       xor       ebp,ebp
M00_L05:
       mov       [rsi],rdx
       mov       [rsi+8],ebp
       mov       rax,rsi
       add       rsp,28
       pop       rbx
       pop       rbp
       pop       rsi
       pop       rdi
       ret
M00_L06:
       call      qword ptr [7FF999FEB498]
       int       3
; Total bytes of code 136</code></pre><p>In particular, look at <code>M00_L03</code>:</p><pre><code class="language-assembly">M00_L03:
       cmp       eax,ebp
       jae       short M00_L04
       cmp       eax,ebp
       ja        short M00_L06
       mov       edx,eax
       lea       rdx,[rbx+rdx*2]</code></pre><p>At this point, either <code>3</code> or <code>20</code> (0x14) has been loaded into <code>eax</code>, and it‚Äôs being compared against <code>ebp</code>, which was loaded from the span‚Äôs <code>Length</code> earlier (<code>mov ebp,[rcx+8]</code>). There‚Äôs a very obvious redundant branch here, as the code does <code>cmp eax,ebp</code>, and then if it doesn‚Äôt jump as part of the <code>jae</code>, it does the exact same comparison again; the first is the one we wrote in <code>TrySlice</code>, the second is the one from <code>Slice</code> itself, which got inlined.</p><p>On .NET 8, thanks to <a href="https://github.com/dotnet/runtime/pull/72979">dotnet/runtime#72979</a> and <a href="https://github.com/dotnet/runtime/pull/75804">dotnet/runtime#75804</a>, that branch (and many others of a similar ilk) is optimized away. We can run the exact same benchmark, this time on .NET 8, and if we look at the assembly at the corresponding code block (which isn‚Äôt numbered exactly the same because of other changes):</p><pre><code class="language-assembly">M00_L04:
       cmp       eax,ebp
       jae       short M00_L07
       mov       ecx,eax
       lea       rdx,[rdi+rcx*2]</code></pre><p>we can see that, indeed, the redundant branch has been eliminated.</p><p>Another way the overhead associated with branches (and branch misprediction) is removed is by avoiding them altogether. Sometimes simple bit manipulation tricks can be employed to avoid branches. <a href="https://github.com/dotnet/runtime/pull/62689">dotnet/runtime#62689</a> from <a href="https://github.com/pedrobsaila">@pedrobsaila</a>, for example, finds expressions like <code>i &gt;= 0 &amp;&amp; j &gt;= 0</code> for signed integers <code>i</code> and <code>j</code>, and rewrites them to the equivalent of <code>(i | j) &gt;= 0</code>.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;i&quot;, &quot;j&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    [Benchmark]
    [Arguments(42, 84)]
    public bool BothGreaterThanOrEqualZero(int i, int j) =&gt; i &gt;= 0 &amp;&amp; j &gt;= 0;
}</code></pre><p>Here instead of code like we‚Äôd get on .NET 7, which involves a branch for the <code>&amp;&amp;</code>:</p><pre><code class="language-assembly">; Tests.BothGreaterThanOrEqualZero(Int32, Int32)
       test      edx,edx
       jl        short M00_L00
       mov       eax,r8d
       not       eax
       shr       eax,1F
       ret
M00_L00:
       xor       eax,eax
       ret
; Total bytes of code 16</code></pre><p>now on .NET 8, the result is branchless:</p><pre><code class="language-assembly">; Tests.BothGreaterThanOrEqualZero(Int32, Int32)
       or        edx,r8d
       mov       eax,edx
       not       eax
       shr       eax,1F
       ret
; Total bytes of code 11</code></pre><p>Such bit tricks, however, only get you so far. To go further, both x86/64 and Arm provide conditional move instructions, like <code>cmov</code> on x86/64 and <code>csel</code> on Arm, that encapsulate the condition into the single instruction. For example, <code>csel</code> ‚Äúconditionally selects‚Äù the value from one of two register arguments based on whether the condition is true or false and writes that value into the destination register. The instruction pipeline stays filled then because the instruction after the <code>csel</code> is always the next instruction; there‚Äôs no control flow that would result in a different instruction coming next.</p><p>The JIT in .NET 8 is now capable of emitting conditional instructions, on both x86/64 and Arm. With PRs like <a href="https://github.com/dotnet/runtime/pull/73472">dotnet/runtime#73472</a> from <a href="https://github.com/a74nh">@a74nh</a> and <a href="https://github.com/dotnet/runtime/pull/77728">dotnet/runtime#77728</a> from <a href="https://github.com/a74nh">@a74nh</a>, the JIT gains an additional ‚Äúif conversion‚Äù optimization phase, where various conditional patterns are recognized and morphed into conditional nodes in the JIT‚Äôs internal representation; these can then later be emitted as conditional instructions, as was done by <a href="https://github.com/dotnet/runtime/pull/78879">dotnet/runtime#78879</a>, <a href="https://github.com/dotnet/runtime/pull/81267">dotnet/runtime#81267</a>, <a href="https://github.com/dotnet/runtime/pull/82235">dotnet/runtime#82235</a>,  <a href="https://github.com/dotnet/runtime/pull/82766">dotnet/runtime#82766</a>, and <a href="https://github.com/dotnet/runtime/pull/83089">dotnet/runtime#83089</a>. Other PRs, like <a href="https://github.com/dotnet/runtime/pull/84926">dotnet/runtime#84926</a> from <a href="https://github.com/SwapnilGaikwad">@SwapnilGaikwad</a> and <a href="https://github.com/dotnet/runtime/pull/82031">dotnet/runtime#82031</a> from <a href="https://github.com/SwapnilGaikwad">@SwapnilGaikwad</a> optimized which exact instructions would be employed, in these cases using the Arm <a href="https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/CINV--Conditional-Invert--an-alias-of-CSINV-"><code>cinv</code></a> and <a href="https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/CINC--Conditional-Increment--an-alias-of-CSINC-"><code>cinc</code></a> instructions.</p><p>We can see all this in a simple benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private static readonly Random s_rand = new();

    [Params(1.0, 0.5)]
    public double Probability { get; set; }

    [Benchmark]
    public FileOptions GetOptions() =&gt; GetOptions(s_rand.NextDouble() &lt; Probability);

    private static FileOptions GetOptions(bool useAsync) =&gt; useAsync ? FileOptions.Asynchronous : FileOptions.None;
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th>Probability</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>GetOptions</td><td>.NET 7.0</td><td>0.5</td><td style="text-align: right">7.952 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td></tr><tr><td>GetOptions</td><td>.NET 8.0</td><td>0.5</td><td style="text-align: right">2.327 ns</td><td style="text-align: right">0.29</td><td style="text-align: right">86 B</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetOptions</td><td>.NET 7.0</td><td>1</td><td style="text-align: right">2.587 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td></tr><tr><td>GetOptions</td><td>.NET 8.0</td><td>1</td><td style="text-align: right">2.357 ns</td><td style="text-align: right">0.91</td><td style="text-align: right">86 B</td></tr></tbody></table><p>Two things to notice:</p><ol><li>In .NET 7, the cost with a probability of 0.5 is 3x that of when it had a probability of 1.0, due to the branch predictor not being able to successfully predict which way the actual branch would go.</li><li>In .NET 8, it doesn‚Äôt matter whether the probability is 0.5 or 1: the cost is the same (and cheaper than on .NET 7).</li></ol><p>We can also look at the generated assembly to see the difference. In particular, on .NET 8, we see this for the generated assembly:</p><pre><code class="language-assembly">; Tests.GetOptions()
       push      rbx
       sub       rsp,20
       vzeroupper
       mov       rbx,rcx
       mov       rcx,2C54EC01E40
       mov       rcx,[rcx]
       mov       rcx,[rcx+8]
       mov       rax,offset MT_System.Random+XoshiroImpl
       cmp       [rcx],rax
       jne       short M00_L01
       call      qword ptr [7FFA2D790C88]; System.Random+XoshiroImpl.NextDouble()
M00_L00:
       vmovsd    xmm1,qword ptr [rbx+8]
       mov       eax,40000000
       xor       ecx,ecx
       vucomisd  xmm1,xmm0
       cmovbe    eax,ecx
       add       rsp,20
       pop       rbx
       ret
M00_L01:
       mov       rax,[rcx]
       mov       rax,[rax+48]
       call      qword ptr [rax+20]
       jmp       short M00_L00
; Total bytes of code 86</code></pre><p>That <code>vucomisd; cmovbe</code> sequence in there is the comparison between the randomly-generated floating-point value and the probability threshold followed by the conditional move (‚Äúconditionally move if below or equal‚Äù).</p><p>There are many methods that implicitly benefit from these transformations. Take even a simple method, like <code>Math.Max</code>, whose code I‚Äôve copied here:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    [Benchmark]
    public int Max() =&gt; Max(1, 2);

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static int Max(int val1, int val2)
    {
        return (val1 &gt;= val2) ? val1 : val2;
    }
}</code></pre><p>That pattern should look familiar. Here‚Äôs the assembly we get on .NET 7:</p><pre><code class="language-assembly">; Tests.Max(Int32, Int32)
       cmp       ecx,edx
       jge       short M01_L00
       mov       eax,edx
       ret
M01_L00:
       mov       eax,ecx
       ret
; Total bytes of code 10</code></pre><p>The two arguments come in via the <code>ecx</code> and <code>edx</code> registers. They‚Äôre compared, and if the first argument is greater than or equal to the second, it jumps down to the bottom where the first argument is moved into <code>eax</code> as the return value; if it wasn‚Äôt, then the second value is moved into <code>eax</code>. And on .NET 8:</p><pre><code class="language-assembly">; Tests.Max(Int32, Int32)
       cmp       ecx,edx
       mov       eax,edx
       cmovge    eax,ecx
       ret
; Total bytes of code 8</code></pre><p>Again the two arguments come in via the <code>ecx</code> and <code>edx</code> registers, and they‚Äôre compared. The second argument is then moved into <code>eax</code> as the return value. If the comparison showed that the first argument was greater than the second, it‚Äôs then moved into <code>eax</code> (overwriting the second argument that was just moved there). Fun.</p><p>Note if you ever find yourself wanting to do a deeper-dive into this area, BenchmarkDotNet has some excellent additional tools at your disposal. On Windows, it enables you to collect hardware counters, which expose a wealth of information about how things actually executed on the hardware, whether it be number of instructions retired, cache misses, or branch mispredictions. To use it, add another package reference to your .csproj:</p><pre><code class="language-xml">&lt;PackageReference Include=&quot;BenchmarkDotNet.Diagnostics.Windows&quot; Version=&quot;0.13.8&quot; /&gt;</code></pre><p>and add an additional attribute to your tests class:</p><pre><code class="language-C#">[HardwareCounters(HardwareCounter.BranchMispredictions, HardwareCounter.BranchInstructions)]</code></pre><p>Then make sure you‚Äôre running the benchmarks from an elevated / admin terminal. When I do that, now I see this:</p><table><thead><tr><th>Method</th><th>Runtime</th><th>Probability</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">BranchMispredictions/Op</th><th style="text-align: right">BranchInstructions/Op</th></tr></thead><tbody><tr><td>GetOptions</td><td>.NET 7.0</td><td>0.5</td><td style="text-align: right">8.585 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">1</td><td style="text-align: right">5</td></tr><tr><td>GetOptions</td><td>.NET 8.0</td><td>0.5</td><td style="text-align: right">2.488 ns</td><td style="text-align: right">0.29</td><td style="text-align: right">0</td><td style="text-align: right">4</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetOptions</td><td>.NET 7.0</td><td>1</td><td style="text-align: right">2.783 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">0</td><td style="text-align: right">4</td></tr><tr><td>GetOptions</td><td>.NET 8.0</td><td>1</td><td style="text-align: right">2.531 ns</td><td style="text-align: right">0.91</td><td style="text-align: right">0</td><td style="text-align: right">4</td></tr></tbody></table><p>We can see it confirms what we already knew: on .NET 7 with a 0.5 probability, it ends up mispredicting a branch.</p><p>The C# compiler (aka ‚ÄúRoslyn‚Äù) also gets in on the branch-elimination game in .NET 8, for a very specific kind of branch. In .NET, while we think of <code>System.Boolean</code> as only being a two-value type (<code>false</code> and <code>true</code>), <code>sizeof(bool)</code> is actually one byte. That means a <code>bool</code> can technically have 256 different values, where 0 is considered <code>false</code> and [1,255] are all considered <code>true</code>. Thankfully, unless a developer is poking around the edges of interop or otherwise using <code>unsafe</code> code to purposefully manipulate these other values, developers can remain blissfully unaware of the actual numeric value here, for two reasons. First, C# doesn‚Äôt consider <code>bool</code> to be a numerical type, and thus you can‚Äôt perform arithmetic on it or cast it to a type like <code>int</code>. Second, all of the <code>bool</code>s produced by the runtime and C# are normalized to actually be 0 or 1 in value, e.g. a <a href="https://learn.microsoft.com/dotnet/api/system.reflection.emit.opcodes.cgt"><code>cmp</code></a> IL instruction is documented as ‚ÄúIf value1 is greater than value2, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.‚Äù There is a class of algorithms, however, where being able to rely on such 0 and 1 values is handy, and we were just talking about them: branch-free algorithms.</p><p>Let‚Äôs say we didn‚Äôt have the JIT‚Äôs new-found ability to use conditional moves and we wanted to write our own <code>ConditionalSelect</code> method for integers:</p><pre><code class="language-C#">static int ConditionalSelect(bool condition, int whenTrue, int whenFalse);</code></pre><p><em>If</em> we could rely on <code>bool</code> always being 0 or 1 (we can‚Äôt), and <em>if</em> we could do arithmetic on a <code>bool</code> (we can‚Äôt), then we could use the behavior of multiplication to implement our <code>ConditionalSelect</code> function. Anything multiplied by 0 is 0, and anything multiplied by 1 is itself, so we could write our <code>ConditionalSelect</code> like this:</p><pre><code class="language-C#">// pseudo-code; this won&#39;t compile!
static int ConditionalSelect(bool condition, int whenTrue, int whenFalse) =&gt;
    (whenTrue  *  condition) +
    (whenFalse * !condition);</code></pre><p>Then if <code>condition</code> is 1, <code>whenTrue * condition</code> would be <code>whenTrue</code> and <code>whenFalse * !condition</code> would be 0, such that the whole expression would evaluate to <code>whenTrue</code>. And, conversely, if <code>condition</code> is 0, <code>whenTrue * condition</code> would be 0 and <code>whenFalse * !condition</code> would be <code>whenFalse</code>, such that the whole expression would evaluate to <code>whenFalse</code>. As noted, though, we can‚Äôt write the above, but we could write this:</p><pre><code class="language-C#">static int ConditionalSelect(bool condition, int whenTrue, int whenFalse) =&gt;
    (whenTrue  * (condition ? 1 : 0)) +
    (whenFalse * (condition ? 0 : 1));</code></pre><p>That provides the exact semantics we want‚Ä¶ but we‚Äôve introduced two branches into our supposedly branch-free algorithm. This is the IL produced for that <code>ConditionalSelect</code> in .NET 7:</p><pre><code class="language-assembly">.method private hidebysig static  int32 ConditionalSelect (bool condition, int32 whenTrue, int32 whenFalse) cil managed 
{
    .maxstack 8

    IL_0000: ldarg.1
    IL_0001: ldarg.0
    IL_0002: brtrue.s IL_0007

    IL_0004: ldc.i4.0
    IL_0005: br.s IL_0008

    IL_0007: ldc.i4.1

    IL_0008: mul
    IL_0009: ldarg.2
    IL_000a: ldarg.0
    IL_000b: brtrue.s IL_0010

    IL_000d: ldc.i4.1
    IL_000e: br.s IL_0011

    IL_0010: ldc.i4.0

    IL_0011: mul
    IL_0012: add
    IL_0013: ret
}</code></pre><p>Note all those <code>brtrue.s</code> and <code>br.s</code> instructions in there. Are they necessary, though? Earlier I noted that the runtime will only produce <code>bool</code>s with a value of 0 or 1. And thanks to <a href="https://github.com/dotnet/roslyn/pull/67191">dotnet/roslyn#67191</a>, the C# compiler now recognizes that and optimizes the pattern <code>(b ? 1 : 0)</code> to be branchless. Our same <code>ConditionalSelect</code> function now in .NET 8 compiles to this:</p><pre><code class="language-assembly">.method private hidebysig static  int32 ConditionalSelect (bool condition, int32 whenTrue, int32 whenFalse) cil managed 
{
    .maxstack 8

    IL_0000: ldarg.1
    IL_0001: ldarg.0
    IL_0002: ldc.i4.0
    IL_0003: cgt.un
    IL_0005: mul
    IL_0006: ldarg.2
    IL_0007: ldarg.0
    IL_0008: ldc.i4.0
    IL_0009: ceq
    IL_000b: mul
    IL_000c: add
    IL_000d: ret
}</code></pre><p>Zero branch instructions. Of course, you wouldn‚Äôt actually want to write this function like this anymore; just because it‚Äôs branch-free doesn‚Äôt mean it‚Äôs the most efficient. On .NET 8, here‚Äôs the assembly code produced by the JIT for the above:</p><pre><code class="language-assembly">       movzx    rax, cl
       xor      ecx, ecx
       test     eax, eax
       setne    cl
       imul     ecx, edx
       test     eax, eax
       sete     al
       movzx    rax, al
       imul     eax, r8d
       add      eax, ecx
       ret  </code></pre><p>whereas if you just wrote it as:</p><pre><code class="language-C#">static int ConditionalSelect(bool condition, int whenTrue, int whenFalse) =&gt;
    condition ? whenTrue : whenFalse;</code></pre><p>here‚Äôs what you‚Äôd get:</p><pre><code class="language-assembly">       test     cl, cl
       mov      eax, r8d
       cmovne   eax, edx
       ret    </code></pre><p>Even so, this C# compiler optimization is useful for other branch-free algorithms. Let‚Äôs say I wanted to write a <code>Compare</code> method that would compare two <code>int</code>s, returning -1 if the first is less than the second, 0 if they‚Äôre equal, and 1 if the first is greater than the second. I could write that like this:</p><pre><code class="language-C#">static int Compare(int x, int y)
{
    if (x &lt; y) return -1;
    if (x &gt; y) return 1;
    return 0;
}</code></pre><p>Simple, but every invocation will incur at least one branch, if not two. With the <code>(b ? 1 : 0)</code> optimization, we can instead write it like this:</p><pre><code class="language-C#">static int Compare(int x, int y)
{
    int gt = (x &gt; y) ? 1 : 0;
    int lt = (x &lt; y) ? 1 : 0;
    return gt - lt;
}</code></pre><p>This is now branch-free, with the C# compiler producing:</p><pre><code class="language-assembly">    IL_0000: ldarg.0
    IL_0001: ldarg.1
    IL_0002: cgt
    IL_0004: ldarg.0
    IL_0005: ldarg.1
    IL_0006: clt
    IL_0008: stloc.0
    IL_0009: ldloc.0
    IL_000a: sub
    IL_000b: ret</code></pre><p>and, from that, the JIT producing:</p><pre><code class="language-assembly">       xor      eax, eax
       cmp      ecx, edx
       setg     al
       setl     cl
       movzx    rcx, cl
       sub      eax, ecx
       ret      </code></pre><p>Does that mean that everyone should now be running to rewrite their algorithms in a branch-free manner? Most definitely not. It‚Äôs another tool in your tool belt, and in some cases it‚Äôs quite beneficial, especially when it can provide more consistent throughput results due to doing the same work regardless of outcome. It‚Äôs not always a win, however, and in general it‚Äôs best not to try to outsmart the compiler. Take the example we just looked at. There‚Äôs a function with that exact implementation in the core libraries: <code>int.CompareTo</code>. And if you look at its implementation in .NET 8, you‚Äôll find that it‚Äôs still using the branch-based implementation. Why? Because it often yields better results, in particular in the common case where the operation gets inlined and the JIT is able to combine the branches in the <code>CompareTo</code> method with ones based on processing the result of <code>CompareTo</code>. Most uses of <code>CompareTo</code> involve additional branching based on its result, such as in a quick sort partitioning step that‚Äôs deciding whether to move elements. So let‚Äôs take an example where code makes a decision based on the result of such a comparison:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    private int _x = 2, _y = 1;

    [Benchmark]
    public int GreaterThanOrEqualTo_Branching()
    {
        if (Compare_Branching(_x, _y) &gt;= 0)
        {
            return _x * 2;
        }

        return _y * 3;
    }

    [Benchmark]
    public int GreaterThanOrEqualTo_Branchless()
    {
        if (Compare_Branchless(_x, _y) &gt;= 0)
        {
            return _x * 2;
        }

        return _y * 3;
    }

    private static int Compare_Branching(int x, int y)
    {
        if (x &lt; y) return -1;
        if (x &gt; y) return 1;
        return 0;
    }

    private static int Compare_Branchless(int x, int y)
    {
        int gt = (x &gt; y) ? 1 : 0;
        int lt = (x &lt; y) ? 1 : 0;
        return gt - lt;
    }
}</code></pre><p>And the resulting assembly:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/BranchingWins.png" alt="Branching vs Branchless Assembly Difference" /></p><p>Note that both implementations now have just one branch (a <code>jl</code> in the ‚Äúbranching‚Äù case and a <code>js</code> in the ‚Äúbranchless‚Äù case), <em>and</em> the ‚Äúbranching‚Äù implementation results in less assembly code.</p><h2 id="bounds-checking">Bounds Checking</h2><p>Arrays, strings, and spans are all bounds checked by the runtime. That means that indexing into one of these data structures incurs validation to ensure that the index is within the bounds of the data structure. For example, the <code>Get(byte[],int)</code> method here:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    private byte[] _array = new byte[8];
    private int _index = 4;

    [Benchmark]
    public void Get() =&gt; Get(_array, _index);

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static byte Get(byte[] array, int index) =&gt; array[index];
}</code></pre><p>results in this code being generated for the method:</p><pre><code class="language-assembly">; Tests.Get(Byte[], Int32)
       sub       rsp,28
       cmp       edx,[rcx+8]
       jae       short M01_L00
       mov       eax,edx
       movzx     eax,byte ptr [rcx+rax+10]
       add       rsp,28
       ret
M01_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 27</code></pre><p>Here, the <code>byte[]</code> is passed in <code>rcx</code>, the <code>int index</code> is in <code>edx</code>, and the code is comparing the value of the index against the value stored at an 8-byte offset from the beginning of the array: that‚Äôs where the array‚Äôs length is stored. The <code>jae</code> instruction (jump if above or equal) is an unsigned comparison, such that if <code>(uint)index &gt;= (uint)array.Length</code>, it‚Äôll jump to <code>M01_L00</code>, where we see a call to a helper function <code>CORINFO_HELP_RNGCHKFAIL</code> that will throw an <code>IndexOutOfRangeException</code>. All of that is the ‚Äúbounds check.‚Äù The actual access into the array is the two <code>mov</code> and <code>movzx</code> instructions, where the <code>index</code> is moved into <code>eax</code>, and then the value located at <code>rcx</code> (the address of the array) + <code>rax</code> (the index) + 0x10 (the offset of the start of the data in the array) is moved into the return <code>eax</code> register.</p><p>It‚Äôs the runtime‚Äôs responsibility to ensure that all accesses are guaranteed in bounds. It can do so with a bounds check. But it can also do so by proving that the index is always in range, in which case it can elide adding a bounds check that would only add overhead and provide zero benefit. Every .NET release, the JIT improves its ability to recognize patterns that don‚Äôt need a bounds check added because there‚Äôs no way the access could be out of range. And .NET 8 is no exception, with it learning several new and valuable tricks.</p><p>One such trick comes from <a href="https://github.com/dotnet/runtime/pull/84231">dotnet/runtime#84231</a>, where it learns how to avoid bounds checks in a pattern that‚Äôs very prevalent in collections, in particular in hash tables. In a hash table, you generally compute a hash code for a key and then use that key to index into an array (often referred to as ‚Äúbuckets‚Äù). As the hash code might be any <code>int</code> and the buckets array is invariably going to be much smaller than the full range of a 32-bit integer, all of the hash codes need to be mapped down to an element in the array, and a good way to do that is by mod‚Äôing the hash code by the array‚Äôs length, e.g.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private readonly int[] _array = new int[7];

    [Benchmark]
    public int GetBucket() =&gt; GetBucket(_array, 42);

    private static int GetBucket(int[] buckets, int hashcode) =&gt;
        buckets[(uint)hashcode % buckets.Length];
}</code></pre><p>In .NET 7, that produces:</p><pre><code class="language-assembly">; Tests.GetBucket()
       sub       rsp,28
       mov       rcx,[rcx+8]
       mov       eax,2A
       mov       edx,[rcx+8]
       mov       r8d,edx
       xor       edx,edx
       idiv      r8
       cmp       rdx,r8
       jae       short M00_L00
       mov       eax,[rcx+rdx*4+10]
       add       rsp,28
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 44</code></pre><p>Note the <code>CORINFO_HELP_RNGCHKFAIL</code>, the tell-tale sign of a bounds check. Now in .NET 8, the JIT recognizes that it‚Äôs impossible for a <code>uint</code> value <code>%</code>‚Äòd by an array‚Äôs length to be out of bounds of that array; either the array‚Äôs <code>Length</code> is greater than 0, in which case the result of the <code>%</code> will always be <code>&gt;= 0</code> and <code>&lt; array.Length</code>, or the <code>Length</code> is 0, and <code>% 0</code> will throw an exception. As such, it can elide the bounds check:</p><pre><code class="language-assembly">; Tests.GetBucket()
       mov       rcx,[rcx+8]
       mov       eax,2A
       mov       r8d,[rcx+8]
       xor       edx,edx
       div       r8
       mov       eax,[rcx+rdx*4+10]
       ret
; Total bytes of code 23</code></pre><p>Now consider this:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private readonly string _s = &quot;\&quot;Hello, World!\&quot;&quot;;

    [Benchmark]
    public bool IsQuoted() =&gt; IsQuoted(_s);

    private static bool IsQuoted(string s) =&gt;
        s.Length &gt;= 2 &amp;&amp; s[0] == &#39;&quot;&#39; &amp;&amp; s[^1] == &#39;&quot;&#39;;
}</code></pre><p>Our function is checking to see whether the supplied string begins and ends with a quote. It needs to be at least two characters long, and the first and last characters need to be quotes (<code>s[^1]</code> is shorthand for and expanded by the C# compiler into the equivalent of <code>s[s.Length - 1]</code>). Here‚Äôs the .NET 7 assembly:</p><pre><code class="language-assembly">; Tests.IsQuoted(System.String)
       sub       rsp,28
       mov       eax,[rcx+8]
       cmp       eax,2
       jl        short M01_L00
       cmp       word ptr [rcx+0C],22
       jne       short M01_L00
       lea       edx,[rax-1]
       cmp       edx,eax
       jae       short M01_L01
       mov       eax,edx
       cmp       word ptr [rcx+rax*2+0C],22
       sete      al
       movzx     eax,al
       add       rsp,28
       ret
M01_L00:
       xor       eax,eax
       add       rsp,28
       ret
M01_L01:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 58</code></pre><p>Note that our function is indexing into the string twice, and the assembly does have a <code>call CORINFO_HELP_RNGCHKFAIL</code> at the end of the method, but there‚Äôs only one <code>jae</code> referring to the location of that <code>call</code>. That‚Äôs because the JIT already knows to avoid the bounds check on the <code>s[0]</code> access: it sees that it‚Äôs already been verified that the string‚Äôs <code>Length &gt;= 2</code>, so it‚Äôs safe to index without a bounds check into any index <code>&lt;= 2</code>. But, we do still have the bounds check for the <code>s[s.Length - 1]</code>. Now in .NET 8, we get this:</p><pre><code class="language-assembly">; Tests.IsQuoted(System.String)
       mov       eax,[rcx+8]
       cmp       eax,2
       jl        short M01_L00
       cmp       word ptr [rcx+0C],22
       jne       short M01_L00
       dec       eax
       cmp       word ptr [rcx+rax*2+0C],22
       sete      al
       movzx     eax,al
       ret
M01_L00:
       xor       eax,eax
       ret
; Total bytes of code 33</code></pre><p>Note the distinct lack of the <code>call CORINFO_HELP_RNGCHKFAIL</code>; no more bounds checks. Not only did the JIT recognize that <code>s[0]</code> is safe because <code>s.Length &gt;= 2</code>, thanks to <a href="https://github.com/dotnet/runtime/pull/84213">dotnet/runtime#84213</a> it also recognized that since <code>s.Length &gt;= 2</code>, <code>s.Length - 1</code> is <code>&gt;= 0</code> and <code>&lt; s.Length</code>, which means it‚Äôs in-bounds and thus no range check is needed.</p><h2 id="constant-folding">Constant Folding</h2><p>Another important operation employed by compilers is constant folding (and the closely related constant propagation). Constant folding is just a fancy name for a compiler evaluating expressions at compile-time, e.g. if you have <code>2 * 3</code>, rather than emitting a multiplication instruction, it can just do the multiplication at compile-time and substitute <code>6</code>. Constant propagation is then the act of taking that new constant and using it anywhere this expression‚Äôs result feeds, e.g. if you have:</p><pre><code class="language-C#">int a = 2 * 3;
int b = a * 4;</code></pre><p>a compiler can instead pretend it was:</p><pre><code class="language-C#">int a = 6;
int b = 24;</code></pre><p>I bring this up here, after we just talked about bounds-check elimination, because there are scenarios where constant folding and bounds check elimination go hand-in-hand. If we can determine a data structure‚Äôs length at compile-time, and we can determine an index at a compile-time, then also at compile-time we can determine whether the index is in bounds and avoid the bounds check. We can also take it further: if we can determine not only the data structure‚Äôs length but also its contents, then we can do the indexing at compile-time and substitute the value from the data structure.</p><p>Consider this example, which is similar in nature to the kind of code types often have in their <code>ToString</code> or <code>TryFormat</code> implementations:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    [Benchmark]
    [Arguments(42)]
    public string Format(int value) =&gt; Format(value, &quot;B&quot;);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static string Format(int value, ReadOnlySpan&lt;char&gt; format)
    {
        if (format.Length == 1)
        {
            switch (format[0] | 0x20)
            {
                case &#39;d&#39;: return DecimalFormat(value);
                case &#39;x&#39;: return HexFormat(value);
                case &#39;b&#39;: return BinaryFormat(value);
            }
        }

        return FallbackFormat(value, format);
    }

    [MethodImpl(MethodImplOptions.NoInlining)] private static string DecimalFormat(int value) =&gt; null;
    [MethodImpl(MethodImplOptions.NoInlining)] private static string HexFormat(int value) =&gt; null;
    [MethodImpl(MethodImplOptions.NoInlining)] private static string BinaryFormat(int value) =&gt; null;
    [MethodImpl(MethodImplOptions.NoInlining)] private static string FallbackFormat(int value, ReadOnlySpan&lt;char&gt; format) =&gt; null;
}</code></pre><p>We have a <code>Format(int value, ReadOnlySpan&lt;char&gt; format)</code> method for formatting the <code>int</code> value according to the specified <code>format</code>. The call site is explicit about the format to use, as many such call sites are, explicitly passing <code>&quot;B&quot;</code> here. The implementation is then special-casing formats that are one-character long and match in an ignore-case manner against one of three known formats (it‚Äôs using an ASCII trick based on the values of the lowercase letters being one bit different from their uppercase counterparts, such that <code>OR</code>‚Äòing an uppercase ASCII letter with <code>0x20</code> lowercases it). If we look at the assembly generated for this method in .NET 7, we get this:</p><pre><code class="language-assembly">; Tests.Format(Int32)
       sub       rsp,38
       xor       eax,eax
       mov       [rsp+28],rax
       mov       ecx,edx
       mov       rax,251C4801418
       mov       rax,[rax]
       add       rax,0C
       movzx     edx,word ptr [rax]
       or        edx,20
       cmp       edx,62
       je        short M00_L01
       cmp       edx,64
       je        short M00_L00;
       cmp       edx,78
       jne       short M00_L02
       call      qword ptr [7FFF3DD47918]; Tests.HexFormat(Int32)
       jmp       short M00_L03
M00_L00:
       call      qword ptr [7FFF3DD47900]; Tests.DecimalFormat(Int32)
       jmp       short M00_L03
M00_L01:
       call      qword ptr [7FFF3DD47930]; Tests.BinaryFormat(Int32)
       jmp       short M00_L03
M00_L02:
       mov       [rsp+28],rax
       mov       dword ptr [rsp+30],1
       lea       rdx,[rsp+28]
       call      qword ptr [7FFF3DD47948]; Tests.FallbackFormat
M00_L03:
       nop
       add       rsp,38
       ret
; Total bytes of code 105</code></pre><p>We can see the code here from <code>Format(Int32, ReadOnlySpan&lt;char&gt;)</code> but this is the code for <code>Format(Int32)</code>, so the callee was successfully inlined. We also don‚Äôt see any code for the <code>format.Length == 1</code> (the first <code>cmp</code> is part of the <code>switch</code>), nor do we see any signs of a bounds check (there‚Äôs no <code>call CORINFO_HELP_RNGCHKFAIL</code>). We do, however, see it loading the first character from <code>format</code>:</p><pre><code class="language-assembly">mov       rax,251C4801418       ; loads the address of where the format const string reference is stored
mov       rax,[rax]             ; loads the address of format
add       rax,0C                ; loads the address of format&#39;s first character
movzx     edx,word ptr [rax]    ; reads the first character of format</code></pre><p>and then using the equivalent of a cascading <code>if</code>/<code>else</code>. Now let‚Äôs look at .NET 8:</p><pre><code class="language-assembly">; Tests.Format(Int32)
       sub       rsp,28
       mov       ecx,edx
       call      qword ptr [7FFEE0BAF4C8]; Tests.BinaryFormat(Int32)
       nop
       add       rsp,28
       ret
; Total bytes of code 18</code></pre><p>Whoa. It not only saw that <code>format</code>‚Äòs <code>Length</code> was 1 and not only was able to avoid the bounds check, it actually read the first character, lowercased it, and matched it against all the <code>switch</code> branches, such that the entire operation was constant folded and propagated away, leaving just a call to <code>BinaryFormat</code>. That‚Äôs primarily thanks to <a href="https://github.com/dotnet/runtime/pull/78593">dotnet/runtime#78593</a>.</p><p>There are a multitude of other such improvements, such as <a href="https://github.com/dotnet/runtime/pull/77593">dotnet/runtime#77593</a> which enables it to constant fold the length of a <code>string</code> or <code>T[]</code> stored in a <code>static readonly</code> field. Consider:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private static readonly string s_newline = Environment.NewLine;

    [Benchmark]
    public bool IsLineFeed() =&gt; s_newline.Length == 1 &amp;&amp; s_newline[0] == &#39;\n&#39;;
}</code></pre><p>On .NET 7, I get the following assembly:</p><pre><code class="language-assembly">; Tests.IsLineFeed()
       mov       rax,18AFF401F78
       mov       rax,[rax]
       mov       edx,[rax+8]
       cmp       edx,1
       jne       short M00_L00
       cmp       word ptr [rax+0C],0A
       sete      al
       movzx     eax,al
       ret
M00_L00:
       xor       eax,eax
       ret
; Total bytes of code 36</code></pre><p>This is effectively a 1:1 translation of the C#, with not much interesting happening: it loads the string from <code>s_newline</code>, and compares its <code>Length</code> to 1; if it doesn‚Äôt match, it returns 0 (false), otherwise it compares the value in the first element of the array against 0xA (line feed) and returns whether they match. Now, .NET 8:</p><pre><code class="language-assembly">; Tests.IsLineFeed()
       xor       eax,eax
       ret
; Total bytes of code 3</code></pre><p>That‚Äôs more interesting. I ran this code on Windows, where <code>Environment.NewLine</code> is <code>&quot;\r\n&quot;</code>. The JIT has constant folded the entire operation, seeing that the length is not 1, such that the whole operation boils down to just returning false.</p><p>Or consider <a href="https://github.com/dotnet/runtime/pull/78783">dotnet/runtime#78783</a> and <a href="https://github.com/dotnet/runtime/pull/80661">dotnet/runtime#80661</a> which teach the JIT how to actually peer into the contents of an ‚ÄúRVA static.‚Äù These are ‚ÄúRelative Virtual Address‚Äù static fields, which is a fancy way of saying they live in the assembly‚Äôs data section. The C# compiler has optimizations that put constant data into such fields; for example, when you write:</p><pre><code class="language-C#">private static ReadOnlySpan&lt;byte&gt; Prefix =&gt; &quot;http://&quot;u8;</code></pre><p>the C# compiler will actually emil IL like this:</p><pre><code class="language-assembly">.method private hidebysig specialname static 
    valuetype [System.Runtime]System.ReadOnlySpan`1&lt;uint8&gt; get_Prefix () cil managed 
{
    .maxstack 8

    IL_0000: ldsflda int64 &#39;&lt;PrivateImplementationDetails&gt;&#39;::&#39;6709A82409D4C9E2EC04E1E71AB12303402A116B0F923DB8114F69CB05F1E926&#39;
    IL_0005: ldc.i4.7
    IL_0006: newobj instance void valuetype [System.Runtime]System.ReadOnlySpan`1&lt;uint8&gt;::.ctor(void*, int32)
    IL_000b: ret
}
...
.class private auto ansi sealed &#39;&lt;PrivateImplementationDetails&gt;&#39;
    extends [System.Runtime]System.Object
{
    .field assembly static initonly int64 &#39;6709A82409D4C9E2EC04E1E71AB12303402A116B0F923DB8114F69CB05F1E926&#39; at I_00002868
    .data cil I_00002868 = bytearray ( 68 74 74 70 3a 2f 2f 00 )
}</code></pre><p>With these PRs, when indexing into such RVA statics, the JIT is now able to actually read the data at the relevant location, constant folding the operation to the value at that location. So, take the following benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    [Benchmark]
    public bool IsWhiteSpace() =&gt; char.IsWhiteSpace(&#39;\n&#39;);
}</code></pre><p>The <code>char.IsWhiteSpace</code> method is implemented via a lookup into such an RVA static, using the <code>char</code> passed in as an index into it. If the index ends up being a <code>const</code>, now on .NET 8 the whole operation can be constant folded away. .NET 7:</p><pre><code class="language-assembly">; Tests.IsWhiteSpace()
       xor       eax,eax
       test      byte ptr [7FFF9BCCD83A],80
       setne     al
       ret
; Total bytes of code 13</code></pre><p>and .NET 8:</p><pre><code class="language-assembly">; Tests.IsWhiteSpace()
       mov       eax,1
       ret
; Total bytes of code 6</code></pre><p>You get the idea. Of course, a developer hopefully wouldn‚Äôt explicitly write <code>char.IsWhiteSpace(&#39;\n&#39;)</code>, but such code can result none-the-less, especially via inlining.</p><p>There are a multitude of these kinds of improvements in .NET 8. <a href="https://github.com/dotnet/runtime/pull/77102">dotnet/runtime#77102</a> made it so that a <code>static readonly</code> value type‚Äôs primitive fields can be constant folded as if they were themselves <code>static readonly</code> fields, and <a href="https://github.com/dotnet/runtime/pull/80431">dotnet/runtime#80431</a> extended that to strings. <a href="https://github.com/dotnet/runtime/pull/85804">dotnet/runtime#85804</a> taught the JIT how to handle <code>RuntimeTypeHandle.ToIntPtr(typeof(T).TypeHandle)</code> (which is used in methods like <code>GC.AllocateUninitializedArray</code>), while <a href="https://github.com/dotnet/runtime/pull/87101">dotnet/runtime#87101</a> taught it to handle <code>obj.GetType()</code> (such that if the JIT knows the exact type of an instance <code>obj</code>, it can replace the <code>GetType()</code> invocation with the known answer). However, one of my favorite examples, purely because of just how magical it seems, comes from a series of PRs, including <a href="https://github.com/dotnet/runtime/pull/80622">dotnet/runtime#80622</a>, <a href="https://github.com/dotnet/runtime/pull/78961">dotnet/runtime#78961</a>, <a href="https://github.com/dotnet/runtime/pull/80888">dotnet/runtime#80888</a>, and <a href="https://github.com/dotnet/runtime/pull/81005">dotnet/runtime#81005</a>. Together, they enable this:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    [Benchmark]
    public DateTime Get() =&gt; new DateTime(2023, 9, 1);
}</code></pre><p>to produce this:</p><pre><code class="language-assembly">; Tests.Get()
       mov       rax,8DBAA7E629B4000
       ret
; Total bytes of code 11</code></pre><p>The JIT was able to successfully inline and constant fold the entire operation down to a single constant. That <code>8DBAA7E629B4000</code> in that <code>mov</code> instruction is the value for the <code>private readonly ulong _dateData</code> field that backs <code>DateTime</code>. Sure enough, if you run:</p><pre><code class="language-C#">new DateTime(0x8DBAA7E629B4000)</code></pre><p>you‚Äôll see it produces:</p><pre><code class="language-C#">[9/1/2023 12:00:00 AM]</code></pre><p>Very cool.</p><h2 id="non-gc-heap">Non-GC Heap</h2><p>Earlier we saw an example of the codegen when loading a constant string. As a reminder, this code:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    [Benchmark]
    public string GetPrefix() =&gt; &quot;https://&quot;;
}</code></pre><p>results in this assembly on .NET 7:</p><pre><code class="language-assembly">; Tests.GetPrefix()
       mov       rax,126A7C01498
       mov       rax,[rax]
       ret
; Total bytes of code 14</code></pre><p>There are two <code>mov</code> instructions here. The first is loading the location where the address to the string object is stored, and the second is reading the address stored at that location (this requires two <code>mov</code>s because on x64 there‚Äôs no addressing mode that supports moving the value stored at an absolute address larger than 32-bits). Even though we‚Äôre dealing with a string literal here, such that the data for the string is constant, that constant data still ends up being copied into a heap-allocated <code>string</code> object. That object is interned, such that there‚Äôs only one of them in the process, but it‚Äôs still a heap object, and that means it‚Äôs still subject to being moved around by the GC. That means the JIT can‚Äôt just bake in the address of the <code>string</code> object, since the address can change, hence why it needs to read the address each time, in order to know where it currently is. Or, does it?</p><p>What if we could ensure that the <code>string</code> object for this literal is created some place where it would never move, for example on the Pinned Object Heap (POH)? Then the JIT could avoid the indirection and instead just hardcode the address of the <code>string</code>, knowing that it would never move. Of course, the POH guarantees objects on it will never <em>move</em>, but it doesn‚Äôt guarantee addresses to them will always be valid; after all, it doesn‚Äôt root the objects, so objects on the POH are still collectible by the GC, and if they were collected, their addresses would be pointing at garbage or other data that ended up reusing the space.</p><p>To address that, .NET 8 introduces a new mechanism used by the JIT for these kinds of situations: the Non-GC Heap (an evolution of the older ‚ÄúFrozen Segments‚Äù concept used by Native AOT). The JIT can ensure relevant objects are allocated on the Non-GC Heap, which is, as the name suggests, not managed by the GC and is intended to store objects where the JIT can prove the object has no references the GC needs to be aware of and will be rooted for the lifetime of the process, which in turn implies it can‚Äôt be part of an unloadable context.</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/HeapsWhereNetObjectsLive.png" alt="Heaps where .NET Objects Live" /></p><p>The JIT can then avoid indirections in code generated to access that object, instead just hardcoding the object‚Äôs address. That‚Äôs exactly what it does now for string literals, as of <a href="https://github.com/dotnet/runtime/pull/49576">dotnet/runtime#49576</a>. Now in .NET 8, that same method above results in this assembly:</p><pre><code class="language-assembly">; Tests.GetPrefix()
       mov       rax,227814EAEA8
       ret
; Total bytes of code 11</code></pre><p><a href="https://github.com/dotnet/runtime/pull/75573">dotnet/runtime#75573</a> makes a similar play, but with the <code>RuntimeType</code> objects produced by <code>typeof(T)</code> (subject to various constraints, like the <code>T</code> not coming from an unloadable assembly, in which case permanently rooting the object would prevent unloading). Again, we can see this with a simple benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    [Benchmark]
    public Type GetTestsType() =&gt; typeof(Tests);
}</code></pre><p>where we get the following difference between .NET 7 and .NET 8:</p><pre><code class="language-assembly">; .NET 7
; Tests.GetTestsType()
       sub       rsp,28
       mov       rcx,offset MT_Tests
       call      CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE
       nop
       add       rsp,28
       ret
; Total bytes of code 25

; .NET 8
; Tests.GetTestsType()
       mov       rax,1E0015E73F8
       ret
; Total bytes of code 11</code></pre><p>The same capability can be extended to other kinds of objects, as it is in <a href="https://github.com/dotnet/runtime/pull/85559">dotnet/runtime#85559</a> (which is based on work from <a href="https://github.com/dotnet/runtime/pull/76112">dotnet/runtime#76112</a>), making <code>Array.Empty&lt;T&gt;()</code> cheaper by allocating the empty arrays on the Non-GC Heap.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    [Benchmark]
    public string[] Test() =&gt; Array.Empty&lt;string&gt;();
}</code></pre><pre><code class="language-assembly">; .NET 7
; Tests.Test()
       mov       rax,17E8D801FE8
       mov       rax,[rax]
       ret
; Total bytes of code 14

; .NET 8
; Tests.Test()
       mov       rax,1A0814EAEA8
       ret
; Total bytes of code 11</code></pre><p>And as of <a href="https://github.com/dotnet/runtime/pull/77737">dotnet/runtime#77737</a>, it also applies to the heap object associated with <code>static</code> value type fields, at least those that don‚Äôt contain any GC references. Wait, heap object for value type fields? Surely, Stephen, you got that wrong, value types aren‚Äôt allocated on the heap when stored in fields. Well, actually they are when they‚Äôre stored in <code>static</code> fields; the runtime creates a heap-allocated box associated with that field to store the value (but the same box is reused for all writes to that field). And that means for a benchmark like this:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public partial class Tests
{
    private static readonly ConfigurationData s_config = ConfigurationData.ReadData();

    [Benchmark]
    public TimeSpan GetRefreshInterval() =&gt; s_config.RefreshInterval;

    // Struct for storing fictional configuration data that might be read from a configuration file.
    private struct ConfigurationData
    {
        public static ConfigurationData ReadData() =&gt; new ConfigurationData
        {
            Index = 0x12345,
            Id = Guid.NewGuid(),
            IsEnabled = true,
            RefreshInterval = TimeSpan.FromSeconds(100)
        };

        public int Index;
        public Guid Id;
        public bool IsEnabled;
        public TimeSpan RefreshInterval;
    }
}</code></pre><p>we see the following assembly code for reading that <code>RefreshInterval</code> on .NET 7:</p><pre><code class="language-assembly">; Tests.GetRefreshInterval()
       mov       rax,13D84001F78
       mov       rax,[rax]
       mov       rax,[rax+20]
       ret
; Total bytes of code 18</code></pre><p>That code is loading the address of the field, reading from it the address of the box object, and then reading from that box object the <code>TimeSpan</code> value that‚Äôs stored inside of it. But, now on .NET 8 we get the assembly you‚Äôve now come to expect:</p><pre><code class="language-assembly">; Tests.GetRefreshInterval()
       mov       rax,20D9853AE48
       mov       rax,[rax]
       ret
; Total bytes of code 14</code></pre><p>The box gets allocated on the Non-GC heap, which means the JIT can bake in the address of the object, and we get to save a <code>mov</code>.</p><p>Beyond fewer indirections to access these Non-GC Heap objects, there are other benefits. For example, a ‚Äúgenerational GC‚Äù like the one used in .NET divides the heap into multiple ‚Äúgenerations,‚Äù where generation 0 (‚Äúgen0‚Äù) is for recently created objects and generation 2 (‚Äúgen2‚Äù) is for objects that have been around for a while. When the GC performs a collection, it needs to determine which objects are still alive (still referenced) and which ones can be collected, and to do that it has to trace through all references to find out what objects are still reachable. However, the generational model is beneficial because it can enable the GC to scour through much less of the heap than it might otherwise need to. If it can tell, for example, that there aren‚Äôt any references from gen2 back to gen0, then when doing a gen0 collection, it can avoid enumerating gen2 objects entirely. But to be able to know about such references, the GC needs to know any time a reference is written to a shared location. We can see that in this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    [Benchmark]
    public void Write()
    {
        string dst = &quot;old&quot;;
        Write(ref dst, &quot;new&quot;);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static void Write(ref string dst, string s) =&gt; dst = s;
}</code></pre><p>where the code generated for that <code>Write(ref string, string)</code> method on both .NET 7 and .NET 8 is:</p><pre><code class="language-assembly">; Tests.Write(System.String ByRef, System.String)
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       nop
       ret
; Total bytes of code 7</code></pre><p>That <code>CORINFO_HELP_CHECKED_ASSIGN_REF</code> is a JIT helper function that contains what‚Äôs known as a ‚ÄúGC write barrier,‚Äù a little piece of code that runs to let the GC track that a reference is being written that it might need to know about, e.g. because the object being assigned might be gen0 and the destination might be gen2. We see the same thing on .NET 7 for a tweak to the benchmark like this:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    [Benchmark]
    public void Write()
    {
        string dst = &quot;old&quot;;
        Write(ref dst);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static void Write(ref string dst) =&gt; dst = &quot;new&quot;;
}</code></pre><p>Now we‚Äôre storing a string literal into the destination, and on .NET 7 we see assembly similarly calling <code>CORINFO_HELP_CHECKED_ASSIGN_REF</code>:</p><pre><code class="language-assembly">; Tests.Write(System.String ByRef)
       mov       rdx,1FF0E4014A0
       mov       rdx,[rdx]
       call      CORINFO_HELP_CHECKED_ASSIGN_REF
       nop
       ret
; Total bytes of code 20</code></pre><p>But, now on .NET 8 we see this:</p><pre><code class="language-assembly">; Tests.Write(System.String ByRef)
       mov       rax,1B3814EAEC8
       mov       [rcx],rax
       ret
; Total bytes of code 14</code></pre><p>No write barrier. That‚Äôs thanks to <a href="https://github.com/dotnet/runtime/pull/76135">dotnet/runtime#76135</a>, which recognizes that these Non-GC Heap objects don‚Äôt need to be tracked, since they‚Äôll never be collected anyway. There are multiple other PRs that improve how constant folding works with these Non-GC Heap objects, too, like <a href="https://github.com/dotnet/runtime/pull/85127">dotnet/runtime#85127</a>, <a href="https://github.com/dotnet/runtime/pull/85888">dotnet/runtime#85888</a>, and <a href="https://github.com/dotnet/runtime/pull/86318">dotnet/runtime#86318</a>.</p><h2 id="zeroing">Zeroing</h2><p>The JIT frequently needs to generate code that zeroes out memory. Unless you‚Äôve used <code>[SkipLocalsInit]</code>, for example, any stack space allocated with <code>stackalloc</code> needs to be zeroed, and it‚Äôs the JIT‚Äôs responsibility to generate the code that does so. Consider this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{    
    [Benchmark] public void Constant256() =&gt; Use(stackalloc byte[256]);

    [Benchmark] public void Constant1024() =&gt; Use(stackalloc byte[1024]);

    [MethodImpl(MethodImplOptions.NoInlining)] // prevent stackallocs from being optimized away
    private static void Use(Span&lt;byte&gt; span) { }
}</code></pre><p>Here‚Äôs what the .NET 7 assembly looks like for both <code>Constant256</code> and <code>Constant1024</code>:</p><pre><code class="language-assembly">; Tests.Constant256()
       push      rbp
       sub       rsp,40
       lea       rbp,[rsp+20]
       xor       eax,eax
       mov       [rbp+10],rax
       mov       [rbp+18],rax
       mov       rax,0A77E4BDA96AD
       mov       [rbp+8],rax
       add       rsp,20
       mov       ecx,10
M00_L00:
       push      0
       push      0
       dec       rcx
       jne       short M00_L00
       sub       rsp,20
       lea       rcx,[rsp+20]
       mov       [rbp+10],rcx
       mov       dword ptr [rbp+18],100
       lea       rcx,[rbp+10]
       call      qword ptr [7FFF3DD37900]; Tests.Use(System.Span`1&lt;Byte&gt;)
       mov       rcx,0A77E4BDA96AD
       cmp       [rbp+8],rcx
       je        short M00_L01
       call      CORINFO_HELP_FAIL_FAST
M00_L01:
       nop
       lea       rsp,[rbp+20]
       pop       rbp
       ret
; Total bytes of code 110

; Tests.Constant1024()
       push      rbp
       sub       rsp,40
       lea       rbp,[rsp+20]
       xor       eax,eax
       mov       [rbp+10],rax
       mov       [rbp+18],rax
       mov       rax,606DD723A061
       mov       [rbp+8],rax
       add       rsp,20
       mov       ecx,40
M00_L00:
       push      0
       push      0
       dec       rcx
       jne       short M00_L00
       sub       rsp,20
       lea       rcx,[rsp+20]
       mov       [rbp+10],rcx
       mov       dword ptr [rbp+18],400
       lea       rcx,[rbp+10]
       call      qword ptr [7FFF3DD47900]; Tests.Use(System.Span`1&lt;Byte&gt;)
       mov       rcx,606DD723A061
       cmp       [rbp+8],rcx
       je        short M00_L01
       call      CORINFO_HELP_FAIL_FAST
M00_L01:
       nop
       lea       rsp,[rbp+20]
       pop       rbp
       ret
; Total bytes of code 110</code></pre><p>We can see in the middle there that the JIT has written a zeroing loop, zeroing 16 bytes at a time by pushing two 8-byte <code>0</code>s onto the stack on each iteration:</p><pre><code class="language-assembly">M00_L00:
       push      0
       push      0
       dec       rcx
       jne       short M00_L00</code></pre><p>Now in .NET 8 with <a href="https://github.com/dotnet/runtime/pull/83255">dotnet/runtime#83255</a>, the JIT unrolls and vectorizes that zeroing, and after a certain threshold (which as of <a href="https://github.com/dotnet/runtime/pull/83274">dotnet/runtime#83274</a> has also been updated and made consistent with what other native compilers do), it switches over to using an optimized <code>memset</code> routine rather than emitting a large amount of code to achieve the same thing. Here‚Äôs what we now get on .NET 8 for <code>Constant256</code> (on my machine‚Ä¶ I call that out because the limits are based on what instruction sets are available):</p><pre><code class="language-assembly">; Tests.Constant256()
       push      rbp
       sub       rsp,40
       vzeroupper
       lea       rbp,[rsp+20]
       xor       eax,eax
       mov       [rbp+10],rax
       mov       [rbp+18],rax
       mov       rax,6281D64D33C3
       mov       [rbp+8],rax
       test      [rsp],esp
       sub       rsp,100
       lea       rcx,[rsp+20]
       vxorps    ymm0,ymm0,ymm0
       vmovdqu   ymmword ptr [rcx],ymm0
       vmovdqu   ymmword ptr [rcx+20],ymm0
       vmovdqu   ymmword ptr [rcx+40],ymm0
       vmovdqu   ymmword ptr [rcx+60],ymm0
       vmovdqu   ymmword ptr [rcx+80],ymm0
       vmovdqu   ymmword ptr [rcx+0A0],ymm0
       vmovdqu   ymmword ptr [rcx+0C0],ymm0
       vmovdqu   ymmword ptr [rcx+0E0],ymm0
       mov       [rbp+10],rcx
       mov       dword ptr [rbp+18],100
       lea       rcx,[rbp+10]
       call      qword ptr [7FFEB7D3F498]; Tests.Use(System.Span`1&lt;Byte&gt;)
       mov       rcx,6281D64D33C3
       cmp       [rbp+8],rcx
       je        short M00_L00
       call      CORINFO_HELP_FAIL_FAST
M00_L00:
       nop
       lea       rsp,[rbp+20]
       pop       rbp
       ret
; Total bytes of code 156</code></pre><p>Notice there‚Äôs no zeroing loop, and instead we see a bunch of 256-bit <code>vmovdqu</code> move instructions to copy the zeroed out <code>ymm0</code> register to the next portion of the stack. And then for <code>Constant1024</code> we see:</p><pre><code class="language-assembly">; Tests.Constant1024()
       push      rbp
       sub       rsp,40
       lea       rbp,[rsp+20]
       xor       eax,eax
       mov       [rbp+10],rax
       mov       [rbp+18],rax
       mov       rax,0CAF12189F783
       mov       [rbp],rax
       test      [rsp],esp
       sub       rsp,400
       lea       rcx,[rsp+20]
       mov       [rbp+8],rcx
       xor       edx,edx
       mov       r8d,400
       call      CORINFO_HELP_MEMSET
       mov       rcx,[rbp+8]
       mov       [rbp+10],rcx
       mov       dword ptr [rbp+18],400
       lea       rcx,[rbp+10]
       call      qword ptr [7FFEB7D5F498]; Tests.Use(System.Span`1&lt;Byte&gt;)
       mov       rcx,0CAF12189F783
       cmp       [rbp],rcx
       je        short M00_L00
       call      CORINFO_HELP_FAIL_FAST
M00_L00:
       nop
       lea       rsp,[rbp+20]
       pop       rbp
       ret
; Total bytes of code 119</code></pre><p>Again, no zeroing loop, and instead we see <code>call CORINFO_HELP_MEMSET</code>, relying on the optimized underlying <code>memset</code> to efficiently handle the zeroing. The effects of this are visible in throughput numbers as well:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Constant256</td><td>.NET 7.0</td><td style="text-align: right">7.927 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Constant256</td><td>.NET 8.0</td><td style="text-align: right">3.181 ns</td><td style="text-align: right">0.40</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Constant1024</td><td>.NET 7.0</td><td style="text-align: right">30.523 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Constant1024</td><td>.NET 8.0</td><td style="text-align: right">8.850 ns</td><td style="text-align: right">0.29</td></tr></tbody></table><p><a href="https://github.com/dotnet/runtime/pull/83488">dotnet/runtime#83488</a> improved this further by using a standard trick frequently employed when vectorizing algorithms. Let‚Äôs say you want to zero out 120 bytes and you have at your disposal an instruction for zeroing out 32 bytes at a time. We can issue three such instructions to zero out 96 bytes, but we‚Äôre then left with 24 bytes that still need to be zeroed. What do we do? We can‚Äôt write another 32 bytes from where we left off, as we might then be overwriting 8 bytes we shouldn‚Äôt be touching. We could use scalar zeroing and issue three instructions each for 8 bytes, but could we do it in just a single instruction? Yes! Since the writes are idempotent, we can just zero out the last 32 bytes of the 120 bytes, even though that means we‚Äôll be re-zeroing 8 bytes we already zeroed. You can see this same approach utilized in many of the vectorized operations throughout the core libraries, and as of this PR, the JIT employs it when zeroing as well.</p><p><a href="https://github.com/dotnet/runtime/pull/85389">dotnet/runtime#85389</a> takes this further and uses AVX512 to improve bulk operations like this zeroing. So, running the same benchmark on my Dev Box with AVX512, I see this assembly generated for <code>Constant256</code>:</p><pre><code class="language-assembly">; Tests.Constant256()
       push      rbp
       sub       rsp,40
       vzeroupper
       lea       rbp,[rsp+20]
       xor       eax,eax
       mov       [rbp+10],rax
       mov       [rbp+18],rax
       mov       rax,992482B435F7
       mov       [rbp+8],rax
       test      [rsp],esp
       sub       rsp,100
       lea       rcx,[rsp+20]
       vxorps    ymm0,ymm0,ymm0
       vmovdqu32 [rcx],zmm0
       vmovdqu32 [rcx+40],zmm0
       vmovdqu32 [rcx+80],zmm0
       vmovdqu32 [rcx+0C0],zmm0
       mov       [rbp+10],rcx
       mov       dword ptr [rbp+18],100
       lea       rcx,[rbp+10]
       call      qword ptr [7FFCE555F4B0]; Tests.Use(System.Span`1&lt;Byte&gt;)
       mov       rcx,992482B435F7
       cmp       [rbp+8],rcx
       je        short M00_L00
       call      CORINFO_HELP_FAIL_FAST
M00_L00:
       nop
       lea       rsp,[rbp+20]
       pop       rbp
       ret
; Total bytes of code 132</code></pre><pre><code class="language-assembly">; Tests.Use(System.Span`1&lt;Byte&gt;)
       ret
; Total bytes of code 1</code></pre><p>Note that now, rather than eight <code>vmovdqu</code> instructions with <code>ymm0</code>, we see four <code>vmovdqu32</code> instructions with <code>zmm0</code>, as each move instruction is able to zero out twice as much, with each instruction handling 64 bytes at a time.</p><h2 id="value-types">Value Types</h2><p>Value types (structs) have been used increasingly as part of high-performance code. Yet while they have obvious advantages (they don‚Äôt require heap allocation and thus reduce pressure on the GC), they also have disadvantages (more data being copied around) and have historically not been as optimized as someone relying on them heavily for performance might like. It‚Äôs been a key focus area of improvement for the JIT in the last several releases of .NET, and that continues into .NET 8.</p><p>One specific area of improvement here is around ‚Äúpromotion.‚Äù In this context, promotion is the idea of splitting a struct apart into its constituent fields, effectively treating each field as its own local. This can lead to a number of valuable optimizations, including being able to enregister portions of a struct. As of .NET 7, the JIT does support struct promotion, but with limitations, including only supporting structs with at most four fields and not supporting nested structs (other than for primitive types).</p><p>A lot of work in .NET 8 went into removing those restrictions. <a href="https://github.com/dotnet/runtime/pull/83388">dotnet/runtime#83388</a> improves upon the existing promotion support with an additional optimization pass the JIT refers to as ‚Äúphysical promotion;‚Äù it does away with both of those cited limitations, however as of this PR the feature was still disabled by default. Other PRs like <a href="https://github.com/dotnet/runtime/pull/85105">dotnet/runtime#85105</a> and <a href="https://github.com/dotnet/runtime/pull/86043">dotnet/runtime#86043</a> improved it further, and <a href="https://github.com/dotnet/runtime/pull/88090">dotnet/runtime#88090</a> enabled the optimizations by default. The net result is visible in a benchmark like the following:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    private ParsedStat _stat;

    [Benchmark]
    public ulong GetTime()
    {
        ParsedStat stat = _stat;
        return stat.utime + stat.stime;
    }

    internal struct ParsedStat
    {
        internal int pid;
        internal string comm;
        internal char state;
        internal int ppid;
        internal int session;
        internal ulong utime;
        internal ulong stime;
        internal long nice;
        internal ulong starttime;
        internal ulong vsize;
        internal long rss;
        internal ulong rsslim;
    }
}</code></pre><p>Here we have a struct modeling some data that might be extracted from a <code>procfs</code><code>stat</code> file on Linux. The benchmark makes a local copy of the struct and returns a sum of the user and kernel times. In .NET 7, the assembly looks like this:</p><pre><code class="language-assembly">; Tests.GetTime()
       push      rdi
       push      rsi
       sub       rsp,58
       lea       rsi,[rcx+8]
       lea       rdi,[rsp+8]
       mov       ecx,0A
       rep movsq
       mov       rax,[rsp+10]
       add       rax,[rsp+18]
       add       rsp,58
       pop       rsi
       pop       rdi
       ret
; Total bytes of code 40</code></pre><p>The two really interesting instructions here are these:</p><pre><code class="language-assembly">mov ecx,0A
rep movsq</code></pre><p>The <code>ParsedStat</code> struct is 80 bytes in size, and this pair of instructions is repeatedly (<code>rep</code>) copying 8-bytes (<code>movsq</code>) 10 times (<code>ecx</code> that‚Äôs been populated with 0xA) from the source location in <code>rsi</code> (which was initialized with <code>[rcx+8]</code>, aka the location of the <code>_stat</code> field) to the destination location in <code>rdi</code> (a stack location at <code>[rsp+8]</code>). In other words, this is making a full copy of the whole struct, even though we only need two fields from it. Now in .NET 8, we get this:</p><pre><code class="language-assembly">; Tests.GetTime()
       add       rcx,8
       mov       rax,[rcx+8]
       mov       rcx,[rcx+10]
       add       rax,rcx
       ret
; Total bytes of code 16</code></pre><p>Ahhh, so much nicer. Now it‚Äôs avoided the whole copy, and is simply moving the relevant <code>ulong</code> values into registers and adding them together.</p><p>Here‚Äôs another example:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;.NET 7&quot;).WithRuntime(CoreRuntime.Core70).AsBaseline())
    .AddJob(Job.Default.WithId(&quot;.NET 8 w/o PGO&quot;).WithRuntime(CoreRuntime.Core80).WithEnvironmentVariable(&quot;DOTNET_TieredPGO&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;.NET 8&quot;).WithRuntime(CoreRuntime.Core80));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;, &quot;Runtime&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private readonly List&lt;int?&gt; _list = Enumerable.Range(0, 10000).Select(i =&gt; (int?)i).ToList();

    [Benchmark]
    public int CountList()
    {
        int count = 0;
        foreach (int? i in _list)
            if (i is not null)
                count++;

        return count;
    }
}</code></pre><p><code>List&lt;T&gt;</code> has a struct <code>List&lt;T&gt;.Enumerator</code> that‚Äôs returned from <code>List&lt;T&gt;.GetEnumerator()</code>, such that when you <code>foreach</code> the list directly (rather than as an <code>IEnumerable&lt;T&gt;</code>), the C# compiler binds to this struct enumerator via the enumerator pattern. This example runs afoul of the previous limitations in two ways. That <code>Enumerator</code> has a field for the current <code>T</code>, so if <code>T</code> is a non-primitive value type, it violates the ‚Äúno nested structs‚Äù limitation. And that <code>Enumerator</code> has four fields, so if that <code>T</code> has multiple fields, it pushes it beyond the four-field limit. Now in .NET 8, the JIT is able to see through the struct to its fields, and optimize the enumeration of the list to a much more efficient result.</p><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>CountList</td><td>.NET 7</td><td style="text-align: right">18.878 us</td><td style="text-align: right">1.00</td><td style="text-align: right">215 B</td></tr><tr><td>CountList</td><td>.NET 8 w/o PGO</td><td style="text-align: right">11.726 us</td><td style="text-align: right">0.62</td><td style="text-align: right">70 B</td></tr><tr><td>CountList</td><td>.NET 8</td><td style="text-align: right">5.912 us</td><td style="text-align: right">0.31</td><td style="text-align: right">66 B</td></tr></tbody></table><p>Note the significant improvement in both throughput and code size from .NET 7 to .NET 8 even without PGO. However, the gap here between .NET 8 without PGO and with PGO is also interesting, albeit for other reasons. We see an almost halving of execution time with PGO applied, but only four bytes of difference in assembly code size. Those four bytes stem from a single <code>mov</code> instruction that PGO was able to help remove, which we can see easily by pasting the two snippets into a diffing tool:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/ExtraMovInDiffChecker.png" alt="An extra mov highlighted in a diff tool" />
~12us down to ~6us is a lot for a difference of a single <code>mov</code>‚Ä¶ why such an outsized impact? This ends up being a really good example of what I mentioned at the beginning of this article: beware microbenchmarks, as they can differ from machine to machine. Or in this case, in particular from processor to processor. The machine on which I‚Äôm writing this and on which I‚Äôve run the majority of the benchmarks in this post is a several year old desktop with an Intel Coffee Lake processor. When I run the same benchmark on my Dev Box, which has an Intel Xeon Platinum 8370C, I see this:</p><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>CountList</td><td>.NET 7</td><td style="text-align: right">15.804 us</td><td style="text-align: right">1.00</td><td style="text-align: right">215 B</td></tr><tr><td>CountList</td><td>.NET 8 w/o PGO</td><td style="text-align: right">7.138 us</td><td style="text-align: right">0.45</td><td style="text-align: right">70 B</td></tr><tr><td>CountList</td><td>.NET 8</td><td style="text-align: right">6.111 us</td><td style="text-align: right">0.39</td><td style="text-align: right">66 B</td></tr></tbody></table><p>Same code size, still a large improvement due to physical promotion, but now only a small ~15% rather than ~2x improvement from PGO. As it turns out, Coffee Lake is one of the processors affected by the Jump Conditional Code <a href="https://www.intel.com/content/dam/support/us/en/documents/processors/mitigations-jump-conditional-code-erratum.pdf">(JCC) Erratum</a> issued in 2019 (‚Äúerratum‚Äù here is a fancy way of saying ‚Äúbug‚Äù, or alternatively, ‚Äúdocumentation about a bug‚Äù). The problem involved jump instructions on a 32-byte boundary, and the hardware caching information about those instructions. The issue was then subsequently fixed via a microcode update that disabled the relevant caching, but that then created a possible performance issue, as whether a jump is on a 32-byte boundary impacts whether it‚Äôs cached and therefore the resulting performance gains that cache was introduced to provide. If I set the <code>DOTNET_JitDisasm</code> environment variable to <code>*CountList*</code> (to get the JIT to output the disassembly directly, rather than relying on BenchmarkDotNet to fish it out), and set the <code>DOTNET_JitDisasmWithAlignmentBoundaries</code> environment variable to <code>1</code> (to get the JIT to include alignment boundary information in that output), I see this:</p><pre><code class="language-assembly">G_M000_IG04:                ;; offset=0018H
       mov      r8d, dword ptr [rcx+10H]
       cmp      edx, r8d
       jae      SHORT G_M000_IG05
; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (jae: 1 ; jcc erratum) 32B boundary ...............................
       mov      r8, gword ptr [rcx+08H]</code></pre><p>Sure enough, we see that this jump instruction is falling on a 32-byte boundary. When PGO kicks in and removes the earlier <code>mov</code>, that changes the alignment such that the jump is no longer on a 32-byte boundary:</p><pre><code class="language-assembly">G_M000_IG05:                ;; offset=0018H
       cmp      edx, dword ptr [rcx+10H]
       jae      SHORT G_M000_IG06
       mov      r8, gword ptr [rcx+08H]
; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (mov: 1) 32B boundary ...............................
       cmp      edx, dword ptr [r8+08H]</code></pre><p>This is all to say, again, there are many things that can impact microbenchmarks, and it‚Äôs valuable to understand the source of a difference rather than just taking it at face value.</p><p>Ok, where were we? Oh yeah, structs. Another improvement related to structs comes in <a href="https://github.com/dotnet/runtime/pull/79346">dotnet/runtime#79346</a>, which adds an additional ‚Äúliveness‚Äù optimization pass earlier than the others it already has (liveness is just an indication of whether a variable might still be needed because its value might be used again in the future). This then allows the JIT to remove some struct copies it wasn‚Äôt previously able to, in particular in situations where the last time the struct is used is in passing it to another method. However, this additional liveness pass has other benefits as well, in particular with relation to ‚Äúforward substitution.‚Äù Forward substitution is an optimization that can be thought of as the opposite of ‚Äúcommon subexpression elimination‚Äù (CSE). With CSE, the compiler replaces an expression with something containing the result already computed for that expression, so for example if you had:</p><pre><code class="language-C#">int c = (a + b) + 3;
int d = (a + b) * 4;</code></pre><p>a compiler might use CSE to rewrite that as:</p><pre><code class="language-C#">int tmp = a + b;
int c = tmp + 3;
int d = tmp * 4;</code></pre><p>Forward substitution could be used to undo that, distributing the expression feeding into <code>tmp</code> back to where <code>tmp</code> is used, such that we end up back with:</p><pre><code class="language-C#">int c = (a + b) + 3;
int d = (a + b) * 4;</code></pre><p>Why would a compiler want to do that? It can make certain subsequent optimizations easier for it to see. For example, consider this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    [Benchmark]
    [Arguments(42)]
    public int Merge(int a)
    {
        a *= 3;
        a *= 3;
        return a;
    }
}</code></pre><p>On .NET 7, that results in this assembly:</p><pre><code class="language-assembly">; Tests.Merge(Int32)
       lea       edx,[rdx+rdx*2]
       lea       edx,[rdx+rdx*2]
       mov       eax,edx
       ret
; Total bytes of code 9</code></pre><p>The generated code here is performing each multiplication individually. But when we view:</p><pre><code class="language-C#">a *= 3;
a *= 3;
return a;</code></pre><p>instead as:</p><pre><code class="language-C#">a = a * 3;
a = a * 3;
return a;</code></pre><p>and knowing that the initial result stored into <code>a</code> is temporary (thank you, liveness), forward substitution can turn that into:</p><pre><code class="language-C#">a = (a * 3) * 3;
return a;</code></pre><p>at which point constant folding can kick in. Now on .NET 8 we get:</p><pre><code class="language-assembly">; Tests.Merge(Int32)
       lea       eax,[rdx+rdx*8]
       ret
; Total bytes of code 4</code></pre><p>Another change related to liveness is <a href="https://github.com/dotnet/runtime/pull/77990">dotnet/runtime#77990</a> from <a href="https://github.com/SingleAccretion">@SingleAccretion</a>. This adds another pass over one of the JIT‚Äôs internal representations, eliminating writes it finds to be useless.</p><h2 id="casting">Casting</h2><p>Various improvements have gone into improving the performance of casting in .NET 8.</p><p><a href="https://github.com/dotnet/runtime/pull/75816">dotnet/runtime#75816</a> improved the performance of using <code>is T[]</code> when <code>T</code> is sealed. There‚Äôs a <code>CORINFO_HELP_ISINSTANCEOFARRAY</code> helper the JIT uses to determine whether an object is of a specified array type, but when the <code>T</code> is sealed, the JIT can instead emit it without the helper, generating code as if it were written like <code>obj is not null &amp;&amp; obj.GetType() == typeof(T[])</code>. This is another example where dynamic PGO has a measurable impact, so the benchmark highlights the improvements with and without it.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;.NET 7&quot;).WithRuntime(CoreRuntime.Core70).AsBaseline())
    .AddJob(Job.Default.WithId(&quot;.NET 8 w/o PGO&quot;).WithRuntime(CoreRuntime.Core80).WithEnvironmentVariable(&quot;DOTNET_TieredPGO&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;.NET 8&quot;).WithRuntime(CoreRuntime.Core80));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;, &quot;Runtime&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private readonly object _obj = new string[1];

    [Benchmark]
    public bool IsStringArray() =&gt; _obj is string[];
}</code></pre><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>IsStringArray</td><td>.NET 7</td><td style="text-align: right">1.2290 ns</td><td style="text-align: right">1.00</td></tr><tr><td>IsStringArray</td><td>.NET 8 w/o PGO</td><td style="text-align: right">0.2365 ns</td><td style="text-align: right">0.19</td></tr><tr><td>IsStringArray</td><td>.NET 8</td><td style="text-align: right">0.0825 ns</td><td style="text-align: right">0.07</td></tr></tbody></table><p>Moving on, consider this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser(maxDepth: 0)]
public class Tests
{
    private readonly string[] _strings = new string[1];

    [Benchmark]
    public string Get1() =&gt; _strings[0];

    [Benchmark]
    public string Get2() =&gt; Volatile.Read(ref _strings[0]);
}</code></pre><p><code>Get1</code> here is just reading and returning the 0th element from the array. <code>Get2</code> here is returning a <code>ref</code> to the 0th element from the array. Here‚Äôs the assembly we get in .NET 7:</p><pre><code class="language-assembly">; Tests.Get1()
       sub       rsp,28
       mov       rax,[rcx+8]
       cmp       dword ptr [rax+8],0
       jbe       short M00_L00
       mov       rax,[rax+10]
       add       rsp,28
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 29

; Tests.Get2()
       sub       rsp,28
       mov       rcx,[rcx+8]
       xor       edx,edx
       mov       r8,offset MT_System.String
       call      CORINFO_HELP_LDELEMA_REF
       nop
       add       rsp,28
       ret
; Total bytes of code 31</code></pre><p>In <code>Get1</code>, we‚Äôre immediately using the array element, so the C# compiler can emit a <code>ldelem.ref</code> IL instruction, but in <code>Get2</code>, the reference to the array element is being returned, so the C# compiler emits a <code>ldelema</code> (load element address) instruction. In the general case, <code>ldelema</code> requires a type check, because of covariance; you could have a <code>Base[] array = new DerivedFromBase[1];</code>, in which case if you handed out a <code>ref Base</code> pointing into that array and someone wrote a <code>new AlsoDerivedFromBase()</code> via that <code>ref</code>, type safety would be violated (since you‚Äôd be storing an <code>AlsoDerivedFromBase</code> into a <code>DerivedFromBase[]</code> even though <code>DerivedFromBase</code> and <code>AlsoDerivedFromBase</code> aren‚Äôt related). As such, the .NET 7 assembly for this code includes a call to <code>CORINFO_HELP_LDELEMA_REF</code>, which is the helper function the JIT uses to perform that type check. But the array element type here is <code>string</code>, which is sealed, which means we can‚Äôt get into that problematic situation: there‚Äôs no type you can store into a <code>string</code> variable other than <code>string</code>. Thus, this helper call is superfluous, and with <a href="https://github.com/dotnet/runtime/pull/85256">dotnet/runtime#85256</a>, the JIT can now avoid using it. On .NET 8, then, we get this for <code>Get2</code>:</p><pre><code class="language-assembly">; Tests.Get2()
       sub       rsp,28
       mov       rax,[rcx+8]
       cmp       dword ptr [rax+8],0
       jbe       short M00_L00
       add       rax,10
       add       rsp,28
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 29</code></pre><p>No <code>CORINFO_HELP_LDELEMA_REF</code> in sight.</p><p>And then <a href="https://github.com/dotnet/runtime/pull/86728">dotnet/runtime#86728</a> reduces the costs associated with a generic cast. Previously the JIT would always use a <code>CastHelpers.ChkCastAny</code> method to perform the cast, but with this change, it inlines a fast success path.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly object _o = &quot;hello&quot;;

    [Benchmark]
    public string GetString() =&gt; Cast&lt;string&gt;(_o);

    [MethodImpl(MethodImplOptions.NoInlining)]
    public T Cast&lt;T&gt;(object o) =&gt; (T)o;
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>GetString</td><td>.NET 7.0</td><td style="text-align: right">2.247 ns</td><td style="text-align: right">1.00</td></tr><tr><td>GetString</td><td>.NET 8.0</td><td style="text-align: right">1.300 ns</td><td style="text-align: right">0.58</td></tr></tbody></table><h2 id="peephole-optimizations">Peephole Optimizations</h2><p>A ‚Äúpeephole optimization‚Äù is one in which a small sequence of instructions is replaced by a different sequence that is expected to perform better. This could include getting rid of instructions deemed unnecessary or replacing two instructions with one instruction that can accomplish the same task. Every release of .NET features a multitude of new peephole optimizations, often inspired by real-world examples where some overhead could be trimmed by slightly increasing code quality, and .NET 8 is no exception. Here are just some of these optimizations in .NET 8:</p><ul><li><a href="https://github.com/dotnet/runtime/pull/73120">dotnet/runtime#73120</a> from <a href="https://github.com/dubiousconst282">@dubiousconst282</a> and <a href="https://github.com/dotnet/runtime/pull/74806">dotnet/runtime#74806</a> from <a href="https://github.com/En3Tho">@En3Tho</a> improved the handling of the common bit-test patterns like <code>(x &amp; 1) != 0</code>.</li><li><a href="https://github.com/dotnet/runtime/pull/77874">dotnet/runtime#77874</a> gets rid of some unnecessary casts in a method like <code>short Add(short x, short y) =&gt; (short)(x + y)</code>.</li><li><a href="https://github.com/dotnet/runtime/pull/76981">dotnet/runtime#76981</a> improves the performance of multiplying by a number that‚Äôs one away from a power of two, by replacing an <code>imul</code> instruction with a three-instruction <code>mov</code>/<code>shl</code>/<code>add</code> sequence, and <a href="https://github.com/dotnet/runtime/pull/77137">dotnet/runtime#77137</a> improves other multiplications by a constant via replacing a <code>mov</code>/<code>shl</code> sequence with a single <code>lea</code>.</li><li><a href="https://github.com/dotnet/runtime/pull/78786">dotnet/runtime#78786</a> from <a href="https://github.com/pedrobsaila">@pedrobsaila</a> fuses together separate conditions like <code>value &lt; 0 || value == 0</code> into the equivalent of <code>value &lt;= 0</code>.</li><li><a href="https://github.com/dotnet/runtime/pull/82750">dotnet/runtime#82750</a> eliminates some redundant <code>cmp</code> instructions.</li><li><a href="https://github.com/dotnet/runtime/pull/79630">dotnet/runtime#79630</a> avoids an unnecessary <code>and</code> in a method like <code>static byte Mod(uint i) =&gt; (byte)(i % 256)</code>.</li><li><a href="https://github.com/dotnet/runtime/pull/77540">dotnet/runtime#77540</a> from <a href="https://github.com/AndyJGraham">@AndyJGraham</a>, <a href="https://github.com/dotnet/runtime/pull/84399">dotnet/runtime#84399</a>, and <a href="https://github.com/dotnet/runtime/pull/85032">dotnet/runtime#85032</a> optimize pairs of load and store instructions and replace them with a single <code>ldp</code> or <code>stp</code> instruction on Arm.</li><li><a href="https://github.com/dotnet/runtime/pull/84350">dotnet/runtime#84350</a> similarly optimizes pairs of <code>str wzr</code> instructions to be <code>str xzr</code> instructions.</li><li><a href="https://github.com/dotnet/runtime/pull/83458">dotnet/runtime#83458</a> from <a href="https://github.com/SwapnilGaikwad">@SwapnilGaikwad</a> optimizes some redundant memory loads on Arm by replacing some <code>ldr</code> instructions with <code>mov</code> instructions.</li><li><a href="https://github.com/dotnet/runtime/pull/83176">dotnet/runtime#83176</a> optimizes an <code>x &lt; 0</code> expression from emitting a <code>cmp</code>/<code>cset</code> sequence on Arm to instead emitting an <code>lsr</code> instruction.</li><li><a href="https://github.com/dotnet/runtime/pull/82924">dotnet/runtime#82924</a> removes a redundant overflow check on Arm for some division operations.</li><li><a href="https://github.com/dotnet/runtime/pull/84605">dotnet/runtime#84605</a> combines an <code>lsl</code>/<code>cmp</code> sequence on Arm into a single <code>cmp</code>.</li><li><a href="https://github.com/dotnet/runtime/pull/84667">dotnet/runtime#84667</a> combines <code>neg</code> and <code>cmp</code> sequences into use of <code>cmn</code> on Arm.</li><li><a href="https://github.com/dotnet/runtime/pull/79550">dotnet/runtime#79550</a> replaces <code>mul</code>/<code>neg</code> sequences on Arm with <code>mneg</code>.</li></ul><h2 id="native-aot">Native AOT</h2><p>Native AOT shipped in .NET 7. It enables .NET programs to be compiled at build time into a self-contained executable or library composed entirely of native code: no JIT is required at execution time to compile anything, and in fact there‚Äôs no JIT included with the compiled program. The result is an application that can have a very small on-disk footprint, a small memory footprint, and very fast startup time. In .NET 7, the primary supported workloads were console applications. Now in .NET 8, a lot of work has gone into making ASP.NET applications shine when compiled with Native AOT, as well as driving down overall costs, regardless of app model.</p><p>A significant focus in .NET 8 was on reducing the size of built applications, and the net effect of this is quite easy to see. Let‚Äôs start by creating a new Native AOT console app:</p><pre><code class="language-sh">dotnet new console -o nativeaotexample -f net7.0</code></pre><p>That creates a new <code>nativeaotexample</code> directory and adds to it a new ‚ÄúHello, world‚Äù app that targets .NET 7. Edit the generated nativeaotexample.csproj in two ways:</p><ol><li>Change the <code>&lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;</code> to instead be <code>&lt;TargetFrameworks&gt;net7.0;net8.0&lt;/TargetFrameworks&gt;</code>, so that we can easily build for either .NET 7 or .NET 8.</li><li>Add <code>&lt;PublishAot&gt;true&lt;/PublishAot&gt;</code> to the <code>&lt;PropertyGroup&gt;...&lt;/PropertyGroup&gt;</code>, so that when we <code>dotnet publish</code>, it uses Native AOT.</li></ol><p>Now, publish the app for .NET 7. I‚Äôm currently targeting Linux for x64, so I‚Äôm using <code>linux-x64</code>, but you can follow along on Windows with a Windows identifier, like <code>win-x64</code>:</p><pre><code class="language-sh">dotnet publish -f net7.0 -r linux-x64 -c Release</code></pre><p>That should successfully build the app, producing a standalone executable, and we can <code>ls</code>/<code>dir</code> the output directory to see the produced binary size (here I‚Äôve used <code>ls -s --block-size=k</code>):</p><pre><code class="language-text">12820K /home/stoub/nativeaotexample/bin/Release/net7.0/linux-x64/publish/nativeaotexample</code></pre><p>So, on .NET 7 on Linux, this ‚ÄúHello, world‚Äù application, including all necessary library support, the GC, everything, is ~13Mb. Now, we can do the same for .NET 8:</p><pre><code class="language-sh">dotnet publish -f net8.0 -r linux-x64 -c Release</code></pre><p>and again see the generated output size:</p><pre><code class="language-text">1536K /home/stoub/nativeaotexample/bin/Release/net8.0/linux-x64/publish/nativeaotexample</code></pre><p>Now on .NET 8, that ~13MB has dropped to ~1.5M! We can get it smaller, too, using various supported configuration flags. First, we can set a size vs speed option introduced in <a href="https://github.com/dotnet/runtime/pull/85133">dotnet/runtime#85133</a>, adding <code>&lt;OptimizationPreference&gt;Size&lt;/OptimizationPreference&gt;</code> to the .csproj. Then if I don‚Äôt need globalization-specific code and data and am ok utilizing an invariant mode, I can add <code>&lt;InvariantGlobalization&gt;true&lt;/InvariantGlobalization&gt;</code>. Maybe I don‚Äôt care about having good stack traces if an exception occurs? <a href="https://github.com/dotnet/runtime/pull/88235">dotnet/runtime#88235</a> added the <code>&lt;StackTraceSupport&gt;false&lt;/StackTraceSupport&gt;</code> option. Add all of those and republish:</p><pre><code class="language-text">1248K /home/stoub/nativeaotexample/bin/Release/net8.0/linux-x64/publish/nativeaotexample</code></pre><p>Sweet.</p><p>A good chunk of those improvements came from a relentless effort that involved hacking away at the size, 10Kb here, 20Kb there. Some examples that drove down these sizes:</p><ul><li>There are a variety of data structures the Native AOT compiler needs to create that then need to be used by the runtime when the app executes. <a href="https://github.com/dotnet/runtime/pull/77884">dotnet/runtime#77884</a> added support for these data structures, including ones containing pointers, to be stored into the application and then rehydrated at execution time. Even before being extended in a variety of ways by subsequent PRs, this shaved hundreds of kilobytes off the app size, on both Windows and Linux (but more so on Linux).</li><li>Every type with a static field containing references has a data structure associated with it containing a few pointers. <a href="https://github.com/dotnet/runtime/pull/78794">dotnet/runtime#78794</a> made those pointers relative, saving ~0.5% of the HelloWorld app size (at least on Linux, a bit less on Windows). <a href="https://github.com/dotnet/runtime/pull/78801">dotnet/runtime#78801</a> did the same for another set of pointers, saving another ~1%.</li><li><a href="https://github.com/dotnet/runtime/pull/79594">dotnet/runtime#79594</a> removed some over-aggressive tracking of types and methods that needed data stored about them for reflection. This saved another ~32Kb on HelloWorld.</li><li>In some cases, generic type dictionaries were being created even if they were never used and thus empty. <a href="https://github.com/dotnet/runtime/pull/82591">dotnet/runtime#82591</a> got rid of these, saving another ~1.5% on a simple ASP.NET minimal APIs app. <a href="https://github.com/dotnet/runtime/pull/83367">dotnet/runtime#83367</a> saved another ~20Kb by ridding itself of other empty type dictionaries.</li><li>Members declared on a generic type have their code copied and specialized for each value type that‚Äôs substituted for the generic type parameter. However, if with some tweaks those members can be made non-generic and moved out of the type, such as into a non-generic base type, that duplication can be avoided. <a href="https://github.com/dotnet/runtime/pull/82923">dotnet/runtime#82923</a> did so for array enumerators, moving down the <code>IDisposable</code> and non-generic <code>IEnumerator</code> interface implementations.</li><li><code>CoreLib</code> has an implementation of an empty array enumerator that can be used when enumerating a <code>T[]</code> that‚Äôs empty, and that singleton may be used in non-array enumerables, e.g. enumerating an empty <code>(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)Dictionary&lt;TKey, TValue&gt;</code> could produce that array enumerator singleton. That enumerator, however, has a reference to a <code>T[]</code>, and in the Native AOT world, using the enumerator then means code needs to be produced for the various members of <code>T[]</code>. If, however, the enumerator in question is for a <code>T[]</code> that‚Äôs unlikely to be used elsewhere (e.g. <code>KeyValuePair&lt;TKey, TValue&gt;[]</code>), <a href="https://github.com/dotnet/runtime/pull/82899">dotnet/runtime#82899</a> supplies a specialized enumerator singleton that doesn‚Äôt reference <code>T[]</code>, avoiding forcing that code to be created and kept (for example, code for a <code>Dictionary&lt;TKey, TValue&gt;</code>‚Äòs <code>IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;</code>).</li><li>No one ever calls the <code>Equals</code>/<code>GetHashCode</code> methods on the <code>AsyncStateMachine</code> structs produced by the C# compiler for async methods; they‚Äôre a hidden implementation detail, but even so, such virtual methods are in general kept rooted in a Native AOT app (and whereas CoreCLR can use reflection to provide the implementation of these methods for value types, Native AOT needs customized code emitted for each). <a href="https://github.com/dotnet/runtime/pull/83369">dotnet/runtime#83369</a> special-cased these to avoid them being kept, shaving another ~1% off a minimal APIs app.</li><li><a href="https://github.com/dotnet/runtime/pull/83937">dotnet/runtime#83937</a> reduced the size of static constructor contexts, data structures used to pass information about a type‚Äôs static <code>cctor</code> between portions of the system.</li><li><a href="https://github.com/dotnet/runtime/pull/84463">dotnet/runtime#84463</a> made a few tweaks that ended up avoiding creating <code>MethodTable</code>s for <code>double</code>/<code>float</code> and that reduced reliance on some array methods, shaving another ~3% off HelloWorld.</li><li><a href="https://github.com/dotnet/runtime/pull/84156">dotnet/runtime#84156</a> manually split a method into two portions such that some lesser-used code isn‚Äôt always brought in when using the more commonly-used code; this saved another several hundred kilobytes.</li><li><a href="https://github.com/dotnet/runtime/pull/84224">dotnet/runtime#84224</a> improved handling of the common pattern <code>typeof(T) == typeof(Something)</code> that‚Äôs often used to do generic specialization (e.g. such as in code like <code>MemoryExtensions</code>), doing it in a way that makes it easier to get rid of side effects from branches that are trimmed away.</li><li>The GC includes a vectorized sort implementation called <code>vxsort</code>. When building with a configuration optimized for size, <a href="https://github.com/dotnet/runtime/pull/85036">dotnet/runtime#85036</a> enabled removing that throughput optimization, saving several hundred kilobytes.</li><li><code>ValueTuple&lt;...&gt;</code> is a very handy type, but it brings a lot of code with it, as it implements multiple interfaces which then end up rooting functionality on the generic type parameters. <a href="https://github.com/dotnet/runtime/pull/87120">dotnet/runtime#87120</a> removed a use of <code>ValueTuple&lt;T1, T2&gt;</code> from <code>SynchronizationContext</code>, saving ~200Kb.</li><li>On Linux specifically, a large improvement came from <a href="https://github.com/dotnet/runtime/pull/85139">dotnet/runtime#85139</a>. Debug symbols were previously being stored in the published executable; with this change, symbols are stripped from the executable and are instead stored in a separate <code>.dbg</code> file built next to it. Someone who wants to revert to keeping the symbols in the executable can add <code>&lt;StripSymbols&gt;false&lt;/StripSymbols&gt;</code> to in their project.</li></ul><p>You get the idea. The improvements go beyond nipping and tucking here and there within the Native AOT compiler, though. Individual libraries also contributed. For example:</p><ul><li><p><code>HttpClient</code> supports automatic decompression of response streams, for both <code>deflate</code> and <code>brotli</code>, and that in turn means that any <code>HttpClient</code> use implicitly brings with it most of <code>System.IO.Compression</code>. However, by default that decompression isn‚Äôt enabled, and you need to opt-in to it by explicitly setting the <code>AutomaticDecompression</code> property on the <code>HttpClientHandler</code> or <code>SocketsHttpHandler</code> in use. So, <a href="https://github.com/dotnet/runtime/pull/78198">dotnet/runtime#78198</a> employs a trick where rather than <code>SocketsHttpHandler</code>‚Äòs main code paths relying directly on the internal <code>DecompressionHandler</code> that does this work, it instead relies on a delegate. The field storing that delegate starts out as null, and then as part of the <code>AutomaticDecompression</code> setter, that field is set to a delegate that will do the decompression work. That means that if the trimmer doesn‚Äôt see any code accessing the <code>AutomaticDecompression</code> setter such that the setter can be trimmed away, then all of the <code>DecompressionHandler</code> and its reliance on <code>DeflateStream</code> and <code>BrotliStream</code> can also be trimmed away. Since it‚Äôs a little confusing to read, here‚Äôs a representation of it:</p><pre><code class="language-C#">private DecompressionMethods _automaticDecompression;
private Func&lt;Stream, Stream&gt;? _getStream;

public DecompressionMethods AutomaticDecompression
{
    get =&gt; _automaticDecompression;
    set
    {
        _automaticDecompression = value;
        _getStream ??= CreateDecompressionStream;
    }
}

public Stream GetStreamAsync()
{
    Stream response = ...;
    return _getStream is not null ? _getStream(response) : response;
}

private static Stream CreateDecompressionStream(Stream stream) =&gt;
    UseGZip   ? new GZipStream(stream, CompressionMode.Decompress) :
    UseZLib   ? new ZLibStream(stream, CompressionMode.Decompress) :
    UseBrotli ? new BrotliStream(stream, CompressionMode.Decompress) :
    stream;
}</code></pre><p>The <code>CreateDecompressionStream</code> method here is the one that references all of the compression-related code, and the only code path that touches it is in the <code>AutomaticDecompression</code> setter. Therefore, if nothing in the app accesses the setter, the setter can be trimmed, which means the <code>CreateDecompressionStream</code> method can also be trimmed, which means if nothing else in the app is using these compression streams, they can also be trimmed.</p></li><li><a href="https://github.com/dotnet/runtime/pull/80884">dotnet/runtime#80884</a> is another example, saving ~90Kb of size when <code>Regex</code> is used by just being a bit more intentional about what types are being used in its implementation (e.g. using a <code>bool[30]</code> instead of a <code>HashSet&lt;UnicodeCategory&gt;</code> to store a bitmap).</li><li>Or particularly interesting, <a href="https://github.com/dotnet/runtime/pull/84169">dotnet/runtime#84169</a>, which adds a new feature switch to <code>System.Xml</code>. Various APIs in <code>System.Xml</code> use <code>Uri</code>, which can trigger use of <code>XmlUrlResolver</code>, which in turn references the networking stack; an app that‚Äôs using XML but not otherwise using networking can end up inadvertently bringing in upwards of 3MB of networking code, just by using an API like <code>XDocument.Load(&quot;filepath.xml&quot;)</code>. Such an app can use the <code>&lt;XmlResolverIsNetworkingEnabledByDefault&gt;</code> MSBuild property added in <a href="https://github.com/dotnet/sdk/pull/34412">dotnet/sdk#34412</a> to enable all of those code paths in XML to be trimmed away.</li><li><code>ActivatorUtilities.CreateFactory</code> in <code>Microsoft.Extensions.DependencyInjection.Abstractions</code> tries to optimize throughput by spending some time upfront to build a factory that‚Äôs then very efficient at creating things. Its main strategy for doing so involved using <code>System.Linq.Expressions</code> as a simpler API for using reflection emit, building up custom IL for the exact thing being constructed. When you have a JIT, that can work very well. But when dynamic code isn‚Äôt supported, <code>System.Linq.Expressions</code> can‚Äôt use reflection emit and instead falls back to using an interpreter. That makes such an ‚Äúoptimization‚Äù in <code>CreateFactory</code> actually a deoptimization, plus it brings with it the size impact of <code>System.Linq.Expression.dll</code>. <a href="https://github.com/dotnet/runtime/pull/81262">dotnet/runtime#81262</a> adds a reflection-based alternative for when <code>!RuntimeFeature.IsDynamicCodeSupported</code>, resulting in faster code and allowing the <code>System.Linq.Expression</code> usage to be trimmed away.</li></ul><p>Of course, while size was a large focus for .NET 8, there are a multitude of other ways in which performance with Native AOT has improved. For example, <a href="https://github.com/dotnet/runtime/pull/79709">dotnet/runtime#79709</a> and <a href="https://github.com/dotnet/runtime/pull/80969">dotnet/runtime#80969</a> avoid helper calls as part of reading static fields. BenchmarkDotNet works with Native AOT as well, so we can run the following benchmark to compare; instead of using <code>--runtimes net7.0 net8.0</code>, we just use <code>--runtimes nativeaot7.0 nativeaot8.0</code> (BenchmarkDotNet also currently doesn‚Äôt support the <code>[DisassemblyDiagnoser]</code> with Native AOT):</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes nativeaot7.0 nativeaot8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly int s_configValue = 42;

    [Benchmark]
    public int GetConfigValue() =&gt; s_configValue;
}</code></pre><p>For that, BenchmarkDotNet outputs:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>GetConfigValue</td><td>NativeAOT 7.0</td><td style="text-align: right">1.1759 ns</td><td style="text-align: right">1.000</td></tr><tr><td>GetConfigValue</td><td>NativeAOT 8.0</td><td style="text-align: right">0.0000 ns</td><td style="text-align: right">0.000</td></tr></tbody></table><p>including:</p><pre><code class="language-text">// * Warnings *
ZeroMeasurement
  Tests.GetConfigValue: Runtime=NativeAOT 8.0, Toolchain=Latest ILCompiler -&gt; The method duration is indistinguishable from the empty method duration</code></pre><p>(When looking at the output of optimizations, that warning always brings a smile to my face.)</p><p><a href="https://github.com/dotnet/runtime/pull/83054">dotnet/runtime#83054</a> is another good example. It improves upon <code>EqualityComparer&lt;T&gt;</code> support in Native AOT by ensuring that the comparer can be stored in a <code>static readonly</code> to enable better constant folding in consumers.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes nativeaot7.0 nativeaot8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly int[] _array = Enumerable.Range(0, 1000).ToArray();

    [Benchmark]
    public int FindIndex() =&gt; FindIndex(_array, 999);

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static int FindIndex&lt;T&gt;(T[] array, T value)
    {
        for (int i = 0; i &lt; array.Length; i++)
            if (EqualityComparer&lt;T&gt;.Default.Equals(array[i], value))
                return i;

        return -1;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>FindIndex</td><td>NativeAOT 7.0</td><td style="text-align: right">876.2 ns</td><td style="text-align: right">1.00</td></tr><tr><td>FindIndex</td><td>NativeAOT 8.0</td><td style="text-align: right">367.8 ns</td><td style="text-align: right">0.42</td></tr></tbody></table><p>As another example, <a href="https://github.com/dotnet/runtime/pull/83911">dotnet/runtime#83911</a> avoids some overhead related to static class initialization. As we discussed in the JIT section, the JIT is able to rely on tiering to know that a static field accessed by a method must have already been initialized if the method is being promoted from tier 0 to tier 1, but tiering doesn‚Äôt exist in the Native AOT world, so this PR adds a fast-path check to help avoid most of the costs.</p><p>Other fundamental support has also improved. <a href="https://github.com/dotnet/runtime/pull/79519">dotnet/runtime#79519</a>, for example, changes how locks are implemented for Native AOT, employing a hybrid approach that starts with a lightweight spinlock and upgrades to using the <code>System.Threading.Lock</code> type (which is currently internal to Native AOT but likely to ship publicly in .NET 9).</p><h2 id="vm">VM</h2><p>The VM is, loosely speaking, the part of the runtime that‚Äôs not the JIT or the GC. It‚Äôs what handles things like assembly and type loading. While there were a multitude of improvements throughout, I‚Äôll call out three notable improvements.</p><p>First, <a href="https://github.com/dotnet/runtime/pull/79021">dotnet/runtime#79021</a> optimized the operation of mapping an instruction pointer to a <code>MethodDesc</code> (a data structure that represents a method, with various pieces of information about it, like its signature), which happens in particular any time stack walking is performed (e.g. exception handling, <code>Environment.Stacktrace</code>, etc.) and as part of some delegate creations. The change not only makes this conversion faster but also mostly lock-free, which means on a benchmark like the following, there‚Äôs a significant improvement for sequential use but an even larger one for multi-threaded use:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    [Benchmark]
    public void InSerial()
    {
        for (int i = 0; i &lt; 10_000; i++)
        {
            CreateDelegate&lt;string&gt;();
        }
    }

    [Benchmark]
    public void InParallel()
    {
        Parallel.For(0, 10_000, i =&gt;
        {
            CreateDelegate&lt;string&gt;();
        });
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Action&lt;T&gt; CreateDelegate&lt;T&gt;() =&gt; new Action&lt;T&gt;(GenericMethod);

    private static void GenericMethod&lt;T&gt;(T t) { }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>InSerial</td><td>.NET 7.0</td><td style="text-align: right">1,868.4 us</td><td style="text-align: right">1.00</td></tr><tr><td>InSerial</td><td>.NET 8.0</td><td style="text-align: right">706.5 us</td><td style="text-align: right">0.38</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>InParallel</td><td>.NET 7.0</td><td style="text-align: right">1,247.3 us</td><td style="text-align: right">1.00</td></tr><tr><td>InParallel</td><td>.NET 8.0</td><td style="text-align: right">222.9 us</td><td style="text-align: right">0.18</td></tr></tbody></table><p>Second, <a href="https://github.com/dotnet/runtime/pull/83632">dotnet/runtime#83632</a> improves the performance of the <code>ExecutableAllocator</code>. This allocator is responsible for allocation related to all executable memory in the runtime, e.g. the JIT uses it to get memory into which to write the generated code that will then need to be executed. When memory is mapped, it has permissions associated with it for what can be done with that memory, e.g. can it be read and written, can it be executed, etc. The allocator maintains a cache, and this PR improved the performance of the allocator by reducing the number of cache misses incurred and reducing the cost of those cache misses when they do occur.</p><p>Third, <a href="https://github.com/dotnet/runtime/pull/85743">dotnet/runtime#85743</a> makes a variety of changes focused on significantly reducing startup time. This includes reducing the amount of time spent on validation of types in R2R images, making lookups for generic parameters and nested types in R2R images much faster due to dedicated metadata in the R2R image, converting an <code>O(n^2)</code> lookup into an <code>O(1)</code> lookup by storing an additional index in a method description, and ensuring that vtable chunks are always shared.</p><h2 id="gc">GC</h2><p>At the beginning of this post, I suggested that <code>&lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;</code> be added to the csproj used for running the benchmarks in this post. That setting configures the GC to run in ‚Äúserver‚Äù mode, as opposed to ‚Äúworkstation‚Äù mode. The workstation mode was designed for use with client applications and is less resource intensive, preferring to use less memory but at the possible expense of throughput and scalability if the system is placed under heavier load. In contrast, the server mode was designed for larger-scale services. It is much more resource hungry, with a dedicated heap by default per logical core in the machine, and a dedicated thread per heap for servicing that heap, but it is also significantly more scalable. This tradeoff often leads to complication, as while applications might demand the scalability of the server GC, they may also want memory consumption closer to that of workstation, at least at times when demand is lower and the service needn‚Äôt have so many heaps.</p><p>In .NET 8, the server GC now has support for a dynamic heap count, thanks to <a href="https://github.com/dotnet/runtime/pull/86245">dotnet/runtime#86245</a>,
<a href="https://github.com/dotnet/runtime/pull/87618">dotnet/runtime#87618</a>, and <a href="https://github.com/dotnet/runtime/pull/87619">dotnet/runtime#87619</a>, which add a feature dubbed ‚ÄúDynamic Adaptation To Application Sizes‚Äù, or DATAS. It‚Äôs off-by-default in .NET 8 in general (though on-by-default when publishing for Native AOT), but it can be enabled trivially, either by setting the <code>DOTNET_GCDynamicAdaptationMode</code> environment variable to <code>1</code>, or via the <code>&lt;GarbageCollectionAdaptationMode&gt;1&lt;/GarbageCollectionAdaptationMode&gt;</code> MSBuild property. The employed algorithm is able to increase and decrease the heap count over time, trying to maximize its view of throughput, and maintaining a balance between that and overall memory footprint.</p><p>Here‚Äôs a simple example. I create a console app with <code>&lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;</code> in the .csproj and the following code in Program.cs, which just spawns a bunch of threads that continually allocate, and then repeatedly prints out the working set:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0

using System.Diagnostics;

for (int i = 0; i &lt; 32; i++)
{
    new Thread(() =&gt;
    {
        while (true) Array.ForEach(new byte[1], b =&gt; { });
    }).Start();
}

using Process process = Process.GetCurrentProcess();
while (true)
{
    process.Refresh();
    Console.WriteLine($&quot;{process.WorkingSet64:N0}&quot;);
    Thread.Sleep(1000);
}</code></pre><p>When I run that, I consistently see output like:</p><pre><code class="language-text">154,226,688
154,226,688
154,275,840
154,275,840
154,816,512
154,816,512
154,816,512
154,824,704
154,824,704
154,824,704</code></pre><p>When I then add <code>&lt;GarbageCollectionAdaptationMode&gt;1&lt;/GarbageCollectionAdaptationMode&gt;</code> to the .csproj, the working set drops significantly:</p><pre><code class="language-text">71,430,144
72,187,904
72,196,096
72,196,096
72,245,248
72,245,248
72,245,248
72,245,248
72,245,248
72,253,440</code></pre><p>For a more detailed examination of the feature and plans for it, see <a href="https://maoni0.medium.com/dynamically-adapting-to-application-sizes-2d72fcb6f1ea">Dynamically Adapting To Application Sizes</a>.</p><h2 id="mono">Mono</h2><p>Thus far I‚Äôve referred to ‚Äúthe runtime‚Äù, ‚Äúthe JIT‚Äù, ‚Äúthe GC‚Äù, and so on. That‚Äôs all in the context of the ‚ÄúCoreCLR‚Äù runtime, which is the primary runtime used for console applications, ASP.NET applications, services, desktop applications, and the like. For mobile and browser .NET applications, however, the primary runtime used is the ‚ÄúMono‚Äù runtime. And it also has seen some huge improvements in .NET 8, improvements that accrue to scenarios like Blazor WebAssembly apps.</p><p>Just as how with CoreCLR there‚Äôs both the ability to JIT and AOT, there are multiple ways in which code can be shipped for Mono. Mono includes an AOT compiler; for WASM in particular, the AOT compiler enables all of the IL to be compiled to WASM, which is then shipped down to the browser. As with CoreCLR, however, AOT is opt-in. The default experience for WASM is to use an interpreter: the IL is shipped down to the browser, and the interpreter (which itself is compiled to WASM) then interprets the IL. Of course, interpretation has performance implications, and so .NET 7 augmented the interpreter with a tiering scheme similar in concept to the tiering employed by the CoreCLR JIT. The interpreter has its own representation of the code to be interpreted, and the first few times a method is invoked, it just interprets that byte code with little effort put into optimizing it. Then after enough invocations, the interpreter will take some time to optimize that internal representation so as to speed up subsequent interpretations. Even with that, however, it‚Äôs still interpreting: it‚Äôs still an interpreter implemented in WASM reading instructions for what to do and doing them. One of the most notable improvements to Mono in .NET 8 expands on this tiering by introducing a partial JIT into the interpreter. <a href="https://github.com/dotnet/runtime/pull/76477">dotnet/runtime#76477</a> provided the initial code for this ‚Äújiterpreter,‚Äù as some folks refer to it. As part of the interpreter, this JIT is able to participate in the same data structures used by the interpreter and process the same byte code, and works by replacing sequences of that byte code with on-the-fly generated WASM. That could be a whole method, it could just be a hot loop within a method, or it could be just a few instructions. This provides significant flexibility, including a very progressive on-ramp where optimizations can be added incrementally, shifting more and more logic from interpretation to jitted WASM. Dozens of PRs went into making the jiterpreter a reality for .NET 8, such as <a href="https://github.com/dotnet/runtime/pull/82773">dotnet/runtime#82773</a> that added basic SIMD support, <a href="https://github.com/dotnet/runtime/pull/82756">dotnet/runtime#82756</a> that added basic loop support, and <a href="https://github.com/dotnet/runtime/pull/83247">dotnet/runtime#83247</a> that added a control-flow optimization pass.</p><p>Let‚Äôs see this in action. I created a new .NET 7 Blazor WebAssembly project, added a NuGet reference to the <code>System.IO.Hashing</code> project, and replaced the contents of <code>Counter.razor</code> with the following:</p><pre><code class="language-C#">@page &quot;/counter&quot;
@using System.Diagnostics;
@using System.IO.Hashing;
@using System.Text;
@using System.Threading.Tasks;

&lt;h1&gt;.NET 7&lt;/h1&gt;

&lt;p role=&quot;status&quot;&gt;Current time: @_time&lt;/p&gt;

&lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;Hash&quot;&gt;Click me&lt;/button&gt;

@code {
    private TimeSpan _time;

    private void Hash()
    {
        var sw = Stopwatch.StartNew();
        for (int i = 0; i &lt; 50_000; i++) XxHash64.HashToUInt64(_data);
        _time = sw.Elapsed;
    }

    private byte[] _data =
        @&quot;Shall I compare thee to a summer&#39;s day?
          Thou art more lovely and more temperate:
          Rough winds do shake the darling buds of May,
          And summer&#39;s lease hath all too short a date;
          Sometime too hot the eye of heaven shines,
          And often is his gold complexion dimm&#39;d;
          And every fair from fair sometime declines,
          By chance or nature&#39;s changing course untrimm&#39;d;
          But thy eternal summer shall not fade,
          Nor lose possession of that fair thou ow&#39;st;
          Nor shall death brag thou wander&#39;st in his shade,
          When in eternal lines to time thou grow&#39;st:
          So long as men can breathe or eyes can see,
          So long lives this, and this gives life to thee.&quot;u8.ToArray();
}</code></pre><p>Then I did the exact same thing, but for .NET 8, built both in Release, and ran them both. When the resulting page opened for each, I clicked the ‚ÄúClick me‚Äù button (a few times, but it didn‚Äôt change the results).</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/Net7vs8Interpreter.png" alt="Interpreted WASM on .NET 7 vs .NET 8" /></p><p>The timing measurements for how long the operation took in .NET 7 compared to .NET 8 speak for themselves.</p><p>Beyond the jiterpreter, the interpreter itself saw a multitude of improvements, for example:</p><ul><li><a href="https://github.com/dotnet/runtime/pull/79165">dotnet/runtime#79165</a> added special handling of the <code>stobj</code> IL instruction for when the value type doesn‚Äôt contain any references, and thus doesn‚Äôt need to interact with the GC.</li><li><a href="https://github.com/dotnet/runtime/pull/80046">dotnet/runtime#80046</a> special-cased a compare followed by <code>brtrue</code>/<code>brfalse</code>, creating a single interpreter opcode for the very common pattern.</li><li><a href="https://github.com/dotnet/runtime/pull/79392">dotnet/runtime#79392</a> added an intrinsic to the interpreter for string creation.</li><li><a href="https://github.com/dotnet/runtime/pull/78840">dotnet/runtime#78840</a> added a cache to the Mono runtime (including for but not limited to the interpreter) for various pieces of information about types, like <code>IsValueType</code>, <code>IsGenericTypeDefinition</code>, and <code>IsDelegate</code>.</li><li><a href="https://github.com/dotnet/runtime/pull/81782">dotnet/runtime#81782</a> added intrinsics for some of the most common operations on <code>Vector128</code>, and <a href="https://github.com/dotnet/runtime/pull/86859">dotnet/runtime#86859</a> augmented this to use those same opcodes for <code>Vector&lt;T&gt;</code>.</li><li><a href="https://github.com/dotnet/runtime/pull/83498">dotnet/runtime#83498</a> special-cased division by powers of 2 to instead employ shifts.</li><li><a href="https://github.com/dotnet/runtime/pull/83490">dotnet/runtime#83490</a> tweaked the inlining size limit to ensure that key methods could be inlined, like <code>List&lt;T&gt;</code>‚Äòs indexer.</li><li><a href="https://github.com/dotnet/runtime/pull/85528">dotnet/runtime#85528</a> added devirtualization support in situations where enough type information is available to enable doing so.</li></ul><p>I‚Äôve already alluded several times to vectorization in Mono, but in its own right this has been a big area of focus for Mono in .NET 8, across all backends. As of <a href="https://github.com/dotnet/runtime/pull/86546">dotnet/runtime#86546</a>, which completed adding <code>Vector128&lt;T&gt;</code> support for Mono‚Äôs AMD64 JIT backend, <code>Vector128&lt;T&gt;</code> is now supported across all Mono backends. Mono‚Äôs WASM backends not only support <code>Vector128&lt;T&gt;</code>, .NET 8 includes the new <code>System.Runtime.Intrinsics.Wasm.PackedSimd</code> type, which is specific to WASM and exposes hundreds of overloads that map down to WASM SIMD operations. The basis for this type was introduced in <a href="https://github.com/dotnet/runtime/pull/73289">dotnet/runtime#73289</a>, where the initial SIMD support was added as internal. <a href="https://github.com/dotnet/runtime/pull/76539">dotnet/runtime#76539</a> continued the effort by adding more functionality and also making the type public, as it now is in .NET 8. Over a dozen PRs continued to build it out, such as <a href="https://github.com/dotnet/runtime/pull/80145">dotnet/runtime#80145</a> that added <code>ConditionalSelect</code> intrinsics, <a href="https://github.com/dotnet/runtime/pull/87052">dotnet/runtime#87052</a> and <a href="https://github.com/dotnet/runtime/pull/87828">dotnet/runtime#87828</a> that added load and store intrinsics, <a href="https://github.com/dotnet/runtime/pull/85705">dotnet/runtime#85705</a> that added floating-point support, and <a href="https://github.com/dotnet/runtime/pull/88595">dotnet/runtime#88595</a>, which overhauled the surface area based on learnings since its initial design.</p><p>Another effort in .NET 8, related to app size, has been around reducing reliance on ICU‚Äôs data files (ICU is the globalization library employed by .NET and many other systems). Instead, the goal is to rely on the target platform‚Äôs native APIs wherever possible (for WASM, APIs provided by the browser). This effort is referred to as ‚Äúhybrid globalization,‚Äù because the dependence on ICU‚Äôs data files still remains, it‚Äôs just lessened, and it comes with behavioral changes, so it‚Äôs opt-in for situations where someone really wants the smaller size and is willing to deal with the behavioral accommodations. A multitude of PRs have also gone into making this a reality for .NET 8, such as <a href="https://github.com/dotnet/runtime/pull/81470">dotnet/runtime#81470</a>, <a href="https://github.com/dotnet/runtime/pull/84019">dotnet/runtime#84019</a>, and <a href="https://github.com/dotnet/runtime/pull/84249">dotnet/runtime#84249</a>. To enable the feature, you can add <code>&lt;HybridGlobalization&gt;true&lt;/HybridGlobalization&gt;</code> to your .csproj, and for more information, there‚Äôs a <a href="https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-hybrid-mode.md">good design document</a> that goes into much more depth.</p><h2 id="threading">Threading</h2><p>Recent releases of .NET saw huge improvements to the area of threading, parallelism, concurrency, and asynchrony, such as a complete rewrite of the <code>ThreadPool</code> (in .NET 6 and .NET 7), a complete rewrite of the async method infrastructure (in .NET Core 2.1), a complete rewrite of <code>ConcurrentQueue&lt;T&gt;</code> (in .NET Core 2.0), and so on. This release doesn‚Äôt include such massive overhauls, but it does include some thoughtful and impactful improvements.</p><h3 id="threadstatic">ThreadStatic</h3><p>The .NET runtime makes it easy to associate data with a thread, often referred to as thread-local storage (TLS). The most common way to achieve this is by annotating a static field with the <code>[ThreadStatic]</code> attribute (another for more advanced uses is via the <code>ThreadLocal&lt;T&gt;</code> type), which causes the runtime to replicate the storage for that field to be per thread rather than global for the process.</p><pre><code class="language-C#">private static int s_onePerProcess;

[ThreadStatic]
private static int t_onePerThread;</code></pre><p>Historically, accessing such a <code>[ThreadStatic]</code> field has required a non-inlined JIT helper call (e.g. <code>CORINFO_HELP_GETSHARED_NONGCTHREADSTATIC_BASE_NOCTOR</code>), but now with <a href="https://github.com/dotnet/runtime/pull/82973">dotnet/runtime#82973</a> and <a href="https://github.com/dotnet/runtime/pull/85619">dotnet/runtime#85619</a>, the common and fast path from that helper can be inlined into the caller. We can see this with a simple benchmark that just increments an <code>int</code> stored in a <code>[ThreadStatic]</code>.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0
// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes nativeaot7.0 nativeaot8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public partial class Tests
{
    [ThreadStatic]
    private static int t_value;

    [Benchmark]
    public int Increment() =&gt; ++t_value;
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Increment</td><td>.NET 7.0</td><td style="text-align: right">8.492 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Increment</td><td>.NET 8.0</td><td style="text-align: right">1.453 ns</td><td style="text-align: right">0.17</td></tr></tbody></table><p><code>[ThreadStatic]</code> was similarly optimized for Native AOT, via both <a href="https://github.com/dotnet/runtime/pull/84566">dotnet/runtime#84566</a> and <a href="https://github.com/dotnet/runtime/pull/87148">dotnet/runtime#87148</a>:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Increment</td><td>NativeAOT 7.0</td><td style="text-align: right">2.305 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Increment</td><td>NativeAOT 8.0</td><td style="text-align: right">1.325 ns</td><td style="text-align: right">0.57</td></tr></tbody></table><h3 id="threadpool">ThreadPool</h3><p>Let‚Äôs try an experiment. Create a new console app, and add <code>&lt;PublishAot&gt;true&lt;/PublishAot&gt;</code> to the .csproj. Then make the entirety of the program this:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0

Task.Run(() =&gt; Console.WriteLine(Environment.StackTrace)).Wait();</code></pre><p>The idea is to see the stack trace of a work item running on a <code>ThreadPool</code> thread. Now run it, and you should see something like this:</p><pre><code class="language-text">   at System.Environment.get_StackTrace()
   at Program.&lt;&gt;c.&lt;&lt;Main&gt;$&gt;b__0_0()
   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot, Thread threadPoolThread)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()</code></pre><p>The important piece here is the bottom line: we see we‚Äôre being called from the <code>PortableThreadPool</code>, which is the managed thread pool implementation that‚Äôs been used across operating systems since .NET 6. Now, instead of running directly, let‚Äôs publish for Native AOT and run the resulting app (for the specific thing we‚Äôre looking for, this part should be done on Windows).</p><pre><code class="language-sh">dotnet publish -c Release -r win-x64
D:\examples\tmpapp\bin\Release\net8.0\win-x64\publish\tmpapp.exe</code></pre><p>Now, we see this:</p><pre><code class="language-text">   at System.Environment.get_StackTrace() + 0x21
   at Program.&lt;&gt;c.&lt;&lt;Main&gt;$&gt;b__0_0() + 0x9
   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread, ExecutionContext, ContextCallback, Object) + 0x3d
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp;, Thread) + 0xcc
   at System.Threading.ThreadPoolWorkQueue.Dispatch() + 0x289
   at System.Threading.WindowsThreadPool.DispatchCallback(IntPtr, IntPtr, IntPtr) + 0x45</code></pre><p>Again, note the last line: ‚ÄúWindowsThreadPool.‚Äù Applications published with Native AOT <em>on Windows</em> have historically used a <code>ThreadPool</code> implementation that wraps the <a href="https://learn.microsoft.com/windows/win32/procthread/using-the-thread-pool-functions">Windows thread pool</a>. The work item queues and dispatching code is all the same as with the portable pool, but the thread management itself is delegated to the Windows pool. Now in .NET 8 with <a href="https://github.com/dotnet/runtime/pull/85373">dotnet/runtime#85373</a>, projects <em>on Windows</em> have the option of using either pool; Native AOT apps can opt to instead use the portable pool, and other apps can opt to instead use the Windows pool. Opting in or out is easy: in a <code>&lt;PropertyGroup/&gt;</code> in the .csproj, add <code>&lt;UseWindowsThreadPool&gt;false&lt;/UseWindowsThreadPool&gt;</code> to opt-out in a Native AOT app, and conversely use <code>true</code> in other apps to opt-in. When using this MSBuild switch, in a Native AOT app, whichever pool isn‚Äôt being used can automatically be trimmed away. For experimentation, the <code>DOTNET_ThreadPool_UseWindowsThreadPool</code> environment variable can also be set to <code>0</code> or <code>1</code> to explicitly opt out or in, respectively.</p><p>There‚Äôs currently no hard-and-fast rule about why one pool might be better; the option has been added to allow developers to experiment. We‚Äôve seen with the Windows pool that I/O doesn‚Äôt scale as well on larger machines as it does with the portable pool. However, if the Windows thread pool is already being used heavily elsewhere in the application, consolidating into the same pool can reduce oversubscription. Further, if thread pool threads get blocked very frequently, the Windows thread pool has more information about that blocking and can potentially handle those scenarios more efficiently. We can see this with a simple example. Compile this code:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0

using System.Diagnostics;

var sw = Stopwatch.StartNew();

var barrier = new Barrier(Environment.ProcessorCount * 2 + 1);
for (int i = 0; i &lt; barrier.ParticipantCount; i++)
{
    ThreadPool.QueueUserWorkItem(id =&gt;
    {
        Console.WriteLine($&quot;{sw.Elapsed}: {id}&quot;);
        barrier.SignalAndWait();
    }, i);
}

barrier.SignalAndWait();
Console.WriteLine($&quot;Done: {sw.Elapsed}&quot;);</code></pre><p>This is a dastardly repro that creates a bunch of work items, all of which block until all of the work items have been processed: basically it takes every thread the thread pool gives it and never gives it back (until the program exits). When I run this on my machine where <code>Environment.ProcessorCount</code> is 12, I get output like this:</p><pre><code class="language-text">00:00:00.0038906: 0
00:00:00.0038911: 1
00:00:00.0042401: 4
00:00:00.0054198: 9
00:00:00.0047249: 6
00:00:00.0040724: 3
00:00:00.0044894: 5
00:00:00.0052228: 8
00:00:00.0049638: 7
00:00:00.0056831: 10
00:00:00.0039327: 2
00:00:00.0057127: 11
00:00:01.0265278: 12
00:00:01.5325809: 13
00:00:02.0471848: 14
00:00:02.5628161: 15
00:00:03.5805581: 16
00:00:04.5960218: 17
00:00:05.1087192: 18
00:00:06.1142907: 19
00:00:07.1331915: 20
00:00:07.6467355: 21
00:00:08.1614072: 22
00:00:08.6749720: 23
00:00:08.6763938: 24
Done: 00:00:08.6768608</code></pre><p>The portable pool quickly injects <code>Environment.ProcessorCount</code> threads, but after that it proceeds to only inject an additional thread once or twice a second. Now, set <code>DOTNET_ThreadPool_UseWindowsThreadPool</code> to <code>1</code> and try again:</p><pre><code class="language-text">00:00:00.0034909: 3
00:00:00.0036281: 4
00:00:00.0032404: 0
00:00:00.0032727: 1
00:00:00.0032703: 2
00:00:00.0447256: 5
00:00:00.0449398: 6
00:00:00.0451899: 7
00:00:00.0454245: 8
00:00:00.0456907: 9
00:00:00.0459155: 10
00:00:00.0461399: 11
00:00:00.0463612: 12
00:00:00.0465538: 13
00:00:00.0467497: 14
00:00:00.0469477: 15
00:00:00.0471055: 16
00:00:00.0472961: 17
00:00:00.0474888: 18
00:00:00.0477131: 19
00:00:00.0478795: 20
00:00:00.0480844: 21
00:00:00.0482900: 22
00:00:00.0485110: 23
00:00:00.0486981: 24
Done: 00:00:00.0498603</code></pre><p>Zoom. The Windows pool is <em>much</em> more aggressive about injecting threads here. Whether that‚Äôs good or bad can depend on your scenario. If you‚Äôve found yourself setting a really high minimum thread pool thread count for your application, you might want to give this option a go.</p><h3 id="tasks">Tasks</h3><p>Even with all the improvements to async/await in previous releases, this release sees async methods get cheaper still, both when they complete synchronously and when they complete asynchronously.</p><p>When an async <code>Task</code>/<code>Task&lt;TResult&gt;</code>-returning method completes synchronously, it tries to give back a cached task object rather than creating one a new and incurring the allocation. In the case of <code>Task</code>, that‚Äôs easy, it can simply use <code>Task.CompletedTask</code>. In the case of <code>Task&lt;TResult&gt;</code>, it uses a cache that stores cached tasks for some <code>TResult</code> values. When <code>TResult</code> is <code>Boolean</code>, for example, it can successfully cache a <code>Task&lt;bool&gt;</code> for both <code>true</code> and <code>false</code>, such that it‚Äôll always successfully avoid the allocation. For <code>int</code>, it caches a few tasks for common values (e.g. <code>-1</code> through <code>8</code>). For reference types, it caches a task for <code>null</code>. And for the primitive integer types (<code>sbyte</code>, <code>byte</code>, <code>short</code>, <code>ushort</code>, <code>char</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>nint</code>, and <code>nuint</code>), it caches a task for 0. It used to be that all of this logic was dedicated to async methods, but in .NET 6 that logic moved into <code>Task.FromResult</code>, such that all use of <code>Task.FromResult</code> now benefits from this caching. In .NET 8, thanks to <a href="https://github.com/dotnet/runtime/pull/76349">dotnet/runtime#76349</a> and <a href="https://github.com/dotnet/runtime/pull/87541">dotnet/runtime#87541</a>, the caching is improved further. In particular, the optimization of caching a task for <code>0</code> for the primitive types is extended to be the caching of a task for <code>default(TResult)</code> for any value type <code>TResult</code> that is 1, 2, 4, 8, or 16 bytes. In such cases, we can do an unsafe cast to one of these primitives, and then use that primitive‚Äôs equality to compare against <code>default</code>. If that comparison is true, it means the value is entirely zeroed, which means we can use a cached task for <code>Task&lt;TResult&gt;</code> created from <code>default(TResult)</code>, as that is also entirely zeroed. What if that type has a custom equality comparer? That actually doesn‚Äôt matter, since the original value and the one stored in the cached task have identical bit patterns, which means they‚Äôre indistinguishable. The net effect of this is we can cache tasks for other commonly used types.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark] public async Task&lt;TimeSpan&gt; ZeroTimeSpan() =&gt; TimeSpan.Zero;
    [Benchmark] public async Task&lt;DateTime&gt; MinDateTime() =&gt; DateTime.MinValue;
    [Benchmark] public async Task&lt;Guid&gt; EmptyGuid() =&gt; Guid.Empty;
    [Benchmark] public async Task&lt;DayOfWeek&gt; Sunday() =&gt; DayOfWeek.Sunday;
    [Benchmark] public async Task&lt;decimal&gt; ZeroDecimal() =&gt; 0m;
    [Benchmark] public async Task&lt;double&gt; ZeroDouble() =&gt; 0;
    [Benchmark] public async Task&lt;float&gt; ZeroFloat() =&gt; 0;
    [Benchmark] public async Task&lt;Half&gt; ZeroHalf() =&gt; (Half)0f;
    [Benchmark] public async Task&lt;(int, int)&gt; ZeroZeroValueTuple() =&gt; (0, 0);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>ZeroTimeSpan</td><td>.NET 7.0</td><td style="text-align: right">31.327 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">72 B</td><td style="text-align: right">1.00</td></tr><tr><td>ZeroTimeSpan</td><td>.NET 8.0</td><td style="text-align: right">8.851 ns</td><td style="text-align: right">0.28</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>MinDateTime</td><td>.NET 7.0</td><td style="text-align: right">31.457 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">72 B</td><td style="text-align: right">1.00</td></tr><tr><td>MinDateTime</td><td>.NET 8.0</td><td style="text-align: right">8.277 ns</td><td style="text-align: right">0.26</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>EmptyGuid</td><td>.NET 7.0</td><td style="text-align: right">32.233 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">80 B</td><td style="text-align: right">1.00</td></tr><tr><td>EmptyGuid</td><td>.NET 8.0</td><td style="text-align: right">9.013 ns</td><td style="text-align: right">0.28</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Sunday</td><td>.NET 7.0</td><td style="text-align: right">30.907 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">72 B</td><td style="text-align: right">1.00</td></tr><tr><td>Sunday</td><td>.NET 8.0</td><td style="text-align: right">8.235 ns</td><td style="text-align: right">0.27</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>ZeroDecimal</td><td>.NET 7.0</td><td style="text-align: right">33.109 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">80 B</td><td style="text-align: right">1.00</td></tr><tr><td>ZeroDecimal</td><td>.NET 8.0</td><td style="text-align: right">13.110 ns</td><td style="text-align: right">0.40</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>ZeroDouble</td><td>.NET 7.0</td><td style="text-align: right">30.863 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">72 B</td><td style="text-align: right">1.00</td></tr><tr><td>ZeroDouble</td><td>.NET 8.0</td><td style="text-align: right">8.568 ns</td><td style="text-align: right">0.28</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>ZeroFloat</td><td>.NET 7.0</td><td style="text-align: right">31.025 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">72 B</td><td style="text-align: right">1.00</td></tr><tr><td>ZeroFloat</td><td>.NET 8.0</td><td style="text-align: right">8.531 ns</td><td style="text-align: right">0.28</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>ZeroHalf</td><td>.NET 7.0</td><td style="text-align: right">33.906 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">72 B</td><td style="text-align: right">1.00</td></tr><tr><td>ZeroHalf</td><td>.NET 8.0</td><td style="text-align: right">9.008 ns</td><td style="text-align: right">0.27</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>ZeroZeroValueTuple</td><td>.NET 7.0</td><td style="text-align: right">33.339 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">72 B</td><td style="text-align: right">1.00</td></tr><tr><td>ZeroZeroValueTuple</td><td>.NET 8.0</td><td style="text-align: right">11.274 ns</td><td style="text-align: right">0.34</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>Those changes helped some async methods to become leaner when they complete synchronously. Other changes have helped practically <em>all</em> async methods to become leaner when they complete asynchronously. When an async method suspends for the first time, assuming it‚Äôs returning <code>Task</code>/<code>Task&lt;TResult&gt;</code>/<code>ValueTask</code>/<code>ValueTask&lt;TResult&gt;</code> and the default async method builders are in use (i.e. they haven‚Äôt been overridden using <code>[AsyncMethodBuilder(...)]</code> on the method in question), a single allocation occurs: the task object to be returned. That task object is actually a type derived from <code>Task</code> (in the implementation today the internal type is called <code>AsyncStateMachineBox&lt;TStateMachine&gt;</code>) and that has on it a strongly-typed field for the state machine struct generated by the C# compiler. In fact, as of .NET 7, it has three additional fields beyond what‚Äôs on the base <code>Task&lt;TResult&gt;</code>:</p><ol><li>One to hold the <code>TStateMachine</code> state machine struct generated by the C# compiler.</li><li>One to cache an <code>Action</code> delegate that points to <code>MoveNext</code>.</li><li>One to store an <code>ExecutionContext</code> to flow to the next <code>MoveNext</code> invocation.</li></ol><p>If we can trim down the fields required, we can make every async method less expensive by allocating smaller instead of larger objects. That‚Äôs exactly what <a href="https://github.com/dotnet/runtime/pull/83696">dotnet/runtime#83696</a> and <a href="https://github.com/dotnet/runtime/pull/83737">dotnet/runtime#83737</a> accomplish, together shaving 16 bytes (in a 64-bit process) off the size of <em>every</em> such async method task. How?</p><p>The C# language allows anything to be awaitable as long as it follows the right pattern, exposing a <code>GetAwaiter()</code> method that returns a type with the right shape. That pattern includes a set of ‚ÄúOnCompleted‚Äù methods that take an <code>Action</code> delegate, enabling the async method builder to provide a continuation to the awaiter, such that when the awaited operation completes, it can invoke the <code>Action</code> to resume the method‚Äôs processing. As such, the <code>AsyncStateMachineBox</code> type has on it a field used to cache an <code>Action</code> delegate that‚Äôs lazily created to point to its <code>MoveNext</code> method; that <code>Action</code> is created during the first suspending await where it‚Äôs needed and can then be used for all subsequent awaits, such that the <code>Action</code> is allocated at most once for the lifetime of an async method, regardless of how many times the invocation suspends. (The delegate is only needed, however, if the state machine awaits something that‚Äôs not a known awaiter; the runtime has fast paths that avoid requiring that <code>Action</code> when awaiting all of the built-in awaiters). Interestingly, though, <code>Task</code> itself has a field for storing a delegate, and that field is only used when the <code>Task</code> is created to invoke a delegate (e.g. <code>Task.Run</code>, <code>ContinueWith</code>, etc.). Since most tasks allocated today come from async methods, that means that the majority of tasks have all had a wasted field. It turns out we can just use that base field on the <code>Task</code> for this cached <code>MoveNext</code><code>Action</code> as well, making the field relevant to almost all tasks, and allowing us to remove the extra <code>Action</code> field on the state machine box.</p><p>There‚Äôs another existing field on the base <code>Task</code> that also goes unused in async methods: the state object field. When you use a method like <code>StartNew</code> or <code>ContinueWith</code> to create a <code>Task</code>, you can provide an <code>object state</code> that‚Äôs then passed to the <code>Task</code>‚Äòs delegate. In an async method, though, the field just sits there, unused, lonely, forgotten, forelorn. Instead of having a separate field for the <code>ExecutionContext</code>, then, we can just store the <code>ExecutionContext</code> in this existing state field (being careful not to allow it to be exposed via the <code>Task</code>‚Äòs <code>AsyncState</code> property that normally exposes the object state).</p><p>We can see the effect of getting rid of those two fields with a simple benchmark like this:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark]
    public async Task YieldOnce() =&gt; await Task.Yield();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>YieldOnce</td><td>.NET 7.0</td><td style="text-align: right">918.6 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">112 B</td><td style="text-align: right">1.00</td></tr><tr><td>YieldOnce</td><td>.NET 8.0</td><td style="text-align: right">865.8 ns</td><td style="text-align: right">0.94</td><td style="text-align: right">96 B</td><td style="text-align: right">0.86</td></tr></tbody></table><p>Note the 16-byte decrease just as we predicted.</p><p>Async method overheads are reduced in other ways, too. <a href="https://github.com/dotnet/runtime/pull/82181">dotnet/runtime#82181</a>, for example, shrinks the size of the <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> type that‚Äôs used as the workhorse for custom <code>IValueTaskSource</code>/<code>IValueTaskSource&lt;TResult&gt;</code> implementations; it takes advantage of the 99.9% case to use a single field for something that previously required two fields. But my favorite addition in this regard is <a href="https://github.com/dotnet/runtime/issues/22144">dotnet/runtime#22144</a>, which adds new <code>ConfigureAwait</code> overloads. Yes, I know <code>ConfigureAwait</code> is a sore subject with some, but these new overloads a) address a really useful scenario that many folks end up writing their own custom awaiters for, b) do it in a way that‚Äôs cheaper than custom solutions can provide, and c) actually help with the <code>ConfigureAwait</code> naming, as it fulfills the original purpose of <code>ConfigureAwait</code> that led us to name it that in the first place. When <code>ConfigureAwait</code> was originally devised, we debated many names, and we settled on ‚ÄúConfigureAwait‚Äù because that‚Äôs what it was doing: it was allowing you to provide arguments that configured how the await behaved. Of course, for the last decade, the only configuration you‚Äôve been able to do is pass a single <code>Boolean</code> to indicate whether to capture the current context / scheduler or not, and that in part has led folks to bemoan the naming as overly verbose for something that‚Äôs a single <code>bool</code>. Now in .NET 8, there are new overloads of <code>ConfigureAwait</code> that take a <code>ConfigureAwaitOptions</code> enum:</p><pre><code class="language-C#">[Flags]
public enum ConfigureAwaitOptions
{
   None = 0,
   ContinueOnCapturedContext = 1,
   SuppressThrowing = 2,
   ForceYielding = 4,
}</code></pre><p><code>ContinueOnCapturedContext</code> you know; that‚Äôs the same as <code>ConfigureAwait(true)</code> today. <code>ForceYielding</code> is something that comes up now and again in various capacities, but essentially you‚Äôre awaiting something and rather than continuing synchronously if the thing you‚Äôre awaiting has already completed by the time you await it, you effectively want the system to pretend it‚Äôs not completed even if it is. Then rather than continuing synchronously, the continuation will always end up running asynchronously from the caller. This can be helpful as an optimization in a variety of ways. Consider this code that was in <code>SocketsHttpHandler</code>‚Äòs HTTP/2 implementation in .NET 7:</p><pre><code class="language-C#">private void DisableHttp2Connection(Http2Connection connection)
{
    _ = Task.Run(async () =&gt; // fire-and-forget
    {
        bool usable = await connection.WaitForAvailableStreamsAsync().ConfigureAwait(false);
        ... // other stuff
    };
}</code></pre><p>With <code>ForceYielding</code> in .NET 8, the code is now:</p><pre><code class="language-C#">private void DisableHttp2Connection(Http2Connection connection)
{
    _ = DisableHttp2ConnectionAsync(connection); // fire-and-forget

    async Task DisableHttp2ConnectionAsync(Http2Connection connection)
    {
        bool usable = await connection.WaitForAvailableStreamsAsync().ConfigureAwait(ConfigureAwaitOptions.ForceYielding);
        .... // other stuff
    }
}</code></pre><p>Rather than have a separate <code>Task.Run</code>, we‚Äôve just piggy-backed on the <code>await</code> for the task returned from <code>WaitForAvailableStreamsAsync</code> (which we know will quickly return the task to us), ensuring that the work that comes after it doesn‚Äôt run synchronously as part of the call to <code>DisableHttp2Connection</code>. Or imagine you had code that was doing:</p><pre><code class="language-C#">return Task.Run(WorkAsync);

static async Task WorkAsync()
{
    while (...) await Something();
}</code></pre><p>This is using <code>Task.Run</code> to queue an async method‚Äôs invocation. That async method results in a Task being allocated, plus the <code>Task.Run</code> results in a <code>Task</code> being allocated, plus a work item needs to be queued to the <code>ThreadPool</code>, so at least three allocations. Now, this same functionality can be written as:</p><pre><code class="language-C#">return WorkAsync();

static async Task WorkAsync()
{
    await Task.CompletedTask.ConfigureAwait(ConfigureAwaitOptions.ForceYielding);
    while (...) await Something();
}</code></pre><p>and rather than three allocations, we end up with just one: for the async <code>Task</code>. That‚Äôs because with all the optimizations introduced in previous releases, the state machine box object is also what will be queued to the thread pool.</p><p>Arguably the most valuable addition to this support, though, is <code>SuppressThrowing</code>. It does what it sounds like: when you <code>await</code> a task that completes in failure or cancellation, such that normally the <code>await</code> would propagate the exception, it won‚Äôt. So, for example, in <code>System.Text.Json</code> where we previously had this code:</p><pre><code class="language-C#">// Exceptions should only be propagated by the resuming converter
try
{
    await state.PendingTask.ConfigureAwait(false);
}
catch { }</code></pre><p>now we have this code:</p><pre><code class="language-C#">// Exceptions should only be propagated by the resuming converter
await state.PendingTask.ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing);</code></pre><p>or in <code>SemaphoreSlim</code> where we had this code:</p><pre><code class="language-C#">await new ConfiguredNoThrowAwaiter&lt;bool&gt;(asyncWaiter.WaitAsync(TimeSpan.FromMilliseconds(millisecondsTimeout), cancellationToken));
if (cancellationToken.IsCancellationRequested)
{
    // If we might be running as part of a cancellation callback, force the completion to be asynchronous.
    await TaskScheduler.Default;
}

private readonly struct ConfiguredNoThrowAwaiter&lt;T&gt; : ICriticalNotifyCompletion, IStateMachineBoxAwareAwaiter
{
    private readonly Task&lt;T&gt; _task;
    public ConfiguredNoThrowAwaiter(Task&lt;T&gt; task) =&gt; _task = task;
    public ConfiguredNoThrowAwaiter&lt;T&gt; GetAwaiter() =&gt; this;
    public bool IsCompleted =&gt; _task.IsCompleted;
    public void GetResult() =&gt; _task.MarkExceptionsAsHandled();
    public void OnCompleted(Action continuation) =&gt; TaskAwaiter.OnCompletedInternal(_task, continuation, continueOnCapturedContext: false, flowExecutionContext: true);
    public void UnsafeOnCompleted(Action continuation) =&gt; TaskAwaiter.OnCompletedInternal(_task, continuation, continueOnCapturedContext: false, flowExecutionContext: false);
    public void AwaitUnsafeOnCompleted(IAsyncStateMachineBox box) =&gt; TaskAwaiter.UnsafeOnCompletedInternal(_task, box, continueOnCapturedContext: false);
}

internal readonly struct TaskSchedulerAwaiter : ICriticalNotifyCompletion
{
    private readonly TaskScheduler _scheduler;
    public TaskSchedulerAwaiter(TaskScheduler scheduler) =&gt; _scheduler = scheduler;
    public bool IsCompleted =&gt; false;
    public void GetResult() { }
    public void OnCompleted(Action continuation) =&gt; Task.Factory.StartNew(continuation, CancellationToken.None, TaskCreationOptions.DenyChildAttach, _scheduler);
    public void UnsafeOnCompleted(Action continuation)
    {
        if (ReferenceEquals(_scheduler, Default))
        {
            ThreadPool.UnsafeQueueUserWorkItem(s =&gt; s(), continuation, preferLocal: true);
        }
        else
        {
            OnCompleted(continuation);
        }
    }
}</code></pre><p>now we just have this:</p><pre><code class="language-C#">await ((Task)asyncWaiter.WaitAsync(TimeSpan.FromMilliseconds(millisecondsTimeout), cancellationToken)).ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing);
if (cancellationToken.IsCancellationRequested)
{
    // If we might be running as part of a cancellation callback, force the completion to be asynchronous.
    await Task.CompletedTask.ConfigureAwait(ConfigureAwaitOptions.ForceYielding);
}</code></pre><p>It is useful to note the <code>(Task)</code> cast that‚Äôs in there. <code>WaitAsync</code> returns a <code>Task&lt;bool&gt;</code>, but that <code>Task&lt;bool&gt;</code> is being cast to the base <code>Task</code> because <code>SuppressThrowing</code> is incompatible with <code>Task&lt;TResult&gt;</code>. That‚Äôs because, without an exception propagating, the await will complete successfully and return a <code>TResult</code>, which may be invalid if the task actually faulted. So if you have a <code>Task&lt;TResult&gt;</code> that you want to await with <code>SuppressThrowing</code>, cast to the base <code>Task</code> and await it, and then you can inspect the <code>Task&lt;TResult&gt;</code> immediately after the await completes. (If you do end up using <code>ConfigureAwaitOptions.SuppressThrowing</code> with a <code>Task&lt;TResult&gt;</code>, the <code>CA2261</code> analyzer introduced in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6669">dotnet/roslyn-analyzers#6669</a> will alert you to it.)</p><p>The above example with <code>SemaphoreSlim</code> is using the new <code>ConfigureAwaitOptions</code> to replace a previous optimization added in .NET 8, as well. <a href="https://github.com/dotnet/runtime/pull/83294">dotnet/runtime#83294</a> added to that <code>ConfiguredNoThrowAwaiter&lt;T&gt;</code> an implementation of the internal <code>IStateMachineBoxAwareAwaiter</code> interface, which is the special sauce that enables the async method builders to backchannel with a known awaiter to avoid the <code>Action</code> delegate allocation. Now that the behaviors this <code>ConfiguredNoThrowAwaiter</code> was providing are built-in, it‚Äôs no longer needed, and the built-in implementation enjoys the same privileges via <code>IStateMachineBoxAwareAwaiter</code>. The net result of these changes for <code>SemaphoreSlim</code> is that it now not only has simpler code, but faster code, too. Here‚Äôs a benchmark showing the decrease in execution time and allocation associated with <code>SemaphoreAsync.WaitAsync</code> calls that need to wait with a <code>CancellationToken</code> and/or timeout:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly CancellationToken _token = new CancellationTokenSource().Token;
    private readonly SemaphoreSlim _sem = new SemaphoreSlim(0);
    private readonly Task[] _tasks = new Task[100];

    [Benchmark]
    public Task WaitAsync()
    {
        for (int i = 0; i &lt; _tasks.Length; i++)
        {
            _tasks[i] = _sem.WaitAsync(_token);
        }
        _sem.Release(_tasks.Length);
        return Task.WhenAll(_tasks);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>WaitAsync</td><td>.NET 7.0</td><td style="text-align: right">85.48 us</td><td style="text-align: right">1.00</td><td style="text-align: right">44.64 KB</td><td style="text-align: right">1.00</td></tr><tr><td>WaitAsync</td><td>.NET 8.0</td><td style="text-align: right">69.37 us</td><td style="text-align: right">0.82</td><td style="text-align: right">36.02 KB</td><td style="text-align: right">0.81</td></tr></tbody></table><p>There have been other improvements on other operations on <code>Task</code> as well. <a href="https://github.com/dotnet/runtime/pull/81065">dotnet/runtime#81065</a> removes a defensive <code>Task[]</code> allocation from <code>Task.WhenAll</code>. It was previously doing a defensive copy such that it could then validate on the copy whether any of the elements were <code>null</code> (a copy because another thread could erroneously and concurrently null out elements); that‚Äôs a large cost to pay for argument validation in the face of multi-threaded misuse. Instead, the method will still validate whether <code>null</code> is in the input, and if a <code>null</code> slips through because the input collection was erroneously mutated concurrently with the synchronous call to <code>WhenAll</code>, it‚Äôll just ignore the <code>null</code> at that point. In making these changes, the PR also special-cased a <code>List&lt;Task&gt;</code> input to avoid making a copy, as <code>List&lt;Task&gt;</code> is also one of the main types we see fed into <code>WhenAll</code> (e.g. someone builds up a list of tasks and then waits for all of them).</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.ObjectModel;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark]
    public void WhenAll_Array()
    {
        AsyncTaskMethodBuilder atmb1 = AsyncTaskMethodBuilder.Create();
        AsyncTaskMethodBuilder atmb2 = AsyncTaskMethodBuilder.Create();
        Task whenAll = Task.WhenAll(atmb1.Task, atmb2.Task);
        atmb1.SetResult();
        atmb2.SetResult();
        whenAll.Wait();
    }

    [Benchmark]
    public void WhenAll_List()
    {
        AsyncTaskMethodBuilder atmb1 = AsyncTaskMethodBuilder.Create();
        AsyncTaskMethodBuilder atmb2 = AsyncTaskMethodBuilder.Create();
        Task whenAll = Task.WhenAll(new List&lt;Task&gt;(2) { atmb1.Task, atmb2.Task });
        atmb1.SetResult();
        atmb2.SetResult();
        whenAll.Wait();
    }

    [Benchmark]
    public void WhenAll_Collection()
    {
        AsyncTaskMethodBuilder atmb1 = AsyncTaskMethodBuilder.Create();
        AsyncTaskMethodBuilder atmb2 = AsyncTaskMethodBuilder.Create();
        Task whenAll = Task.WhenAll(new ReadOnlyCollection&lt;Task&gt;(new[] { atmb1.Task, atmb2.Task }));
        atmb1.SetResult();
        atmb2.SetResult();
        whenAll.Wait();
    }

    [Benchmark]
    public void WhenAll_Enumerable()
    {
        AsyncTaskMethodBuilder atmb1 = AsyncTaskMethodBuilder.Create();
        AsyncTaskMethodBuilder atmb2 = AsyncTaskMethodBuilder.Create();
        var q = new Queue&lt;Task&gt;(2);
        q.Enqueue(atmb1.Task);
        q.Enqueue(atmb2.Task);
        Task whenAll = Task.WhenAll(q);
        atmb1.SetResult();
        atmb2.SetResult();
        whenAll.Wait();
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>WhenAll_Array</td><td>.NET 7.0</td><td style="text-align: right">210.8 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">304 B</td><td style="text-align: right">1.00</td></tr><tr><td>WhenAll_Array</td><td>.NET 8.0</td><td style="text-align: right">160.9 ns</td><td style="text-align: right">0.76</td><td style="text-align: right">264 B</td><td style="text-align: right">0.87</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>WhenAll_List</td><td>.NET 7.0</td><td style="text-align: right">296.4 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">376 B</td><td style="text-align: right">1.00</td></tr><tr><td>WhenAll_List</td><td>.NET 8.0</td><td style="text-align: right">185.5 ns</td><td style="text-align: right">0.63</td><td style="text-align: right">296 B</td><td style="text-align: right">0.79</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>WhenAll_Collection</td><td>.NET 7.0</td><td style="text-align: right">271.3 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">360 B</td><td style="text-align: right">1.00</td></tr><tr><td>WhenAll_Collection</td><td>.NET 8.0</td><td style="text-align: right">199.7 ns</td><td style="text-align: right">0.74</td><td style="text-align: right">328 B</td><td style="text-align: right">0.91</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>WhenAll_Enumerable</td><td>.NET 7.0</td><td style="text-align: right">328.2 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">472 B</td><td style="text-align: right">1.00</td></tr><tr><td>WhenAll_Enumerable</td><td>.NET 8.0</td><td style="text-align: right">230.0 ns</td><td style="text-align: right">0.70</td><td style="text-align: right">432 B</td><td style="text-align: right">0.92</td></tr></tbody></table><p>The generic <code>WhenAny</code> was also improved as part of <a href="https://github.com/dotnet/runtime/pull/88154">dotnet/runtime#88154</a>, which removes a <code>Task</code> allocation from an extra continuation that was an implementation detail. This is one of my favorite kinds of PRs: it not only improved performance, it also resulted in cleaner code, and less code.</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/GitHubPlusMinusIndicatorForWhenAnyChange.png" alt="GitHub plus/minus line count indicator for Task.WhenAny" /></p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark]
    public Task&lt;Task&lt;int&gt;&gt; WhenAnyGeneric_ListNotCompleted()
    {
        AsyncTaskMethodBuilder&lt;int&gt; atmb1 = default;
        AsyncTaskMethodBuilder&lt;int&gt; atmb2 = default;
        AsyncTaskMethodBuilder&lt;int&gt; atmb3 = default;

        Task&lt;Task&lt;int&gt;&gt; wa = Task.WhenAny(new List&lt;Task&lt;int&gt;&gt;() { atmb1.Task, atmb2.Task, atmb3.Task });

        atmb3.SetResult(42);

        return wa;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>WhenAnyGeneric_ListNotCompleted</td><td>.NET 7.0</td><td style="text-align: right">555.0 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">704 B</td><td style="text-align: right">1.00</td></tr><tr><td>WhenAnyGeneric_ListNotCompleted</td><td>.NET 8.0</td><td style="text-align: right">260.3 ns</td><td style="text-align: right">0.47</td><td style="text-align: right">504 B</td><td style="text-align: right">0.72</td></tr></tbody></table><p>One last example related to tasks, though this one is a bit different, as it‚Äôs specifically about improving test performance (and test reliability). Imagine you have a method like this:</p><pre><code class="language-C#">public static async Task LogAfterDelay(Action&lt;string, TimeSpan&gt; log)
{
    long startingTimestamp = Stopwatch.GetTimestamp();
    await Task.Delay(TimeSpan.FromSeconds(30));
    log(&quot;Completed&quot;, Stopwatch.GetElapsedTime(startingTimestamp));
}</code></pre><p>The purpose of this method is to wait for 30 seconds and then log a completion message as well as how much time the method observed to pass. This is obviously a simplification of the kind of functionality you‚Äôd find in real applications, but you can extrapolate from it to code you‚Äôve likely written. How do you test this? Maybe you‚Äôve written a test like this:</p><pre><code class="language-C#">[Fact]
public async Task LogAfterDelay_Success_CompletesAfterThirtySeconds()
{
    TimeSpan ts = default;

    Stopwatch sw = Stopwatch.StartNew();
    await LogAfterDelay((message, time) =&gt; ts = time);
    sw.Stop();

    Assert.InRange(ts, TimeSpan.FromSeconds(30), TimeSpan.MaxValue);
    Assert.InRange(sw.Elapsed, TimeSpan.FromSeconds(30), TimeSpan.MaxValue);
}</code></pre><p>This is validating both that the method included a value of at least 30 seconds in its log and also that at least 30 seconds passed. What‚Äôs the problem? From a performance perspective, the problem is this test had to wait 30 seconds! That‚Äôs a ton of overhead for something which would otherwise complete close to instantaneously. Now imagine the delay was longer, like 10 minutes, or that we had a bunch of tests that all needed to do the same thing. It becomes untenable to test well and thoroughly.</p><p>To address these kinds of situations, many developers have introduced their own abstractions for the flow of time. Now in .NET 8, that‚Äôs no longer needed. As of <a href="https://github.com/dotnet/runtime/pull/83604">dotnet/runtime#83604</a>, the core libraries include <code>System.TimeProvider</code>. This abstract base class abstracts over the flow of time, with members for getting the current UTC time, getting the current local time, getting the current time zone, getting a high-frequency timestamp, and creating a timer (which in turn returns the new <code>System.Threading.ITimer</code> that supports changing the timer‚Äôs tick interval). Then core library members like <code>Task.Delay</code> and <code>CancellationTokenSource</code>‚Äòs constructor have new overloads that accept a <code>TimeProvider</code>, and use it for time-related functionality rather than being hardcoded to <code>DateTime.UtcNow</code>, <code>Stopwatch</code>, or <code>System.Threading.Timer</code>. With that, we can rewrite our previous method:</p><pre><code class="language-C#">public static async Task LogAfterDelay(Action&lt;string, TimeSpan&gt; log, TimeProvider provider)
{
    long startingTimestamp = provider.GetTimestamp();
    await Task.Delay(TimeSpan.FromSeconds(30), provider);
    log(&quot;Completed&quot;, provider.GetElapsedTime(startingTimestamp));
}</code></pre><p>It‚Äôs been augmented to accept a <code>TimeProvider</code> parameter, though in a system that uses a dependency injection (DI) mechanism, it would likely just fetch a <code>TimeProvider</code> singleton from DI. Then instead of using <code>Stopwatch.GetTimestamp</code> or <code>Stopwatch.GetElapsedTime</code>, it uses the corresponding members on the <code>provider</code>, and instead of using the <code>Task.Delay</code> overload that just takes a duration, it uses the overload that also takes a <code>TimeProvider</code>. When used in production, this can be passed <code>TimeProvider.System</code>, which is implemented based on the system clock (exactly what you would get without providing a <code>TimeProvider</code> at all), but in a test, it can be passed a custom instance, one that manually controls the observed flow of time. Exactly such a custom <code>TimeProvider</code> exists in the <a href="https://www.nuget.org/packages/Microsoft.Extensions.TimeProvider.Testing">Microsoft.Extensions.TimeProvider.Testing</a> NuGet package: <code>FakeTimeProvider</code>. Here‚Äôs an example of using it with our <code>LogAfterDelay</code> method:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using Microsoft.Extensions.Time.Testing;
using System.Diagnostics;

Stopwatch sw = Stopwatch.StartNew();

var fake = new FakeTimeProvider();

Task t = LogAfterDelay((message, time) =&gt; Console.WriteLine($&quot;{message}: {time}&quot;), fake);

fake.Advance(TimeSpan.FromSeconds(29));
Console.WriteLine(t.IsCompleted);

fake.Advance(TimeSpan.FromSeconds(1));
Console.WriteLine(t.IsCompleted);

Console.WriteLine($&quot;Actual execution time: {sw.Elapsed}&quot;);

static async Task LogAfterDelay(Action&lt;string, TimeSpan&gt; log, TimeProvider provider)
{
    long startingTimestamp = provider.GetTimestamp();
    await Task.Delay(TimeSpan.FromSeconds(30), provider);
    log(&quot;Completed&quot;, provider.GetElapsedTime(startingTimestamp));
}</code></pre><p>When I run this, it outputs the following:</p><pre><code class="language-text">False
Completed: 00:00:30
True
Actual execution time: 00:00:00.0119943</code></pre><p>In other words, after manually advancing time by 29 seconds, the operation still hadn‚Äôt completed. Then we manually advanced time by one more second, and the operation completed. It reported that 30 seconds passed, but in reality, the whole operation took only 0.01 seconds of actual wall clock time.</p><p>With that, let‚Äôs move up the stack to <code>Parallel</code>‚Ä¶</p><h2 id="parallel">Parallel</h2><p>.NET 6 introduced new async methods onto <code>Parallel</code> in the form of <code>Parallel.ForEachAsync</code>. After its introduction, we started getting requests for an equivalent for <code>for</code> loops, so now in .NET 8, with <a href="https://github.com/dotnet/runtime/pull/84804">dotnet/runtime#84804</a>, the class gains a set of <code>Parallel.ForAsync</code> methods. These were previously achievable by passing in an <code>IEnumerable&lt;T&gt;</code> created from a method like <code>Enumerable.Range</code>, e.g.</p><pre><code class="language-C#">await Parallel.ForEachAsync(Enumerable.Range(0, 1_000), async i =&gt;
{
   ... 
});</code></pre><p>but you can now achieve the same more simply and cheaply with:</p><pre><code class="language-C#">await Parallel.ForAsync(0, 1_000, async i =&gt;
{
   ... 
});</code></pre><p>It ends up being cheaper because you don‚Äôt need to allocate the enumerable/enumerator, and the synchronization involved in multiple workers trying to peel off the next iteration can be done in a much less expensive manner, a single <code>Interlocked</code> rather than using an asynchronous lock like <code>SemaphoreSlim</code>.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark(Baseline = true)]
    public Task ForEachAsync() =&gt; Parallel.ForEachAsync(Enumerable.Range(0, 1_000_000), (i, ct) =&gt; ValueTask.CompletedTask);

    [Benchmark]
    public Task ForAsync() =&gt; Parallel.ForAsync(0, 1_000_000, (i, ct) =&gt; ValueTask.CompletedTask);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>ForEachAsync</td><td style="text-align: right">589.5 ms</td><td style="text-align: right">1.00</td><td style="text-align: right">87925272 B</td><td style="text-align: right">1.000</td></tr><tr><td>ForAsync</td><td style="text-align: right">147.5 ms</td><td style="text-align: right">0.25</td><td style="text-align: right">792 B</td><td style="text-align: right">0.000</td></tr></tbody></table><p>The allocation column here is particularly stark, and also a tad misleading. Why is <code>ForEachAsync</code><em>so</em> much worse here allocation-wise? It‚Äôs because of the synchronization mechanism. There‚Äôs zero work being performed here by the delegate in the test, so all of the time is spent hammering on the source. In the case of <code>Parallel.ForAsync</code>, that‚Äôs a single <code>Interlocked</code> instruction to get the next value. In the case of <code>Parallel.ForEachAsync</code>, it‚Äôs a <code>WaitAsync</code>, and under a lot of contention, many of those <code>WaitAsync</code> calls are going to complete asynchronously, resulting in allocation. In a real workload, where the body delegate is doing real work, synchronously or asynchronously, the impact of that synchronization is much, much less dramatic. Here I‚Äôve changed the calls to just be a simple <code>Task.Delay</code> for 1ms (and also significantly lowered the iteration count):</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark(Baseline = true)]
    public Task ForEachAsync() =&gt; Parallel.ForEachAsync(Enumerable.Range(0, 100), async (i, ct) =&gt; await Task.Delay(1));

    [Benchmark]
    public Task ForAsync() =&gt; Parallel.ForAsync(0, 100, async (i, ct) =&gt; await Task.Delay(1));
}</code></pre><p>and the two methods are the effectively same:</p><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>ForEachAsync</td><td style="text-align: right">89.39 ms</td><td style="text-align: right">1.00</td><td style="text-align: right">27.96 KB</td><td style="text-align: right">1.00</td></tr><tr><td>ForAsync</td><td style="text-align: right">89.44 ms</td><td style="text-align: right">1.00</td><td style="text-align: right">27.84 KB</td><td style="text-align: right">1.00</td></tr></tbody></table><p>Interestingly, this <code>Parallel.ForAsync</code> method is also one of the first public methods in the core libraries to be based on the generic math interfaces introduced in .NET 7:</p><pre><code class="language-C#">public static Task ForAsync&lt;T&gt;(T fromInclusive, T toExclusive, Func&lt;T, CancellationToken, ValueTask&gt; body)
    where T : notnull, IBinaryInteger&lt;T&gt;</code></pre><p>When initially designing the method, we copied the synchronous <code>For</code> counterpart, which has overloads specific to <code>int</code> and overloads specific to <code>long</code>. Now that we have <code>IBinaryInteger&lt;T&gt;</code>, however, we realized we could not only reduce the number of overloads and not only reduce the number of implementations, by using <code>IBinaryInteger&lt;T&gt;</code> we could also open the same method up to other types folks want to use, such as <code>nint</code> or <code>UInt128</code> or <code>BigInteger</code>; they all ‚Äújust work,‚Äù which is pretty cool. (The new <code>TotalOrderIeee754Comparer&lt;T&gt;</code>, added in .NET 8 in <a href="https://github.com/dotnet/runtime/pull/75517">dotnet/runtime#75517</a> by <a href="https://github.com/huoyaoyuan">@huoyaoyuan</a>, is another new public type relying on these interfaces.) Once we did that, in <a href="https://github.com/dotnet/runtime/pull/84853">dotnet/runtime#84853</a> we used a similar technique to deduplicate the <code>Parallel.For</code> implementations, such that both <code>int</code> and <code>long</code> share the same generic implementations internally.</p><h2 id="exceptions">Exceptions</h2><p>In .NET 6, <code>ArgumentNullException</code> gained a <code>ThrowIfNull</code> method, as we dipped our toes into the waters of providing ‚Äúthrow helpers.‚Äù The intent of the method is to concisely express the constraint being verified, letting the system throw a consistent exception for failure to meet the constraint while also optimizing the success and 99.999% case where no exception need be thrown. The method is structured in such a way that the fast path performing the check gets inlined, with as little work as possible on that path, and then everything else is relegated to a method that performs the actual throwing (the JIT won‚Äôt inline that throwing method, as it‚Äôll look at its implementation and see that the method always throws).</p><pre><code class="language-C#">public static void ThrowIfNull(
    [NotNull] object? argument,
    [CallerArgumentExpression(nameof(argument))] string? paramName = null)
{
    if (argument is null)
        Throw(paramName);
}

[DoesNotReturn]
internal static void Throw(string? paramName) =&gt; throw new ArgumentNullException(paramName);</code></pre><p>In .NET 7, <code>ArgumentNullException.ThrowIfNull</code> gained another overload, this time for pointers, and two new methods were introduced: <code>ArgumentException.ThrowIfNullOrEmpty</code> for <code>string</code>s and <code>ObjectDisposedException.ThrowIf</code>.</p><p>Now in .NET 8, a slew of new such helpers have been added. Thanks to <a href="https://github.com/dotnet/runtime/pull/86007">dotnet/runtime#86007</a>, <code>ArgumentException</code> gains <code>ThrowIfNullOrWhiteSpace</code> to complement <code>ThrowIfNullOrEmpty</code>:</p><pre><code class="language-C#">public static void ThrowIfNullOrWhiteSpace([NotNull] string? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null);</code></pre><p>and thanks to <a href="https://github.com/dotnet/runtime/pull/78222">dotnet/runtime#78222</a> from <a href="https://github.com/hrrrrustic">@hrrrrustic</a> and <a href="https://github.com/dotnet/runtime/pull/83853">dotnet/runtime#83853</a>, <code>ArgumentOutOfRangeException</code> gains 9 new methods:</p><pre><code class="language-C#">public static void ThrowIfEqual&lt;T&gt;(T value, T other, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : System.IEquatable&lt;T&gt;?;
public static void ThrowIfNotEqual&lt;T&gt;(T value, T other, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : System.IEquatable&lt;T&gt;?;

public static void ThrowIfLessThan&lt;T&gt;(T value, T other, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : IComparable&lt;T&gt;;
public static void ThrowIfLessThanOrEqual&lt;T&gt;(T value, T other, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : IComparable&lt;T&gt;;

public static void ThrowIfGreaterThan&lt;T&gt;(T value, T other, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : IComparable&lt;T&gt;;
public static void ThrowIfGreaterThanOrEqual&lt;T&gt;(T value, T other, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : IComparable&lt;T&gt;;

public static void ThrowIfNegative&lt;T&gt;(T value, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : INumberBase&lt;T&gt;;
public static void ThrowIfZero&lt;T&gt;(T value, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : INumberBase&lt;T&gt;;
public static void ThrowIfNegativeOrZero&lt;T&gt;(T value, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : INumberBase&lt;T&gt;;</code></pre><p>Those PRs used these new methods in a few places, but then <a href="https://github.com/dotnet/runtime/pull/79460">dotnet/runtime#79460</a>, <a href="https://github.com/dotnet/runtime/pull/80355">dotnet/runtime#80355</a>, <a href="https://github.com/dotnet/runtime/pull/82357">dotnet/runtime#82357</a>, <a href="https://github.com/dotnet/runtime/pull/82533">dotnet/runtime#82533</a>, and <a href="https://github.com/dotnet/runtime/pull/85858">dotnet/runtime#85858</a> rolled out their use more broadly throughout the core libraries. To get a sense for the usefulness of these methods, here are the number of times each of these methods is being called from within the <code>src</code> for the core libraries in <a href="https://github.com/dotnet/runtime">dotnet/runtime</a> as of the time I‚Äôm writing this paragraph:</p><table><thead><tr><th>Method</th><th>Count</th></tr></thead><tbody><tr><td>ANE.ThrowIfNull(object)</td><td>4795</td></tr><tr><td>AOORE.ThrowIfNegative</td><td>873</td></tr><tr><td>AE.ThrowIfNullOrEmpty</td><td>311</td></tr><tr><td>ODE.ThrowIf</td><td>237</td></tr><tr><td>AOORE.ThrowIfGreaterThan</td><td>223</td></tr><tr><td>AOORE.ThrowIfNegativeOrZero</td><td>100</td></tr><tr><td>AOORE.ThrowIfLessThan</td><td>89</td></tr><tr><td>ANE.ThrowIfNull(void*)</td><td>55</td></tr><tr><td>AOORE.ThrowIfGreaterThanOrEqual</td><td>39</td></tr><tr><td>AE.ThrowIfNullOrWhiteSpace</td><td>32</td></tr><tr><td>AOORE.ThrowIfLessThanOrEqual</td><td>20</td></tr><tr><td>AOORE.ThrowIfNotEqual</td><td>13</td></tr><tr><td>AOORE.ThrowIfZero</td><td>5</td></tr><tr><td>AOORE.ThrowIfEqual</td><td>3</td></tr></tbody></table><p>These new methods also do more work in the throwing portion (e.g. formatting the exception message with the invalid arguments), which helps to better exemplify the benfits of moving all of that work out into a separate method. For example, here is the <code>ThrowIfGreaterThan</code> copied straight from <code>System.Private.CoreLib</code>:</p><pre><code class="language-C#">public static void ThrowIfGreaterThan&lt;T&gt;(T value, T other, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : IComparable&lt;T&gt;
{
    if (value.CompareTo(other) &gt; 0)
        ThrowGreater(value, other, paramName);
}

private static void ThrowGreater&lt;T&gt;(T value, T other, string? paramName) =&gt;
    throw new ArgumentOutOfRangeException(paramName, value, SR.Format(SR.ArgumentOutOfRange_Generic_MustBeLessOrEqual, paramName, value, other));</code></pre><p>and here is a benchmark showing what consumption would look like if the <code>throw</code> expression were directly part of <code>ThrowIfGreaterThan</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;value1&quot;, &quot;value2&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    [Benchmark(Baseline = true)]
    [Arguments(1, 2)]
    public void WithOutline(int value1, int value2)
    {
        ArgumentOutOfRangeException.ThrowIfGreaterThan(value1, 100);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(value2, 200);
    }

    [Benchmark]
    [Arguments(1, 2)]
    public void WithInline(int value1, int value2)
    {
        ThrowIfGreaterThan(value1, 100);
        ThrowIfGreaterThan(value2, 200);
    }

    public static void ThrowIfGreaterThan&lt;T&gt;(T value, T other, [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : IComparable&lt;T&gt;
    {
        if (value.CompareTo(other) &gt; 0)
            throw new ArgumentOutOfRangeException(paramName, value, SR.Format(SR.ArgumentOutOfRange_Generic_MustBeLessOrEqual, paramName, value, other));
    }

    internal static class SR
    {
        public static string Format(string format, object arg0, object arg1, object arg2) =&gt; string.Format(format, arg0, arg1, arg2);
        internal static string ArgumentOutOfRange_Generic_MustBeLessOrEqual =&gt; GetResourceString(&quot;ArgumentOutOfRange_Generic_MustBeLessOrEqual&quot;);

        [MethodImpl(MethodImplOptions.NoInlining)]
        static string GetResourceString(string resourceKey) =&gt; &quot;{0} (&#39;{1}&#39;) must be less than or equal to &#39;{2}&#39;.&quot;;
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Code Size</th></tr></thead><tbody><tr><td>WithOutline</td><td style="text-align: right">0.4839 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">118 B</td></tr><tr><td>WithInline</td><td style="text-align: right">2.4976 ns</td><td style="text-align: right">5.16</td><td style="text-align: right">235 B</td></tr></tbody></table><p>The most relevant highlight from the generated assembly is from the <code>WithInline</code> case:</p><pre><code class="language-assembly">; Tests.WithInline(Int32, Int32)
       push      rbx
       sub       rsp,20
       mov       ebx,r8d
       mov       ecx,edx
       mov       edx,64
       mov       r8,1F5815EA8F8
       call      qword ptr [7FF99C03DEA8]; Tests.ThrowIfGreaterThan[[System.Int32, System.Private.CoreLib]](Int32, Int32, System.String)
       mov       ecx,ebx
       mov       edx,0C8
       mov       r8,1F5815EA920
       add       rsp,20
       pop       rbx
       jmp       qword ptr [7FF99C03DEA8]; Tests.ThrowIfGreaterThan[[System.Int32, System.Private.CoreLib]](Int32, Int32, System.String)
; Total bytes of code 59</code></pre><p>Because there‚Äôs more cruft inside the <code>ThrowIfGreaterThan</code> method, the system decides not to inline it, and so we end up with two method invocations that occur even when the value is within range (the first is a <code>call</code>, the second here is a <code>jmp</code>, since there was no follow-up work in this method that would require control flow returning).</p><p>To make it easier to roll out usage of these helpers, <a href="https://github.com/dotnet/roslyn-analyzers/pull/6293">dotnet/roslyn-analyzers#6293</a> added new analyzers to look for argument validation that can be replaced by one of the throw helper methods on <code>ArgumentNullException</code>, <code>ArgumentException</code>, <code>ArgumentOutOfRangeException</code>, or <code>ObjectDisposedException</code>. <a href="https://github.com/dotnet/runtime/pull/80149">dotnet/runtime#80149</a> enables the analyzers for <a href="https://github.com/dotnet/runtime">dotnet/runtime</a> and fixes up many call sites.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1510.png" alt="CA1510, CA1511, CA1512, CA1513" /></p><h2 id="reflection">Reflection</h2><p>There have been a variety of improvements here and there in the reflection stack in .NET 8, mostly around reducing allocation or caching information so that subsequent access is faster. For example, <a href="https://github.com/dotnet/runtime/pull/87902">dotnet/runtime#87902</a> tweaks some code in <code>GetCustomAttributes</code> to avoid allocating an <code>object[1]</code> array in order to set a property on an attribute.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark]
    public object[] GetCustomAttributes() =&gt; typeof(C).GetCustomAttributes(typeof(MyAttribute), inherit: true);

    [My(Value1 = 1, Value2 = 2)]
    class C { }

    [AttributeUsage(AttributeTargets.All)]
    public class MyAttribute : Attribute
    {
        public int Value1 { get; set; }
        public int Value2 { get; set; }
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>GetCustomAttributes</td><td>.NET 7.0</td><td style="text-align: right">1,287.1 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">296 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetCustomAttributes</td><td>.NET 8.0</td><td style="text-align: right">994.0 ns</td><td style="text-align: right">0.77</td><td style="text-align: right">232 B</td><td style="text-align: right">0.78</td></tr></tbody></table><p>Other changes like <a href="https://github.com/dotnet/runtime/pull/76574">dotnet/runtime#76574</a> from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a>, <a href="https://github.com/dotnet/runtime/pull/81059">dotnet/runtime#81059</a> from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a>, and <a href="https://github.com/dotnet/runtime/pull/86657">dotnet/runtime#86657</a> from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a> also removed allocations in the reflection stack, in particular by more liberal use of spans. And <a href="https://github.com/dotnet/runtime/pull/78288">dotnet/runtime#78288</a> from <a href="https://github.com/lateapexearlyspeed">@lateapexearlyspeed</a> improves the handling of generics information on a <code>Type</code>, leading to a boost for various generics-related members, in particular for <code>GetGenericTypeDefinition</code> for which the result is now cached on the <code>Type</code> object.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly Type _type = typeof(List&lt;int&gt;);

    [Benchmark] public Type GetGenericTypeDefinition() =&gt; _type.GetGenericTypeDefinition();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>GetGenericTypeDefinition</td><td>.NET 7.0</td><td style="text-align: right">47.426 ns</td><td style="text-align: right">1.00</td></tr><tr><td>GetGenericTypeDefinition</td><td>.NET 8.0</td><td style="text-align: right">3.289 ns</td><td style="text-align: right">0.07</td></tr></tbody></table><p>However, the largest impact on performance in reflection in .NET 8 comes from <a href="https://github.com/dotnet/runtime/pull/88415">dotnet/runtime#88415</a>. This is a continuation of work done in .NET 7 to improve the performance of <code>MethodBase.Invoke</code>. When you know at compile-time the signature of the target method you want to invoke via reflection, you can achieve the best performance by using <code>CreateDelegate&lt;DelegateType&gt;</code> to get and cache a delegate for the method in question, and then performing all invocations via that delegate. However, if you don‚Äôt know the signature at compile-time, you need to rely on more dynamic means, like <code>MethodBase.Invoke</code>, which historically has been much more costly. Some enterprising developers turned to reflection emit to avoid that overhead by emitting custom invocation stubs at run-time, and that‚Äôs one of the optimization approaches taken under the covers in .NET 7 as well. Now in .NET 8, the code generated for many of these cases has improved; previously the emitter was always generating code that could accommodate <code>ref</code>/<code>out</code> arguments, but many methods don‚Äôt have such arguments, and the generated code can be more efficient when it needn‚Äôt factor those in.</p><pre><code class="language-C#">// If you have .NET 6 installed, you can update the csproj to include a net6.0 in the target frameworks, and then run:
//     dotnet run -c Release -f net6.0 --filter &quot;*&quot; --runtimes net6.0 net7.0 net8.0
// Otherwise, you can run:
//     dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Reflection;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private MethodInfo _method0, _method1, _method2, _method3;
    private readonly object[] _args1 = new object[] { 1 };
    private readonly object[] _args2 = new object[] { 2, 3 };
    private readonly object[] _args3 = new object[] { 4, 5, 6 };

    [GlobalSetup]
    public void Setup()
    {
        _method0 = typeof(Tests).GetMethod(&quot;MyMethod0&quot;, BindingFlags.NonPublic | BindingFlags.Static);
        _method1 = typeof(Tests).GetMethod(&quot;MyMethod1&quot;, BindingFlags.NonPublic | BindingFlags.Static);
        _method2 = typeof(Tests).GetMethod(&quot;MyMethod2&quot;, BindingFlags.NonPublic | BindingFlags.Static);
        _method3 = typeof(Tests).GetMethod(&quot;MyMethod3&quot;, BindingFlags.NonPublic | BindingFlags.Static);
    }

    [Benchmark] public void Method0() =&gt; _method0.Invoke(null, null);
    [Benchmark] public void Method1() =&gt; _method1.Invoke(null, _args1);
    [Benchmark] public void Method2() =&gt; _method2.Invoke(null, _args2);
    [Benchmark] public void Method3() =&gt; _method3.Invoke(null, _args3);

    private static void MyMethod0() { }
    private static void MyMethod1(int arg1) { }
    private static void MyMethod2(int arg1, int arg2) { }
    private static void MyMethod3(int arg1, int arg2, int arg3) { }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Method0</td><td>.NET 6.0</td><td style="text-align: right">91.457 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Method0</td><td>.NET 7.0</td><td style="text-align: right">7.205 ns</td><td style="text-align: right">0.08</td></tr><tr><td>Method0</td><td>.NET 8.0</td><td style="text-align: right">5.719 ns</td><td style="text-align: right">0.06</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Method1</td><td>.NET 6.0</td><td style="text-align: right">132.832 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Method1</td><td>.NET 7.0</td><td style="text-align: right">26.151 ns</td><td style="text-align: right">0.20</td></tr><tr><td>Method1</td><td>.NET 8.0</td><td style="text-align: right">21.602 ns</td><td style="text-align: right">0.16</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Method2</td><td>.NET 6.0</td><td style="text-align: right">172.224 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Method2</td><td>.NET 7.0</td><td style="text-align: right">37.937 ns</td><td style="text-align: right">0.22</td></tr><tr><td>Method2</td><td>.NET 8.0</td><td style="text-align: right">26.951 ns</td><td style="text-align: right">0.16</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Method3</td><td>.NET 6.0</td><td style="text-align: right">211.247 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Method3</td><td>.NET 7.0</td><td style="text-align: right">42.988 ns</td><td style="text-align: right">0.20</td></tr><tr><td>Method3</td><td>.NET 8.0</td><td style="text-align: right">34.112 ns</td><td style="text-align: right">0.16</td></tr></tbody></table><p>However, there‚Äôs overhead involved here on each call and that‚Äôs repeated on each call. If we could extract that upfront work, do it once, and cache it, we can achieve much better performance. That‚Äôs exactly what the new <code>MethodInvoker</code> and <code>ConstructorInvoker</code> types implemented in <a href="https://github.com/dotnet/runtime/pull/88415">dotnet/runtime#88415</a> provide. These don‚Äôt incorporate all of the obscure corner-cases that <code>MethodBase.Invoke</code> handles (like specially recognizing and handling <code>Type.Missing</code>), but for everything else, it provides a great solution for optimizing the repeated invocation of methods whose signatures are unknown at build time.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Reflection;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly object _arg0 = 4, _arg1 = 5, _arg2 = 6;
    private readonly object[] _args3 = new object[] { 4, 5, 6 };
    private MethodInfo _method3;
    private MethodInvoker _method3Invoker;

    [GlobalSetup]
    public void Setup()
    {
        _method3 = typeof(Tests).GetMethod(&quot;MyMethod3&quot;, BindingFlags.NonPublic | BindingFlags.Static);
        _method3Invoker = MethodInvoker.Create(_method3);
    }

    [Benchmark(Baseline = true)] 
    public void MethodBaseInvoke() =&gt; _method3.Invoke(null, _args3);

    [Benchmark]
    public void MethodInvokerInvoke() =&gt; _method3Invoker.Invoke(null, _arg0, _arg1, _arg2);

    private static void MyMethod3(int arg1, int arg2, int arg3) { }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>MethodBaseInvoke</td><td style="text-align: right">32.42 ns</td><td style="text-align: right">1.00</td></tr><tr><td>MethodInvokerInvoke</td><td style="text-align: right">11.47 ns</td><td style="text-align: right">0.35</td></tr></tbody></table><p>As of <a href="https://github.com/dotnet/runtime/pull/90119">dotnet/runtime#90119</a>, these types are then used by the <code>ActivatorUtilities.CreateFactory</code> method in <code>Microsoft.Extensions.DependencyInjection.Abstractions</code> to further improve DI service construction performance. <a href="https://github.com/dotnet/runtime/pull/91881">dotnet/runtime#91881</a> improves it further by adding a an additional caching layer that further avoids reflection on each construction.</p><h2 id="primitives">Primitives</h2><p>It‚Äôs hard to believe that after two decades we‚Äôre still finding opportunity to improve the core primitive types in .NET, yet here we are. Some of this comes from new scenarios that drive optimization into different places; some of it comes from new opportunity based on new support that enables different approaches to the same problem; some of it comes from new research highlighting new ways to approach a problem; and some of it simply comes from many new eyes looking at a well-worn space (yay open source!)  Regardless of the reason, there‚Äôs a lot to be excited about here in .NET 8.</p><h3 id="enums">Enums</h3><p>Let‚Äôs start with <code>Enum</code>. <code>Enum</code> has obviously been around since the earliest days of .NET and is  used heavily. Although <code>Enum</code>‚Äòs functionality and implementation have evolved, and although it‚Äôs received new APIs, at its core, how the data is stored has fundamentally remained the same for many years. In the .NET Framework implementation, there‚Äôs an internal <code>ValuesAndNames</code> class that stores a <code>ulong[]</code> and a <code>string[]</code>, and in .NET 7, there‚Äôs an <code>EnumInfo</code> that serves the same purpose. That <code>string[]</code> contains the names of all of the enum‚Äôs values, and the <code>ulong[]</code> stores their numeric counterparts. It‚Äôs a <code>ulong[]</code> to accommodate all possible underlying types an <code>Enum</code> can be, including those supported by C# (<code>sbyte</code>, <code>byte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>) and those additionally supported by the runtime (<code>nint</code>, <code>nuint</code>, <code>char</code>, <code>float</code>, <code>double</code>) even though effectively no one uses those (partial <code>bool</code> support used to be on this list as well, but was deleted in .NET 8 in <a href="https://github.com/dotnet/runtime/pull/79962">dotnet/runtime#79962</a> by <a href="https://github.com/pedrobsaila">@pedrobsaila</a>).</p><p>As an aside, as part of all of this work, we examined the breadth of appropriately-licensed NuGet packages, looking for what the most common underlying types were in their use of <code>enum</code>. Out of ~163 million <code>enum</code>s found, here‚Äôs the breakdown of their underlying types. The result is likely not surprising, given the default underlying type for <code>Enum</code>, but it‚Äôs still interesting:</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/EnumUnderlyingTypesGraph.png" alt="Graph of how common is each underlying Enum type" /></p><p>There are several issues with the cited design for how <code>Enum</code> stores its data. Every operation translates between these <code>ulong[]</code> values and the actual type being used by the particular <code>Enum</code>, plus the array is often twice as large as it needs to be (<code>int</code> is the default underlying type for an enum and, as seen in the above graph, by <em>far</em> the most commonly used). The approach also leads to significant assembly code bloat when dealing with all the new generic methods that have been added to <code>Enum</code> in recent years. <code>enum</code>s are structs, and when a struct is used as a generic type argument, the JIT specializes the code for that value type (whereas for reference types it emits a single shared implementation used by all of them). That specialization is great for throughput, but it means that you get a copy of the code for every value type it‚Äôs used with; if you have a lot of code (e.g. <code>Enum</code> formatting) and a lot of possible types being substituted (e.g. every declared <code>enum</code> type), that‚Äôs a lot of possible increase in code size.</p><p>To address all of this, to modernize the implementation, and to make various operations faster, <a href="https://github.com/dotnet/runtime/pull/78580">dotnet/runtime#78580</a> rewrites <code>Enum</code>. Rather than having a non-generic <code>EnumInfo</code> that stores a <code>ulong[]</code> array of all values, it introduces a generic <code>EnumInfo&lt;TUnderlyingValue&gt;</code> that stores a <code>TUnderlyingValue[]</code>. Then based on the enum‚Äôs type, every generic and non-generic <code>Enum</code> method looks up the underlying <code>TUnderlyingType</code> and invokes a generic method with that <code>TUnderlyingType</code> but <em>not</em> with a generic type parameter for the <code>enum</code> type, e.g. <code>Enum.IsDefined&lt;TEnum&gt;(...)</code> and <code>Enum.IsDefined(typeof(TEnum), ...)</code> both look up the <code>TUnderlyingValue</code> for <code>TEnum</code> and invoke the internal <code>Enum.IsDefinedPrimitive&lt;TUnderlyingValue&gt;(typeof(TEnum))</code>. In this way, the implementation stores a strongly-typed <code>TUnderlyingValue[]</code> value rather than storing the worst case <code>ulong[]</code>, and all of the implementations across generic and non-generic entrypoints are shared while not having full generic specialization for every <code>TEnum</code>: worst case, we end up with one generic specialization per underlying type, of which only the previously cited 8 are expressible in C#. The generic entrypoints are able to do the mapping very efficiently, thanks to <a href="https://github.com/dotnet/runtime/pull/71685">dotnet/runtime#71685</a> from <a href="https://github.com/MichalPetryka">@MichalPetryka</a> which makes <code>typeof(TEnum).IsEnum</code> a JIT intrinsic (such that it effectively becomes a const), and the non-generic entrypoints use switches on <code>TypeCode</code>/<code>CorElementType</code> as was already being done in a variety of methods.</p><p>Other improvements were made to <code>Enum</code> as well. <a href="https://github.com/dotnet/runtime/pull/76162">dotnet/runtime#76162</a> improves the performance of various methods like <code>ToString</code> and <code>IsDefined</code> in cases where all of the <code>enum</code>‚Äòs defined values are sequential starting from 0. In that common case, the internal function that looks up the value in the <code>EnumInfo&lt;TUnderlyingValue&gt;</code> can do so with a simple array access, rather than needing to search for the target.</p><p>The net result of all of these changes are some very nice performance improvements:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly DayOfWeek _dow = DayOfWeek.Saturday;

    [Benchmark] public bool IsDefined() =&gt; Enum.IsDefined(_dow);
    [Benchmark] public string GetName() =&gt; Enum.GetName(_dow);
    [Benchmark] public string[] GetNames() =&gt; Enum.GetNames&lt;DayOfWeek&gt;();
    [Benchmark] public DayOfWeek[] GetValues() =&gt; Enum.GetValues&lt;DayOfWeek&gt;();
    [Benchmark] public Array GetUnderlyingValues() =&gt; Enum.GetValuesAsUnderlyingType&lt;DayOfWeek&gt;();
    [Benchmark] public string EnumToString() =&gt; _dow.ToString();
    [Benchmark] public bool TryParse() =&gt; Enum.TryParse&lt;DayOfWeek&gt;(&quot;Saturday&quot;, out _);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>IsDefined</td><td>.NET 7.0</td><td style="text-align: right">20.021 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>IsDefined</td><td>.NET 8.0</td><td style="text-align: right">2.502 ns</td><td style="text-align: right">0.12</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetName</td><td>.NET 7.0</td><td style="text-align: right">24.563 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>GetName</td><td>.NET 8.0</td><td style="text-align: right">3.648 ns</td><td style="text-align: right">0.15</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetNames</td><td>.NET 7.0</td><td style="text-align: right">37.138 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">80 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetNames</td><td>.NET 8.0</td><td style="text-align: right">22.688 ns</td><td style="text-align: right">0.61</td><td style="text-align: right">80 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetValues</td><td>.NET 7.0</td><td style="text-align: right">694.356 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">224 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetValues</td><td>.NET 8.0</td><td style="text-align: right">39.406 ns</td><td style="text-align: right">0.06</td><td style="text-align: right">56 B</td><td style="text-align: right">0.25</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetUnderlyingValues</td><td>.NET 7.0</td><td style="text-align: right">41.012 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">56 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetUnderlyingValues</td><td>.NET 8.0</td><td style="text-align: right">17.249 ns</td><td style="text-align: right">0.42</td><td style="text-align: right">56 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>EnumToString</td><td>.NET 7.0</td><td style="text-align: right">32.842 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">24 B</td><td style="text-align: right">1.00</td></tr><tr><td>EnumToString</td><td>.NET 8.0</td><td style="text-align: right">14.620 ns</td><td style="text-align: right">0.44</td><td style="text-align: right">24 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>TryParse</td><td>.NET 7.0</td><td style="text-align: right">49.121 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>TryParse</td><td>.NET 8.0</td><td style="text-align: right">30.394 ns</td><td style="text-align: right">0.62</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr></tbody></table><p>These changes, however, also made <code>enum</code>s play much more nicely with string interpolation. First, <code>Enum</code> now sports a new static <code>TryFormat</code> method, which enables formatting an <code>enum</code>‚Äòs string representation directly into a <code>Span&lt;char&gt;</code>:</p><pre><code class="language-C#">public static bool TryFormat&lt;TEnum&gt;(TEnum value, Span&lt;char&gt; destination, out int charsWritten, [StringSyntax(StringSyntaxAttribute.EnumFormat)] ReadOnlySpan&lt;char&gt; format = default) where TEnum : struct, Enum</code></pre><p>Second, <code>Enum</code> now implements <code>ISpanFormattable</code>, such that any code written to use a value‚Äôs <code>ISpanFormattable.TryFormat</code> method now lights up with <code>enum</code>s, too. However, even though enums are value types, they‚Äôre special and weird in that they derive from the reference type <code>Enum</code>, and that means calling instance methods like <code>ToString</code> or <code>ISpanFormattable.TryFormat</code> end up boxing the enum value.</p><p>So, third, the various interpolated string handlers in <code>System.Private.CoreLib</code> were updated to special-case <code>typeof(T).IsEnum</code>, which as noted is now effectively free thanks to JIT optimizations, using <code>Enum.TryFormat</code> directly in order to avoid the boxing. We can see the impact this has by running the following benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly char[] _dest = new char[100];
    private readonly FileAttributes _attr = FileAttributes.Hidden | FileAttributes.ReadOnly;

    [Benchmark]
    public bool Interpolate() =&gt; _dest.AsSpan().TryWrite($&quot;Attrs: {_attr}&quot;, out int charsWritten);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Interpolate</td><td>.NET 7.0</td><td style="text-align: right">81.58 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">80 B</td><td style="text-align: right">1.00</td></tr><tr><td>Interpolate</td><td>.NET 8.0</td><td style="text-align: right">34.41 ns</td><td style="text-align: right">0.42</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><h2 id="numbers">Numbers</h2><p>Such formatting improvements weren‚Äôt just reserved for <code>enum</code>s. The performance of number formatting also sees a nice set of improvements in .NET 8. Daniel Lemire has a <a href="https://lemire.me/blog/2021/06/03/computing-the-number-of-digits-of-an-integer-even-faster/">nice blog post from 2021</a> discussing various approaches to counting the number of digits in an integer. Digit counting is relevant to number formatting as we need to know how many characters the number will be, either to allocate a string of the right length to format into or to ensure that a destination buffer is of a sufficient length. <a href="https://github.com/dotnet/runtime/pull/76519">dotnet/runtime#76519</a> implements this inside of .NET‚Äôs number formatting, providing a branch-free, table-based lookup solution for computing the number of digits in a formatted value.</p><p><a href="https://github.com/dotnet/runtime/pull/76726">dotnet/runtime#76726</a> improves performance further by using a trick <a href="https://engineering.fb.com/2013/03/15/developer-tools/three-optimization-tips-for-c/">other formatting libraries use</a>. One of the more expensive parts of formatting a decimal is in dividing by 10 to pull off each digit; if we can reduce the number of divisions, we can reduce the overall expense of the formatting operation. The trick here is, rather than dividing by 10 for each digit in the number, we instead divide by 100 for each pair of digits in the number, and then have a precomputed lookup table for the <code>char</code>-based representation of all values 0 to 99. This lets us cut the number of divisions in half.</p><p><a href="https://github.com/dotnet/runtime/pull/79061">dotnet/runtime#79061</a> also expands on a previous optimization already present in .NET. The formatting code contained a table of precomputed strings for single digit numbers, so if you asked for the equivalent of <code>0.ToString()</code>, the implementation wouldn‚Äôt need to allocate a new string, it would just fetch <code>&quot;0&quot;</code> from the table and return it. This PR expands that cache from single digit numbers to being all numbers 0 through 299 (it also makes the cache lazy, such that we don‚Äôt need to pay for the strings for values that are never used). The choice of 299 is somewhat arbitrary and could be raised in the future if the need presents itself, but in examining data from various services, this addresses a significant chunk of the allocations that come from number formatting. Coincidentally or not, it also includes all success status codes from the HTTP protocol.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark]
    [Arguments(12)]
    [Arguments(123)]
    [Arguments(1_234_567_890)]
    public string Int32ToString(int i) =&gt; i.ToString();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th>i</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Int32ToString</td><td>.NET 7.0</td><td>12</td><td style="text-align: right">16.253 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">32 B</td><td style="text-align: right">1.00</td></tr><tr><td>Int32ToString</td><td>.NET 8.0</td><td>12</td><td style="text-align: right">1.985 ns</td><td style="text-align: right">0.12</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Int32ToString</td><td>.NET 7.0</td><td>123</td><td style="text-align: right">18.056 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">32 B</td><td style="text-align: right">1.00</td></tr><tr><td>Int32ToString</td><td>.NET 8.0</td><td>123</td><td style="text-align: right">1.971 ns</td><td style="text-align: right">0.11</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Int32ToString</td><td>.NET 7.0</td><td>1234567890</td><td style="text-align: right">26.964 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">48 B</td><td style="text-align: right">1.00</td></tr><tr><td>Int32ToString</td><td>.NET 8.0</td><td>1234567890</td><td style="text-align: right">17.082 ns</td><td style="text-align: right">0.63</td><td style="text-align: right">48 B</td><td style="text-align: right">1.00</td></tr></tbody></table><p>Numbers in .NET 8 also gain the ability to format as binary (via <a href="https://github.com/dotnet/runtime/pull/84889">dotnet/runtime#84889</a>, and parse from binary (via <a href="https://github.com/dotnet/runtime/pull/84998">dotnet/runtime#84998</a>), via the new ‚Äúb‚Äù specifier. For example, this:</p><pre><code class="language-C#">// dotnet run -f net8.0

int i = 12345;
Console.WriteLine(i.ToString(&quot;x16&quot;)); // 16 hex digits
Console.WriteLine(i.ToString(&quot;b16&quot;)); // 16 binary digits</code></pre><p>outputs:</p><pre><code class="language-text">0000000000003039
0011000000111001</code></pre><p>That implementation is then used to reimplement the existing <code>Convert.ToString(int value, int toBase)</code> method, such that it‚Äôs also now optimized:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly int _value = 12345;

    [Benchmark]
    public string ConvertBinary() =&gt; Convert.ToString(_value, 2);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>ConvertBinary</td><td>.NET 7.0</td><td style="text-align: right">104.73 ns</td><td style="text-align: right">1.00</td></tr><tr><td>ConvertBinary</td><td>.NET 8.0</td><td style="text-align: right">23.76 ns</td><td style="text-align: right">0.23</td></tr></tbody></table><p>In a significant addition to the primitive types (numerical and beyond), .NET 8 also sees the introduction of the new <code>IUtf8SpanFormattable</code> interface. <code>ISpanFormattable</code> was introduced in .NET 6, and with it <code>TryFormat</code> methods on many types that enable those types to directly format into a <code>Span&lt;char&gt;</code>:</p><pre><code class="language-C#">public interface ISpanFormattable : IFormattable
{
    bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider);
}</code></pre><p>Now in .NET 8, we also have the <code>IUtf8SpanFormattable</code> interface:</p><pre><code class="language-C#">public interface IUtf8SpanFormattable
{
    bool TryFormat(Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider);
}</code></pre><p>that enables types to directly format into a <code>Span&lt;byte&gt;</code>. These are by design almost identical, the key difference being whether the implementation of these interfaces writes out UTF16 <code>char</code>s or UTF8 <code>byte</code>s. With <a href="https://github.com/dotnet/runtime/pull/84587">dotnet/runtime#84587</a> and <a href="https://github.com/dotnet/runtime/pull/84841">dotnet/runtime#84841</a>, all of the numerical primitives in <code>System.Private.CoreLib</code> both implement the new interface and expose a public <code>TryFormat</code> method. So, for example, <code>ulong</code> exposes these:</p><pre><code class="language-C#">public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, [StringSyntax(StringSyntaxAttribute.NumericFormat)] ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = null);
public bool TryFormat(Span&lt;byte&gt; utf8Destination, out int bytesWritten, [StringSyntax(StringSyntaxAttribute.NumericFormat)] ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = null);</code></pre><p>They have the exact same functionality, support the exact same format strings, the same general performance characteristics, and so on, and simply differ in whether writing out UTF16 or UTF8. How can I be so sure they‚Äôre so similar? Because, drumroll, they share the same implementation. Thanks to generics, the two methods above delegate to the exact same helper:</p><pre><code class="language-C#">public static bool TryFormatUInt64&lt;TChar&gt;(ulong value, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider, Span&lt;TChar&gt; destination, out int charsWritten)</code></pre><p>just with one with <code>TChar</code> as <code>char</code> and the other as <code>byte</code>. So, when we run a benchmark like this:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly ulong _value = 12345678901234567890;
    private readonly char[] _chars = new char[20];
    private readonly byte[] _bytes = new byte[20];

    [Benchmark] public void FormatUTF16() =&gt; _value.TryFormat(_chars, out _);
    [Benchmark] public void FormatUTF8() =&gt; _value.TryFormat(_bytes, out _);
}</code></pre><p>we get practically identical results like this:</p><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th></tr></thead><tbody><tr><td>FormatUTF16</td><td style="text-align: right">12.10 ns</td></tr><tr><td>FormatUTF8</td><td style="text-align: right">12.96 ns</td></tr></tbody></table><p>And now that the primitive types themselves are able to format with full fidelity as UTF8, the <code>Utf8Formatter</code> class largely becomes legacy. In fact, the previously mentioned PR also rips out <code>Utf8Formatter</code>‚Äòs implementation and just reparents it on top of the same formatting logic from the primitive types. All of the previously cited performance improvements to number formatting then not only accrue to <code>ToString</code> and <code>TryFormat</code> for UTF16, and not only to <code>TryFormat</code> for UTF8, but then also to <code>Utf8Formatter</code> (plus, removing duplicated code and reducing maintenance burden makes me giddy).</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly byte[] _bytes = new byte[10];

    [Benchmark]
    [Arguments(123)]
    [Arguments(1234567890)]
    public bool Utf8FormatterTryFormat(int i) =&gt; Utf8Formatter.TryFormat(i, _bytes, out int bytesWritten);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th>i</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Utf8FormatterTryFormat</td><td>.NET 7.0</td><td>123</td><td style="text-align: right">8.849 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Utf8FormatterTryFormat</td><td>.NET 8.0</td><td>123</td><td style="text-align: right">4.645 ns</td><td style="text-align: right">0.53</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Utf8FormatterTryFormat</td><td>.NET 7.0</td><td>1234567890</td><td style="text-align: right">15.844 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Utf8FormatterTryFormat</td><td>.NET 8.0</td><td>1234567890</td><td style="text-align: right">7.174 ns</td><td style="text-align: right">0.45</td></tr></tbody></table><p>Not only is UTF8 formatting directly supported by all these types, so, too, is parsing. <a href="https://github.com/dotnet/runtime/pull/86875">dotnet/runtime#86875</a> added the new <code>IUtf8SpanParsable&lt;TSelf&gt;</code> interface and implemented it on the primitive numeric types. Just as with its formatting counterpart, this provides identical behavior to <code>IParsable&lt;TSelf&gt;</code>, just for UTF8 instead of UTF16. And just as with its formatting counterpart, all of the parsing logic is shared in generic routines between the two modes. In fact, not only does this share logic between UTF16 and UTF8 parsing, it follows closely on the heals of <a href="https://github.com/dotnet/runtime/pull/84582">dotnet/runtime#84582</a>, which uses the same generic tricks to deduplicate the parsing logic across all the primitive types, such that the same generic routines end up being used for all the types and both UTF8 and UTF16. That PR removed almost 2,000 lines of code from <code>System.Private.CoreLib</code>:</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/GitHubPlusMinusIndicatorForParsingDeduping.png" alt="GitHub plus/minus line count indicator for parsing deduplication" /></p><h2 id="datetime">DateTime</h2><p>Parsing and formatting are improved on other types, as well. Take <code>DateTime</code> and <code>DateTimeOffset</code>. <a href="https://github.com/dotnet/runtime/pull/84963">dotnet/runtime#84963</a> improved a variety of aspects of <code>DateTime{Offset}</code> formatting:</p><ul><li>The formatting logic has general support used as a fallback and that supports any custom format, but then there are dedicated routines used for the most popular formats, allowing them to be optimized and tuned. Dedicated routines already existed for the very popular ‚Äúr‚Äù (RFC1123 pattern) and ‚Äúo‚Äù (round-trip date/time pattern) formats; this PR adds dedicated routines for the default format (‚ÄúG‚Äù) when used with the invariant culture, the ‚Äús‚Äù format (sortable date/time pattern), and ‚Äúu‚Äù format (universal sortable date/time pattern), all of which are used frequently in a variety of domains.</li><li>For the ‚ÄúU‚Äù format (universal full date/time pattern), the implementation would end up always allocating new <code>DateTimeFormatInfo</code> and <code>GregorianCalendar</code> instances, resulting in a significant amount of allocation even though it was only needed in a rare fallback case. This fixed it to only allocate when truly required.</li><li>When there‚Äôs no dedicated formatting routine, formatting is done into an internal <code>ref struct</code> called <code>ValueListBuilder&lt;T&gt;</code> that starts with a provided span buffer (typically seeded from a <code>stackalloc</code>) and then grows with <code>ArrayPool</code> memory as needed. After the formatting has completed, that builder is either copied into a destination span or a new string, depending on the method that triggered the formatting. However, we can avoid that copy for a destination span if we just seed the builder with the destination span. Then if the builder still contains the initial span when formatting has completed (having not grown out of it), we know all the data fit, and we can skip the copy, as all the data is already there.</li></ul><p>Here‚Äôs some of the example impact:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Globalization;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly DateTime _dt = new DateTime(2023, 9, 1, 12, 34, 56);
    private readonly char[] _chars = new char[100];

    [Params(null, &quot;s&quot;, &quot;u&quot;, &quot;U&quot;, &quot;G&quot;)]
    public string Format { get; set; }

    [Benchmark] public string DT_ToString() =&gt; _dt.ToString(Format);
    [Benchmark] public string DT_ToStringInvariant() =&gt; _dt.ToString(Format, CultureInfo.InvariantCulture);
    [Benchmark] public bool DT_TryFormat() =&gt; _dt.TryFormat(_chars, out _, Format);
    [Benchmark] public bool DT_TryFormatInvariant() =&gt; _dt.TryFormat(_chars, out _, Format, CultureInfo.InvariantCulture);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th>Format</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>DT_ToString</td><td>.NET 7.0</td><td>?</td><td style="text-align: right">166.64 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToString</td><td>.NET 8.0</td><td>?</td><td style="text-align: right">102.45 ns</td><td style="text-align: right">0.62</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 7.0</td><td>?</td><td style="text-align: right">161.94 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 8.0</td><td>?</td><td style="text-align: right">28.74 ns</td><td style="text-align: right">0.18</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormat</td><td>.NET 7.0</td><td>?</td><td style="text-align: right">151.52 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>DT_TryFormat</td><td>.NET 8.0</td><td>?</td><td style="text-align: right">78.57 ns</td><td style="text-align: right">0.52</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 7.0</td><td>?</td><td style="text-align: right">140.35 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 8.0</td><td>?</td><td style="text-align: right">18.26 ns</td><td style="text-align: right">0.13</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToString</td><td>.NET 7.0</td><td>G</td><td style="text-align: right">162.86 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToString</td><td>.NET 8.0</td><td>G</td><td style="text-align: right">109.49 ns</td><td style="text-align: right">0.68</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 7.0</td><td>G</td><td style="text-align: right">162.20 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 8.0</td><td>G</td><td style="text-align: right">102.71 ns</td><td style="text-align: right">0.63</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormat</td><td>.NET 7.0</td><td>G</td><td style="text-align: right">148.32 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>DT_TryFormat</td><td>.NET 8.0</td><td>G</td><td style="text-align: right">83.60 ns</td><td style="text-align: right">0.57</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 7.0</td><td>G</td><td style="text-align: right">145.05 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 8.0</td><td>G</td><td style="text-align: right">79.77 ns</td><td style="text-align: right">0.55</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToString</td><td>.NET 7.0</td><td>s</td><td style="text-align: right">186.44 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToString</td><td>.NET 8.0</td><td>s</td><td style="text-align: right">29.35 ns</td><td style="text-align: right">0.17</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 7.0</td><td>s</td><td style="text-align: right">182.15 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 8.0</td><td>s</td><td style="text-align: right">27.67 ns</td><td style="text-align: right">0.16</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormat</td><td>.NET 7.0</td><td>s</td><td style="text-align: right">165.08 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>DT_TryFormat</td><td>.NET 8.0</td><td>s</td><td style="text-align: right">15.53 ns</td><td style="text-align: right">0.09</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 7.0</td><td>s</td><td style="text-align: right">155.24 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 8.0</td><td>s</td><td style="text-align: right">15.50 ns</td><td style="text-align: right">0.10</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToString</td><td>.NET 7.0</td><td>u</td><td style="text-align: right">184.71 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToString</td><td>.NET 8.0</td><td>u</td><td style="text-align: right">29.62 ns</td><td style="text-align: right">0.16</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 7.0</td><td>u</td><td style="text-align: right">184.01 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 8.0</td><td>u</td><td style="text-align: right">26.98 ns</td><td style="text-align: right">0.15</td><td style="text-align: right">64 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormat</td><td>.NET 7.0</td><td>u</td><td style="text-align: right">171.73 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>DT_TryFormat</td><td>.NET 8.0</td><td>u</td><td style="text-align: right">16.08 ns</td><td style="text-align: right">0.09</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 7.0</td><td>u</td><td style="text-align: right">158.42 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 8.0</td><td>u</td><td style="text-align: right">15.58 ns</td><td style="text-align: right">0.10</td><td style="text-align: right">‚Äì</td><td style="text-align: right">NA</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToString</td><td>.NET 7.0</td><td>U</td><td style="text-align: right">1,622.28 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">1240 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToString</td><td>.NET 8.0</td><td>U</td><td style="text-align: right">206.08 ns</td><td style="text-align: right">0.13</td><td style="text-align: right">96 B</td><td style="text-align: right">0.08</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 7.0</td><td>U</td><td style="text-align: right">1,567.92 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">1240 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_ToStringInvariant</td><td>.NET 8.0</td><td>U</td><td style="text-align: right">207.60 ns</td><td style="text-align: right">0.13</td><td style="text-align: right">96 B</td><td style="text-align: right">0.08</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormat</td><td>.NET 7.0</td><td>U</td><td style="text-align: right">1,590.27 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">1144 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_TryFormat</td><td>.NET 8.0</td><td>U</td><td style="text-align: right">190.98 ns</td><td style="text-align: right">0.12</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 7.0</td><td>U</td><td style="text-align: right">1,560.00 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">1144 B</td><td style="text-align: right">1.00</td></tr><tr><td>DT_TryFormatInvariant</td><td>.NET 8.0</td><td>U</td><td style="text-align: right">184.11 ns</td><td style="text-align: right">0.12</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>Parsing has also improved meaningfully. For example, <a href="https://github.com/dotnet/runtime/pull/82877">dotnet/runtime#82877</a> improves the handling of ‚Äúddd‚Äù (abbreviated name of the day of the week), ‚Äúdddd‚Äù (full name of the day of the week), ‚ÄúMMM‚Äù (abbreviated name of the month), and ‚ÄúMMMM‚Äù (full name of the month) in a custom format string; these show up in a variety of commonly used format strings, such as in the expanded definition of the RFC1123 format: <code>ddd, dd MMM yyyy HH&#39;:&#39;mm&#39;:&#39;ss &#39;GMT&#39;</code>. When the general parsing routine encounters these in a format string, it needs to consult the supplied <code>CultureInfo</code> / <code>DateTimeFormatInfo</code> for that culture‚Äôs associated month and day names, e.g. <code>DateTimeFormatInfo.GetAbbreviatedMonthName</code>, and then needs to do a linguistic ignore-case comparison for each name against the input text; that‚Äôs not particularly cheap. However, if we‚Äôre given an invariant culture, we can do the comparison much, much faster. Take ‚ÄúMMM‚Äù for abbreviated month name, for example. We can read the next three characters (<code>uint m0 = span[0], m1 = span[1], m2 = span[2]</code>), ensure they‚Äôre all ASCII (<code>(m0 | m1 | m2) &lt;= 0x7F</code>), and then combine them all into a single <code>uint</code>, employing the same ASCII casing trick discussed earlier (<code>(m0 &lt;&lt; 16) | (m1 &lt;&lt; 8) | m2 | 0x202020</code>). We can do the same thing, precomputed, for each month name, which for the invariant culture we know in advance, and the entire lookup becomes a single numerical <code>switch</code>:</p><pre><code class="language-C#">switch ((m0 &lt;&lt; 16) | (m1 &lt;&lt; 8) | m2 | 0x202020)
{
    case 0x6a616e: /* &#39;jan&#39; */ result = 1; break;
    case 0x666562: /* &#39;feb&#39; */ result = 2; break;
    case 0x6d6172: /* &#39;mar&#39; */ result = 3; break;
    case 0x617072: /* &#39;apr&#39; */ result = 4; break;
    case 0x6d6179: /* &#39;may&#39; */ result = 5; break;
    case 0x6a756e: /* &#39;jun&#39; */ result = 6; break;
    case 0x6a756c: /* &#39;jul&#39; */ result = 7; break;
    case 0x617567: /* &#39;aug&#39; */ result = 8; break;
    case 0x736570: /* &#39;sep&#39; */ result = 9; break;
    case 0x6f6374: /* &#39;oct&#39; */ result = 10; break;
    case 0x6e6f76: /* &#39;nov&#39; */ result = 11; break;
    case 0x646563: /* &#39;dec&#39; */ result = 12; break;
    default: maxMatchStrLen = 0; break; // undo match assumption
}  </code></pre><p>Nifty, and way faster.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Globalization;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private const string Format = &quot;ddd, dd MMM yyyy HH&#39;:&#39;mm&#39;:&#39;ss &#39;GMT&#39;&quot;;

    private readonly string _s = new DateTime(1955, 11, 5, 6, 0, 0, DateTimeKind.Utc).ToString(Format, CultureInfo.InvariantCulture);

    [Benchmark]
    public void ParseExact() =&gt; DateTimeOffset.ParseExact(_s, Format, CultureInfo.InvariantCulture, DateTimeStyles.AllowInnerWhite | DateTimeStyles.AssumeUniversal);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>ParseExact</td><td>.NET 7.0</td><td style="text-align: right">1,139.3 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">80 B</td><td style="text-align: right">1.00</td></tr><tr><td>ParseExact</td><td>.NET 8.0</td><td style="text-align: right">318.6 ns</td><td style="text-align: right">0.28</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>A variety of other PRs contributed as well. The decreased allocation in the previous benchmark is thanks to <a href="https://github.com/dotnet/runtime/pull/82861">dotnet/runtime#82861</a>, which removed a string allocation that might occur when the format string contained quotes; the PR simply replaced the string allocation with use of spans. <a href="https://github.com/dotnet/runtime/pull/82925">dotnet/runtime#82925</a> further reduced the cost of parsing with the ‚Äúr‚Äù and ‚Äúo‚Äù formats by removing some work that ended up being unnecessary, removing a virtual dispatch, and general streamlining of the code paths. And <a href="https://github.com/dotnet/runtime/pull/84964">dotnet/runtime#84964</a> removed some <code>string[]</code> allocations that occured in <code>ParseExact</code> when parsing with some cultures, in particular those that employ genitive month names. If the parser needed to retrieve the <code>MonthGenitiveNames</code> or <code>AbbreviatedMonthGenitiveNames</code> arrays, it would do so via the public properties for these on <code>DateTimeFormatInfo</code>; however, out of concern that code could mutate those arrays, these public properties hand back copies. That means that the parser was allocating a copy every time it accessed one of these. The parser can instead access the underlying original array, and pinky swear not to change it.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Globalization;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly CultureInfo _ci = new CultureInfo(&quot;ru-RU&quot;);

    [Benchmark] public DateTime Parse() =&gt; DateTime.ParseExact(&quot;–≤—Ç–æ—Ä–Ω–∏–∫, 18 –∞–ø—Ä–µ–ª—è 2023 04:31:26&quot;, &quot;dddd, dd MMMM yyyy HH:mm:ss&quot;, _ci);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Parse</td><td>.NET 7.0</td><td style="text-align: right">2.654 us</td><td style="text-align: right">1.00</td><td style="text-align: right">128 B</td><td style="text-align: right">1.00</td></tr><tr><td>Parse</td><td>.NET 8.0</td><td style="text-align: right">2.353 us</td><td style="text-align: right">0.90</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p><code>DateTime</code> and <code>DateTimeOffset</code> also implement <code>IUtf8SpanFormattable</code>, thanks to <a href="https://github.com/dotnet/runtime/pull/84469">dotnet/runtime#84469</a>, and as with the numerical types, the implementations are all shared between UTF16 and UTF8; thus all of the optimizations previously mentioned accrue to both. And again, <code>Utf8Formatter</code>‚Äòs support for formatting <code>DateTimeOffset</code> is just reparented on top of this same shared logic.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly DateTime _dt = new DateTime(2023, 9, 1, 12, 34, 56);
    private readonly byte[] _bytes = new byte[100];

    [Benchmark] public bool TryFormatUtf8Formatter() =&gt; Utf8Formatter.TryFormat(_dt, _bytes, out _); 
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>TryFormatUtf8Formatter</td><td>.NET 7.0</td><td style="text-align: right">19.35 ns</td><td style="text-align: right">1.00</td></tr><tr><td>TryFormatUtf8Formatter</td><td>.NET 8.0</td><td style="text-align: right">16.24 ns</td><td style="text-align: right">0.83</td></tr></tbody></table><p>Since we‚Äôre talking about <code>DateTime</code>, a brief foray into <code>TimeZoneInfo</code>. <code>TimeZoneInfo.FindSystemTimeZoneById</code> gets a <code>TimeZoneInfo</code> object for the specified identifier. One of the <a href="https://devblogs.microsoft.com/dotnet/date-time-and-time-zone-enhancements-in-net-6/">improvements introduced in .NET 6</a> is that <code>FindSystemTimeZoneById</code> supports both the Windows time zone set as well as the IANA time zone set, regardless of whether running on Windows or Linux or macOS. However, the <code>TimeZoneInfo</code> was only being cached when its ID matched that for the current OS, and as such calls that resolved to the other set weren‚Äôt being fulfilled by the cache and were falling back to re-reading from the OS. <a href="https://github.com/dotnet/runtime/pull/85615">dotnet/runtime#85615</a> ensures a cache can be used in both cases. It also allows returning the immutable <code>TimeZoneInfo</code> objects directly, rather than cloning them on every access. <a href="https://github.com/dotnet/runtime/pull/88368">dotnet/runtime#88368</a> also improves <code>TimeZoneInfo</code>, in particular <code>GetSystemTimeZones</code> on Linux and macOS, by lazily loading several of the properties. <a href="https://github.com/dotnet/runtime/pull/89985">dotnet/runtime#89985</a> then improves on that with a new overload of <code>GetSystemTimeZones</code> that allows the caller to skip the sort the implementation would otherwise perform on the result.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark]
    [Arguments(&quot;America/Los_Angeles&quot;)]
    [Arguments(&quot;Pacific Standard Time&quot;)]
    public TimeZoneInfo FindSystemTimeZoneById(string id) =&gt; TimeZoneInfo.FindSystemTimeZoneById(id);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th>id</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>FindSystemTimeZoneById</td><td>.NET 7.0</td><td>America/Los_Angeles</td><td style="text-align: right">1,503.75 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">80 B</td><td style="text-align: right">1.00</td></tr><tr><td>FindSystemTimeZoneById</td><td>.NET 8.0</td><td>America/Los_Angeles</td><td style="text-align: right">40.96 ns</td><td style="text-align: right">0.03</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>FindSystemTimeZoneById</td><td>.NET 7.0</td><td>Pacif(‚Ä¶) Time [21]</td><td style="text-align: right">3,951.60 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">568 B</td><td style="text-align: right">1.00</td></tr><tr><td>FindSystemTimeZoneById</td><td>.NET 8.0</td><td>Pacif(‚Ä¶) Time [21]</td><td style="text-align: right">57.00 ns</td><td style="text-align: right">0.01</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>Back to formatting and parsing‚Ä¶</p><h2 id="guid">Guid</h2><p>Formatting and parsing improvements go beyond the numerical and date types. <code>Guid</code> also gets in on the game. Thanks to <a href="https://github.com/dotnet/runtime/pull/84553">dotnet/runtime#84553</a>, <code>Guid</code> implements <code>IUtf8SpanFormattable</code>, and as with all the other cases, it shares the exact same routines between UTF16 and UTF8 support. Then <a href="https://github.com/dotnet/runtime/pull/81650">dotnet/runtime#81650</a>, <a href="https://github.com/dotnet/runtime/pull/81666">dotnet/runtime#81666</a>, and <a href="https://github.com/dotnet/runtime/pull/87126">dotnet/runtime#87126</a> from <a href="https://github.com/SwapnilGaikwad">@SwapnilGaikwad</a> vectorize that formatting support.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly Guid _guid = Guid.Parse(&quot;7BD626F6-4396-41E3-A491-4B1DC538DD92&quot;);
    private readonly char[] _dest = new char[100];

    [Benchmark]
    [Arguments(&quot;D&quot;)]
    [Arguments(&quot;N&quot;)]
    [Arguments(&quot;B&quot;)]
    [Arguments(&quot;P&quot;)]
    public bool TryFormat(string format) =&gt; _guid.TryFormat(_dest, out _, format);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th>format</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>TryFormat</td><td>.NET 7.0</td><td>B</td><td style="text-align: right">23.622 ns</td><td style="text-align: right">1.00</td></tr><tr><td>TryFormat</td><td>.NET 8.0</td><td>B</td><td style="text-align: right">7.341 ns</td><td style="text-align: right">0.31</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>TryFormat</td><td>.NET 7.0</td><td>D</td><td style="text-align: right">22.134 ns</td><td style="text-align: right">1.00</td></tr><tr><td>TryFormat</td><td>.NET 8.0</td><td>D</td><td style="text-align: right">5.485 ns</td><td style="text-align: right">0.25</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>TryFormat</td><td>.NET 7.0</td><td>N</td><td style="text-align: right">20.891 ns</td><td style="text-align: right">1.00</td></tr><tr><td>TryFormat</td><td>.NET 8.0</td><td>N</td><td style="text-align: right">4.852 ns</td><td style="text-align: right">0.23</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>TryFormat</td><td>.NET 7.0</td><td>P</td><td style="text-align: right">24.139 ns</td><td style="text-align: right">1.00</td></tr><tr><td>TryFormat</td><td>.NET 8.0</td><td>P</td><td style="text-align: right">6.101 ns</td><td style="text-align: right">0.25</td></tr></tbody></table><p>Before moving on from primitives and numerics, let‚Äôs take a quick look at <code>System.Random</code>, which has methods for producing pseudo-random numerical values.</p><h2 id="random">Random</h2><p><a href="https://github.com/dotnet/runtime/pull/79790">dotnet/runtime#79790</a> from <a href="https://github.com/mla-alm">@mla-alm</a> provides an implementation in <code>Random</code> based on <a href="https://github.com/lemire">@lemire</a>‚Äòs <a href="https://github.com/lemire/fastrange">unbiased range functions</a>. When a method like <code>Next(int min, int max)</code> is invoked, it needs to provide a value in the range <code>[min, max)</code>. In order to provide an unbiased answer, the .NET 7 implementation generates a 32-bit value, narrows down the range to the smallest power of 2 that contains the max (by taking the log2 of the max and shifting to throw away bits), and then checks whether the result is less than the max: if it is, it returns the result as the answer. But if it‚Äôs not, it rejects the value (a process referred to as ‚Äúrejection sampling‚Äù) and loops around to start the whole process over. While the cost to produce each sample in the current approach isn‚Äôt terrible, the nature of the approach makes it reasonably likely the sample will need to be rejected, which means looping and retries. With the new approach, it effectively implements modulo reduction (e.g. <code>Next() % max</code>), except replacing the expensive modulo operation with a cheaper multiplication and shift; then a rejection sampling loop is still employed, but the bias it corrects for happens much more rarely and thus the more expensive path happens much more rarely. The net result is a nice boost on average to the throughput of <code>Random</code>‚Äòs methods (<code>Random</code> can also get a boost from dynamic PGO, as the internal abstraction <code>Random</code> uses can be devirtualized, so I‚Äôve shown here the impact with and without PGO enabled.)</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;.NET 7&quot;).WithRuntime(CoreRuntime.Core70).AsBaseline())
    .AddJob(Job.Default.WithId(&quot;.NET 8 w/o PGO&quot;).WithRuntime(CoreRuntime.Core80).WithEnvironmentVariable(&quot;DOTNET_TieredPGO&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;.NET 8&quot;).WithRuntime(CoreRuntime.Core80));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;)]
public class Tests
{
    private static readonly Random s_rand = new();

    [Benchmark]
    public int NextMax() =&gt; s_rand.Next(12345);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>NextMax</td><td>.NET 7.0</td><td style="text-align: right">5.793 ns</td><td style="text-align: right">1.00</td></tr><tr><td>NextMax</td><td>.NET 8.0 w/o PGO</td><td style="text-align: right">1.840 ns</td><td style="text-align: right">0.32</td></tr><tr><td>NextMax</td><td>.NET 8.0</td><td style="text-align: right">1.598 ns</td><td style="text-align: right">0.28</td></tr></tbody></table><p><a href="https://github.com/dotnet/runtime/pull/87219">dotnet/runtime#87219</a> from <a href="https://github.com/MichalPetryka">@MichalPetryka</a> then further improves this for <code>long</code> values. The core part of the algorithm involves multiplying the random value by the max value and then taking the low part of the product:</p><pre><code class="language-C#">UInt128 randomProduct = (UInt128)maxValue * xoshiro.NextUInt64();
ulong lowPart = (ulong)randomProduct;</code></pre><p>This can be made more efficient by not using <code>UInt128</code>‚Äòs multiplication implementation and instead using <code>Math.BigMul</code>,</p><pre><code class="language-C#">ulong randomProduct = Math.BigMul(maxValue, xoshiro.NextUInt64(), out ulong lowPart);</code></pre><p>which is implemented to use the <code>Bmi2.X64.MultiplyNoFlags</code> or <code>Armbase.Arm64.MultiplyHigh</code> intrinsics when one is available.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;)]
public class Tests
{
    private static readonly Random s_rand = new();

    [Benchmark]
    public long NextMinMax() =&gt; s_rand.NextInt64(123456789101112, 1314151617181920);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>NextMinMax</td><td>.NET 7.0</td><td style="text-align: right">9.839 ns</td><td style="text-align: right">1.00</td></tr><tr><td>NextMinMax</td><td>.NET 8.0</td><td style="text-align: right">1.927 ns</td><td style="text-align: right">0.20</td></tr></tbody></table><p>Finally, I‚Äôll mention <a href="https://github.com/dotnet/runtime/pull/81627">dotnet/runtime#81627</a>. <code>Random</code> is both a commonly-used type in its own right and also an abstraction; many of the APIs on <code>Random</code> are virtual, such that a derived type can be implemented to completely swap out the algorithm employed. So, for example, if you wanted to implement a <code>MersenneTwisterRandom</code> that derived from <code>Random</code> and completely replaced the base algorithm by overriding every virtual method, you could do so, pass your instance around as <code>Random</code>, and everyone‚Äôs happy‚Ä¶ unless you‚Äôre creating your derived type frequently and care about allocation. <code>Random</code> actually includes multiple pseudo-random generators. .NET 6 imbued it with an implementation of the <code>xoshiro128**</code>/<code>xoshiro256**</code> algorithms, which are used when you just do <code>new Random()</code>. However, if you instead instantiate a derived type, the implementation falls back to the same algorithm (a variant of Knuth‚Äôs subtractive random number generator algorithm) it‚Äôs used since the dawn of <code>Random</code>, as it doesn‚Äôt know what the derived type will be doing nor what dependencies it may have taken on the nature of the algorithm employed. That algorithm carries with it a 56-element <code>int[]</code>, which means that derived classes end up instantiating and initializing that array even if they never use it. With this PR, the creation of that array is made lazy, such that it‚Äôs only initialized if and when it‚Äôs used. With that, a derived implementation that wants to avoid that cost can.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark] public Random NewDerived() =&gt; new NotRandomRandom();

    private sealed class NotRandomRandom : Random { }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>NewDerived</td><td>.NET 7.0</td><td style="text-align: right">1,237.73 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">312 B</td><td style="text-align: right">1.00</td></tr><tr><td>NewDerived</td><td>.NET 8.0</td><td style="text-align: right">20.49 ns</td><td style="text-align: right">0.02</td><td style="text-align: right">72 B</td><td style="text-align: right">0.23</td></tr></tbody></table><h2 id="strings-arrays-and-spans">Strings, Arrays, and Spans</h2><p>.NET 8 sees a tremendous amount of improvement in the realm of data processing, in particular in the efficient manipulation of strings, arrays, and spans. Since we‚Äôve just been talking about UTF8 and <code>IUtf8SpanFormattable</code>, let‚Äôs start there.</p><h3 id="utf8">UTF8</h3><p>As noted, <code>IUtf8SpanFormattable</code> is now implemented on a bunch of types. I noted all the numerical primitives, <code>DateTime{Offset}</code>, and <code>Guid</code>, and with <a href="https://github.com/dotnet/runtime/pull/84556">dotnet/runtime#84556</a> the <code>System.Version</code> type also implements it, as do <code>IPAddress</code> and the new <code>IPNetwork</code> types, thanks to <a href="https://github.com/dotnet/runtime/pull/84487">dotnet/runtime#84487</a>. However, .NET 8 doesn‚Äôt just provide implementations of this interface on all of these types, it also consumes the interface in a key place.</p><p>If you‚Äôll recall, <a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/">string interpolation in C# 10 and .NET 6</a> was completely overhauled. This included not only making string interpolation much more efficient, but also in providing a pattern that a type could implement to allow for the string interpolation syntax to be used efficiently to do things other than create a new string. For example, a new <code>TryWrite</code> extension method for <code>Span&lt;char&gt;</code> was added that makes it possible to format an interpolated string directly into a destination <code>char</code> buffer:</p><pre><code class="language-C#">public bool Format(Span&lt;char&gt; span, DateTime dt, out int charsWritten) =&gt;
    span.TryWrite($&quot;Date: {dt:R}&quot;, out charsWritten);</code></pre><p>The above gets translated (‚Äúlowered‚Äù) by the compiler into the equivalent of the following:</p><pre><code class="language-C#">public bool Format(Span&lt;char&gt; span, DateTime dt, out int charsWritten)
{
    var handler = new MemoryExtensions.TryWriteInterpolatedStringHandler(6, 1, span, out bool shouldAppend);
    _ = shouldAppend &amp;&amp;
        handler.AppendLiteral(&quot;Date: &quot;) &amp;&amp;
        handler.AppendFormatted&lt;DateTime&gt;(dt, &quot;R&quot;);
    return MemoryExtensions.TryWrite(span, ref handler, out charsWritten);</code></pre><p>The implementation of that generic <code>AppendFormatted&lt;T&gt;</code> call examines the <code>T</code> and tries to do the most optimal thing. In this case, it‚Äôll see that <code>T</code> implements <code>ISpanFormattable</code>, and it‚Äôll end up using its <code>TryFormat</code> to format directly into the destination span.</p><p>That‚Äôs for UTF16. Now with <code>IUtf8SpanFormattable</code>, we have the opportunity to do the same thing but for UTF8. And that‚Äôs exactly what <a href="https://github.com/dotnet/runtime/pull/83852">dotnet/runtime#83852</a> does. It introduces the new <code>Utf8.TryWrite</code> method, which behaves exactly like the aforementioned <code>TryWrite</code>, except writing as UTF8 into a destination <code>Span&lt;byte&gt;</code> instead of as UTF16 into a destination <code>Span&lt;char&gt;</code>. The implementation also special-cases <code>IUtf8SpanFormattable</code>, using its <code>TryFormat</code> to write directly into the destination buffer.</p><p>With that, we can write the equivalent to the method we wrote earlier:</p><pre><code class="language-C#">public bool Format(Span&lt;byte&gt; span, DateTime dt, out int bytesWritten) =&gt;
    Utf8.TryWrite(span, $&quot;Date: {dt:R}&quot;, out bytesWritten);</code></pre><p>and that gets lowered as you‚Äôd now expect:</p><pre><code class="language-C#">public bool Format(Span&lt;byte&gt; span, DateTime dt, out int bytesWritten)
{
    var handler = new Utf8.TryWriteInterpolatedStringHandler(6, 1, span, out bool shouldAppend);
    _ = shouldAppend &amp;&amp;
        handler.AppendLiteral(&quot;Date: &quot;) &amp;&amp;
        handler.AppendFormatted&lt;DateTime&gt;(dt, &quot;R&quot;);
    return Utf8.TryWrite(span, ref handler, out bytesWritten);</code></pre><p>So, identical, other than the parts you expect to change. But that‚Äôs also a problem in some ways. Take a look at that <code>AppendLiteral(&quot;Date: &quot;)</code> call. In the UTF16 case where we‚Äôre dealing with a destination <code>Span&lt;char&gt;</code>, the implementation of <code>AppendLiteral</code> simply needs to copy that string into the destination; not only that, but the JIT will inline the call, see that a string literal is being copied, and will unroll the copy, making it super efficient. But in the UTF8 case, we can‚Äôt just copy the UTF16 string <code>char</code>s into the destination UTF8 <code>Span&lt;byte&gt;</code> buffer; we need to UTF8 encode the string. And while we can certainly do that (<a href="https://github.com/dotnet/runtime/pull/84609">dotnet/runtime#84609</a> and <a href="https://github.com/dotnet/runtime/pull/85120">dotnet/runtime#85120</a> make that trivial with the addition of a new <code>Encoding.TryGetBytes</code> method), it‚Äôs frustratingly inefficient to need to spend cycles repeatedly at run-time doing work that could be done at compile time. After all, we‚Äôre dealing with a string literal known at JIT time; it‚Äôd be really, really nice if the JIT could do the UTF8 encoding and then do an unrolled copy just as it‚Äôs already doing in the UTF16 case. And with <a href="https://github.com/dotnet/runtime/pull/85328">dotnet/runtime#85328</a> and <a href="https://github.com/dotnet/runtime/pull/89376">dotnet/runtime#89376</a>, that‚Äôs exactly what happens, such that performance is effectively the same between them.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Unicode;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly char[] _chars = new char[100];
    private readonly byte[] _bytes = new byte[100];
    private readonly int _major = 1, _minor = 2, _build = 3, _revision = 4;

    [Benchmark] public bool FormatUTF16() =&gt; _chars.AsSpan().TryWrite($&quot;{_major}.{_minor}.{_build}.{_revision}&quot;, out int charsWritten);
    [Benchmark] public bool FormatUTF8() =&gt; Utf8.TryWrite(_bytes, $&quot;{_major}.{_minor}.{_build}.{_revision}&quot;, out int bytesWritten);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th></tr></thead><tbody><tr><td>FormatUTF16</td><td style="text-align: right">19.07 ns</td></tr><tr><td>FormatUTF8</td><td style="text-align: right">19.33 ns</td></tr></tbody></table><h2 id="ascii">ASCII</h2><p>UTF8 is the predominent encoding for text on the internet and for the movement of text between endpoints. However, much of this data is actually the ASCII subset, the 128 values in the range <code>[0, 127]</code>. When you know the data you‚Äôre working with is ASCII, you can achieve even better performance by using routines optimized for the subset. The new <code>Ascii</code> class in .NET 8, introduced in <a href="https://github.com/dotnet/runtime/pull/75012">dotnet/runtime#75012</a> and <a href="https://github.com/dotnet/runtime/pull/84886">dotnet/runtime#84886</a>, and then further optimized in <a href="https://github.com/dotnet/runtime/pull/85926">dotnet/runtime#85926</a> from <a href="https://github.com/gfoidl">@gfoidl</a>,
<a href="https://github.com/dotnet/runtime/pull/85266">dotnet/runtime#85266</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a>, <a href="https://github.com/dotnet/runtime/pull/84881">dotnet/runtime#84881</a>, and <a href="https://github.com/dotnet/runtime/pull/87141">dotnet/runtime#87141</a>, provides this:</p><pre><code class="language-C#">namespace System.Text;

public static class Ascii
{
    public static bool Equals(ReadOnlySpan&lt;byte&gt; left, ReadOnlySpan&lt;byte&gt; right);
    public static bool Equals(ReadOnlySpan&lt;byte&gt; left, ReadOnlySpan&lt;char&gt; right);
    public static bool Equals(ReadOnlySpan&lt;char&gt; left, ReadOnlySpan&lt;byte&gt; right);
    public static bool Equals(ReadOnlySpan&lt;char&gt; left, ReadOnlySpan&lt;char&gt; right);

    public static bool EqualsIgnoreCase(ReadOnlySpan&lt;byte&gt; left, ReadOnlySpan&lt;byte&gt; right);
    public static bool EqualsIgnoreCase(ReadOnlySpan&lt;byte&gt; left, ReadOnlySpan&lt;char&gt; right);
    public static bool EqualsIgnoreCase(ReadOnlySpan&lt;char&gt; left, ReadOnlySpan&lt;byte&gt; right);
    public static bool EqualsIgnoreCase(ReadOnlySpan&lt;char&gt; left, ReadOnlySpan&lt;char&gt; right);

    public static bool IsValid(byte value);
    public static bool IsValid(char value);
    public static bool IsValid(ReadOnlySpan&lt;byte&gt; value);
    public static bool IsValid(ReadOnlySpan&lt;char&gt; value);

    public static OperationStatus ToLower(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, out int bytesWritten);
    public static OperationStatus ToLower(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, out int charsWritten);
    public static OperationStatus ToLower(ReadOnlySpan&lt;byte&gt; source, Span&lt;char&gt; destination, out int charsWritten);
    public static OperationStatus ToLower(ReadOnlySpan&lt;char&gt; source, Span&lt;byte&gt; destination, out int bytesWritten);

    public static OperationStatus ToUpper(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, out int bytesWritten);
    public static OperationStatus ToUpper(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, out int charsWritten);
    public static OperationStatus ToUpper(ReadOnlySpan&lt;byte&gt; source, Span&lt;char&gt; destination, out int charsWritten);
    public static OperationStatus ToUpper(ReadOnlySpan&lt;char&gt; source, Span&lt;byte&gt; destination, out int bytesWritten);

    public static OperationStatus ToLowerInPlace(Span&lt;byte&gt; value, out int bytesWritten);
    public static OperationStatus ToLowerInPlace(Span&lt;char&gt; value, out int charsWritten);
    public static OperationStatus ToUpperInPlace(Span&lt;byte&gt; value, out int bytesWritten);
    public static OperationStatus ToUpperInPlace(Span&lt;char&gt; value, out int charsWritten);

    public static OperationStatus FromUtf16(ReadOnlySpan&lt;char&gt; source, Span&lt;byte&gt; destination, out int bytesWritten);
    public static OperationStatus ToUtf16(ReadOnlySpan&lt;byte&gt; source, Span&lt;char&gt; destination, out int charsWritten);

    public static Range Trim(ReadOnlySpan&lt;byte&gt; value);
    public static Range Trim(ReadOnlySpan&lt;char&gt; value);

    public static Range TrimEnd(ReadOnlySpan&lt;byte&gt; value);
    public static Range TrimEnd(ReadOnlySpan&lt;char&gt; value);

    public static Range TrimStart(ReadOnlySpan&lt;byte&gt; value);
    public static Range TrimStart(ReadOnlySpan&lt;char&gt; value);
}</code></pre><p>Note that it provides overloads that operate on UTF16 (<code>char</code>) and UTF8 (<code>byte</code>), and in many cases, intermixes them, such that you can, for example, compare a UTF8 <code>ReadOnlySpan&lt;byte&gt;</code> with a UTF16 <code>ReadOnlySpan&lt;char&gt;</code>, or transcode a UTF16 <code>ReadOnlySpan&lt;char&gt;</code> to a UTF8 <code>ReadOnlySpan&lt;byte&gt;</code> (which, when working with ASCII, is purely a narrowing operation, getting rid of the leading 0 <code>byte</code> in each <code>char</code>). For example, the PR that added these methods also used them in a variety of places (something I advocate for strongly, in order to ensure what has been designed is actually meeting the need, or ensure that other core library code is benefiting from the new APIs, which in turn makes those APIs more valuable, as their benefits accrue to more indirect consumers), including in multiple places in <code>SocketsHttpHandler</code>. Previously, <code>SocketsHttpHandler</code> had its own helpers for this purpose, an example of which I‚Äôve copied here into this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly byte[] _bytes = &quot;Strict-Transport-Security&quot;u8.ToArray();
    private readonly string _chars = &quot;Strict-Transport-Security&quot;;

    [Benchmark(Baseline = true)]
    public bool Equals_OpenCoded() =&gt; EqualsOrdinalAsciiIgnoreCase(_chars, _bytes);

    [Benchmark]
    public bool Equals_Ascii() =&gt; Ascii.EqualsIgnoreCase(_chars, _bytes);

    internal static bool EqualsOrdinalAsciiIgnoreCase(string left, ReadOnlySpan&lt;byte&gt; right)
    {
        if (left.Length != right.Length)
            return false;

        for (int i = 0; i &lt; left.Length; i++)
        {
            uint charA = left[i], charB = right[i];

            if ((charA - &#39;a&#39;) &lt;= (&#39;z&#39; - &#39;a&#39;)) charA -= (&#39;a&#39; - &#39;A&#39;);
            if ((charB - &#39;a&#39;) &lt;= (&#39;z&#39; - &#39;a&#39;)) charB -= (&#39;a&#39; - &#39;A&#39;);

            if (charA != charB)
                return false;
        }

        return true;
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Equals_OpenCoded</td><td style="text-align: right">31.159 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Equals_Ascii</td><td style="text-align: right">3.985 ns</td><td style="text-align: right">0.13</td></tr></tbody></table><p>Many of these new <code>Ascii</code> APIs also got the <code>Vector512</code> treatment, such that they light up when AVX512 is supported by the current machine, thanks to <a href="https://github.com/dotnet/runtime/pull/88532">dotnet/runtime#88532</a> from <a href="https://github.com/anthonycanino">@anthonycanino</a> and  <a href="https://github.com/dotnet/runtime/pull/88650">dotnet/runtime#88650</a> from <a href="https://github.com/khushal1996">@khushal1996</a>.</p><h2 id="base64">Base64</h2><p>An even further constrained subset of text is Base64-encoded data. This is used when arbitrary bytes need to be transferred as text, and results in text that uses only 64 characters (lowercase ASCII letters, uppercase ASCII letters, ASCII digits, ‚Äò+‚Äô, and ‚Äò/‚Äô). .NET has long had methods on <code>System.Convert</code> for encoding and decoding Base64 with UTF16 (<code>char</code>), and it got an additional set of span-based methods in .NET Core 2.1 with the introduction of <code>Span&lt;T&gt;</code>. At that point, the <code>System.Text.Buffers.Base64</code> class was also introduced, with dedicated surface area for encoding and decoding <code>Base64</code> with UTF8 (<code>byte</code>). That‚Äôs now improved further in .NET 8.</p><p><a href="https://github.com/dotnet/runtime/pull/85938">dotnet/runtime#85938</a> from <a href="https://github.com/heathbm">@heathbm</a> and <a href="https://github.com/dotnet/runtime/pull/86396">dotnet/runtime#86396</a> make two contributions here. First, they bring the behavior of the <code>Base64.Decode</code> methods for UTF8 in line with its counterparts on the <code>Convert</code> class, in particular around handling of whitespace. As it‚Äôs very common for there to be newlines in Base64-encoded data, the <code>Convert</code> class‚Äô methods for decoding <code>Base64</code> permitted whitespace; in contrast, the <code>Base64</code> class‚Äô methods for decoding would fail if whitespace was encountered. These decoding methods now permit exactly the same whitespace that <code>Convert</code> does. And that‚Äôs important in part because of the second contribution from these PRs, which is a new set of <code>Base64.IsValid</code> static methods. As with <code>Ascii.IsValid</code> and <code>Utf8.IsValid</code>, these methods simply state whether the supplied UTF8 or UTF16 input represents a valid <code>Base64</code> input, such that the decoding methods on both <code>Convert</code> and <code>Base64</code> could successfully decode it. And as with all such processing we see introduced into .NET, we‚Äôve strived to make the new functionality as efficient as possible so that it can be used to maximal benefit elsewhere. For example, <a href="https://github.com/dotnet/runtime/pull/86221">dotnet/runtime#86221</a> from <a href="https://github.com/WeihanLi">@WeihanLi</a> updated the new <code>Base64Attribute</code> to use it, and <a href="https://github.com/dotnet/runtime/pull/86002">dotnet/runtime#86002</a> updated <code>PemEncoding.TryCountBase64</code> to use it. Here we can see a benchmark comparing the old non-vectorized <code>TryCountBase64</code> with the new version using the vectorized <code>Base64.IsValid</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers.Text;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly string _exampleFromPemEncodingTests =
        &quot;MHQCAQEEICBZ7/8T1JL2amvNB/QShghtgZPtnPD4W+sAcHxA+hJsoAcGBSuBBAAK\n&quot; +
        &quot;oUQDQgAE3yNC5as8JVN5MjF95ofNSgRBVXjf0CKtYESWfPnmvT3n+cMMJUB9lUJf\n&quot; +
        &quot;dkFNgaSB7JlB+krZVVV8T7HZQXVDRA==\n&quot;;

    [Benchmark(Baseline = true)]
    public bool Count_Old() =&gt; TryCountBase64_Old(_exampleFromPemEncodingTests, out _, out _, out _);

    [Benchmark] 
    public bool Count_New() =&gt; TryCountBase64_New(_exampleFromPemEncodingTests, out _, out _, out _);

    private static bool TryCountBase64_New(ReadOnlySpan&lt;char&gt; str, out int base64Start, out int base64End, out int base64DecodedSize)
    {
        int start = 0, end = str.Length - 1;
        for (; start &lt; str.Length &amp;&amp; IsWhiteSpaceCharacter(str[start]); start++) ;
        for (; end &gt; start &amp;&amp; IsWhiteSpaceCharacter(str[end]); end--) ;

        if (Base64.IsValid(str.Slice(start, end + 1 - start), out base64DecodedSize))
        {
            base64Start = start;
            base64End = end + 1;
            return true;
        }

        base64Start = 0;
        base64End = 0;
        return false;
    }

    private static bool TryCountBase64_Old(ReadOnlySpan&lt;char&gt; str, out int base64Start, out int base64End, out int base64DecodedSize)
    {
        base64Start = 0;
        base64End = str.Length;

        if (str.IsEmpty)
        {
            base64DecodedSize = 0;
            return true;
        }

        int significantCharacters = 0;
        int paddingCharacters = 0;

        for (int i = 0; i &lt; str.Length; i++)
        {
            char ch = str[i];

            if (IsWhiteSpaceCharacter(ch))
            {
                if (significantCharacters == 0) base64Start++;
                else base64End--;
                continue;
            }

            base64End = str.Length;

            if (ch == &#39;=&#39;) paddingCharacters++;
            else if (paddingCharacters == 0 &amp;&amp; IsBase64Character(ch)) significantCharacters++;
            else
            {
                base64DecodedSize = 0;
                return false;
            }
        }

        int totalChars = paddingCharacters + significantCharacters;

        if (paddingCharacters &gt; 2 || (totalChars &amp; 0b11) != 0)
        {
            base64DecodedSize = 0;
            return false;
        }

        base64DecodedSize = (totalChars &gt;&gt; 2) * 3 - paddingCharacters;
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool IsBase64Character(char ch) =&gt; char.IsAsciiLetterOrDigit(ch) || ch is &#39;+&#39; or &#39;/&#39;;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool IsWhiteSpaceCharacter(char ch) =&gt; ch is &#39; &#39; or &#39;\t&#39; or &#39;\n&#39; or &#39;\r&#39;;
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Count_Old</td><td style="text-align: right">356.37 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Count_New</td><td style="text-align: right">33.72 ns</td><td style="text-align: right">0.09</td></tr></tbody></table><h2 id="hex">Hex</h2><p>Another relevant subset of ASCII is hexadecimal, and improvements have been made in .NET 8 around conversions between bytes and their representation in hex. In particular, <a href="https://github.com/dotnet/runtime/pull/82521">dotnet/runtime#82521</a> vectorized the <code>Convert.FromHexString</code> method using an algorithm <a href="http://0x80.pl/notesen/2022-01-17-validating-hex-parse.html#algorithm-3-by-geoff-langdale">outlined by Langdale and Mula</a>. On even a moderate length input, this has a very measurable impact on throughput:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Security.Cryptography;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private string _hex;

    [Params(4, 16, 128)]
    public int Length { get; set; }

    [GlobalSetup]
    public void Setup() =&gt; _hex = Convert.ToHexString(RandomNumberGenerator.GetBytes(Length));

    [Benchmark]
    public byte[] ConvertFromHex() =&gt; Convert.FromHexString(_hex);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th>Length</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>ConvertFromHex</td><td>.NET 7.0</td><td>4</td><td style="text-align: right">24.94 ns</td><td style="text-align: right">1.00</td></tr><tr><td>ConvertFromHex</td><td>.NET 8.0</td><td>4</td><td style="text-align: right">20.71 ns</td><td style="text-align: right">0.83</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>ConvertFromHex</td><td>.NET 7.0</td><td>16</td><td style="text-align: right">57.66 ns</td><td style="text-align: right">1.00</td></tr><tr><td>ConvertFromHex</td><td>.NET 8.0</td><td>16</td><td style="text-align: right">17.29 ns</td><td style="text-align: right">0.30</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>ConvertFromHex</td><td>.NET 7.0</td><td>128</td><td style="text-align: right">337.41 ns</td><td style="text-align: right">1.00</td></tr><tr><td>ConvertFromHex</td><td>.NET 8.0</td><td>128</td><td style="text-align: right">56.72 ns</td><td style="text-align: right">0.17</td></tr></tbody></table><p>Of course, the improvements in .NET 8 go well beyond just the manipulation of certain known sets of characters; there is a wealth of other improvements to explore. Let‚Äôs start with <code>System.Text.CompositeFormat</code>, which was introduced in <a href="https://github.com/dotnet/runtime/pull/80753">dotnet/runtime#80753</a>.</p><h2 id="string-formatting">String Formatting</h2><p>Since the beginning of .NET, <code>string</code> and friends have provided APIs for handling composite format strings, strings with text interspersed with format item placeholders, e.g. <code>&quot;The current time is {0:t}&quot;</code>. These strings can then be passed to various APIs, like <code>string.Format</code>, which are provided with both the composite format string and the arguments that should be substituted in for the placeholders, e.g. <code>string.Format(&quot;The current time is {0:t}&quot;, DateTime.Now)</code> will return a string like <code>&quot;The current time is 3:44 PM&quot;</code> (the <code>0</code> in the placeholder indicates the 0-based number of the argument to substitute, and the <code>t</code> is the format that should be used, in this case the <a href="https://learn.microsoft.com/dotnet/standard/base-types/standard-date-and-time-format-strings">standard short time pattern</a>). Such a method invocation needs to parse the composite format string each time it‚Äôs called, even though for a given call site the composite format string typically doesn‚Äôt change from invocation to invocation. These APIs are also generally non-generic, which means if an argument is a value type (as is <code>DateTime</code> in my example), it‚Äôll incur a boxing allocation. To simplify the syntax around these operations, C# 6 gained support for string interpolation, such that instead of writing <code>string.Format(null, &quot;The current time is {0:t}&quot;, DateTime.Now)</code>, you could instead write <code>$&quot;The current time is {DateTime.Now:t}&quot;</code>, and it was then up to the compiler to achieve the same behavior as if <code>string.Format</code> had been used (which the compiler typically achieved simply by lowering the interpolation into a call to <code>string.Format</code>).</p><p>In .NET 6 and C# 10, string interpolation was <a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/">significantly improved</a>, both in terms of the scenarios supported and in terms of its efficiency. One key aspect of the efficiency is it enabled the parsing to be performed once (at compile-time). It also enabled avoiding all of the allocation associated with providing arguments. These improvements contributed to all use of string interpolation and a significant portion of the use of <code>string.Format</code> in real-world applications and services. However, the compiler support works by being able to see the string at compile time. What if the format string isn‚Äôt known until run-time, such as if it‚Äôs pulled from a <code>.resx</code> resource file or some other source of configuration? At that point, <code>string.Format</code> remains the answer.</p><p>Now in .NET 8, there‚Äôs a new answer available: <code>CompositeFormat</code>. Just as an interpolated string allows the compiler to do the heavy lifting once in order to optimize repeated use, <code>CompositeFormat</code> allows that reusable work to be done once in order to optimize repeated use. As it does the parsing at run-time, it‚Äôs able to tackle the remaining cases that string interpolation can‚Äôt reach. To create an instance, one simply calls its <code>Parse</code> method, which takes a composite format string, parses it, and returns a <code>CompositeFormat</code> instance:</p><pre><code class="language-C#">private static readonly CompositeFormat s_currentTimeFormat = CompositeFormat.Parse(SR.CurrentTime);</code></pre><p>Then, existing methods like <code>string.Format</code> now have new overloads, exactly the same as the existing ones, but instead of taking a <code>string format</code>, they take a <code>CompositeFormat format</code>. The same formatting as was done earlier can then instead be done like this:</p><pre><code class="language-C#">string result = string.Format(null, s_currentTimeFormat, DateTime.Now);</code></pre><p>This overload (and other new overloads of methods like <code>StringBuilder.AppendFormat</code> and <code>MemoryExtensions.TryWrite</code>) accepts generic arguments, avoiding the boxing.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private static readonly CompositeFormat s_format = CompositeFormat.Parse(SR.CurrentTime);

    [Benchmark(Baseline = true)]
    public string FormatString() =&gt; string.Format(null, SR.CurrentTime, DateTime.Now);

    [Benchmark]
    public string FormatComposite() =&gt; string.Format(null, s_format, DateTime.Now);
}

internal static class SR
{
    public static string CurrentTime =&gt; /*load from resource file*/&quot;The current time is {0:t}&quot;;
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>FormatString</td><td style="text-align: right">163.6 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">96 B</td><td style="text-align: right">1.00</td></tr><tr><td>FormatComposite</td><td style="text-align: right">146.5 ns</td><td style="text-align: right">0.90</td><td style="text-align: right">72 B</td><td style="text-align: right">0.75</td></tr></tbody></table><p>If you know the composite format string at compile time, interpolated strings are the answer. Otherwise, <code>CompositeFormat</code> can give you throughput in the same ballpark at the expense of some startup costs. Formatting with a <code>CompositeFormat</code> is actually implemented with the same interpolated string handlers that are used for string interpolation, e.g. <code>string.Format(..., compositeFormat, ...)</code> ends up calling into methods on <code>DefaultInterpolatedStringHandler</code> to do the actual formatting work.</p><p>There‚Äôs also a new analyzer to help with this. CA1863 ‚ÄúUse ‚ÄòCompositeFormat'‚Äù was introduced in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6675">dotnet/roslyn-analyzers#6675</a> to identify <code>string.Format</code> and <code>StringBuilder.AppendFormat</code> calls that could possibly benefit from switching to use a <code>CompositeFormat</code> argument instead.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1863.png" alt="CA1863" /></p><h2 id="spans">Spans</h2><p>Moving on from formatting, let‚Äôs turn our attention to all the other kinds of operations one frequently wants to perform on sequences of data, whether that be arrays, strings, or the unifying force of spans. A home for many routines for manipulating all of these, via spans, is the <code>System.MemoryExtensions</code> type, which has received a multitude of new APIs in .NET 8.</p><p>One very common operation is to count how many of something there are. For example, in support of multiline comments, <code>System.Text.Json</code> needs to count how many line feed characters there are in a given piece of JSON. This is, of course, trivial to write as a loop, whether character-by-character or using <code>IndexOf</code> and slicing. Now in .NET 8, you can also just call the <code>Count</code> extension method, thanks to <a href="https://github.com/dotnet/runtime/pull/80662">dotnet/runtime#80662</a> from <a href="https://github.com/bollhals">@bollhals</a> and <a href="https://github.com/dotnet/runtime/pull/82687">dotnet/runtime#82687</a> from <a href="https://github.com/gfoidl">@gfoidl</a>. Here we‚Äôre counting the number of line feed characters in <a href="https://www.gutenberg.org/files/1661/1661-0.txt">‚ÄúThe Adventures of Sherlock Holmes‚Äù</a> from Project Gutenberg:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly byte[] s_utf8 = new HttpClient().GetByteArrayAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    [Benchmark(Baseline = true)]
    public int Count_ForeachLoop()
    {
        int count = 0;
        foreach (byte c in s_utf8)
        {
            if (c == &#39;\n&#39;) count++;
        }
        return count;
    }

    [Benchmark]
    public int Count_IndexOf()
    {
        ReadOnlySpan&lt;byte&gt; remaining = s_utf8;
        int count = 0;

        int pos;
        while ((pos = remaining.IndexOf((byte)&#39;\n&#39;)) &gt;= 0)
        {
            count++;
            remaining = remaining.Slice(pos + 1);
        }

        return count;
    }

    [Benchmark]
    public int Count_Count() =&gt; s_utf8.AsSpan().Count((byte)&#39;\n&#39;);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Count_ForeachLoop</td><td style="text-align: right">314.23 us</td><td style="text-align: right">1.00</td></tr><tr><td>Count_IndexOf</td><td style="text-align: right">95.39 us</td><td style="text-align: right">0.30</td></tr><tr><td>Count_Count</td><td style="text-align: right">13.68 us</td><td style="text-align: right">0.04</td></tr></tbody></table><p>The core of the implementation here that enables <code>MemoryExtensions.Count</code> to be so fast, in particular when searching for a single value, is based on just two key primitives: <code>PopCount</code> and <code>ExtractMostSignificantBits</code>. Here‚Äôs the <code>Vector128</code> loop that forms the bulk of the <code>Count</code> implementation (the implementation has similar loops for <code>Vector256</code> and <code>Vector512</code> as well):</p><pre><code class="language-C#">Vector128&lt;T&gt; targetVector = Vector128.Create(value);
ref T oneVectorAwayFromEnd = ref Unsafe.Subtract(ref end, Vector128&lt;T&gt;.Count);
do
{
    count += BitOperations.PopCount(Vector128.Equals(Vector128.LoadUnsafe(ref current), targetVector).ExtractMostSignificantBits());
    current = ref Unsafe.Add(ref current, Vector128&lt;T&gt;.Count);
}
while (!Unsafe.IsAddressGreaterThan(ref current, ref oneVectorAwayFromEnd));</code></pre><p>This is creating a vector where every element of the vector is the target (in this case, <code>&#39;\n&#39;</code>). Then, as long as there‚Äôs at least one vector‚Äôs worth of data remaining, it loads the next vector (<code>Vector128.LoadUnsafe</code>) and compares that with the target vector (<code>Vector128.Equals</code>). That produces a new <code>Vector128&lt;T&gt;</code> where each <code>T</code> element is all ones when the values are equal and all zeros when they‚Äôre not. We then extract out the most significant bit of each element (<code>ExtractMostSignificantBits</code>), so getting a bit with the value <code>1</code> where the values were equal, otherwise <code>0</code>. And then we use <code>BitOperations.PopCount</code> on the resulting <code>uint</code> to get the ‚Äúpopulation count,‚Äù i.e. the number of bits that are <code>1</code>, and we add that to our running tally. In this way, the inner loop of the count operation remains branch-free, and the implementation can churn through the data very quickly. You can find several examples of using <code>Count</code> in <a href="https://github.com/dotnet/runtime/pull/81325">dotnet/runtime#81325</a>, which used it in several places in the core libraries.</p><p>A similar new <code>MemoryExtensions</code> method is <code>Replace</code>, which comes in .NET 8 in two shapes. <a href="https://github.com/dotnet/runtime/pull/76337">dotnet/runtime#76337</a> from <a href="https://github.com/gfoidl">@gfoidl</a> added an in-place variant:</p><pre><code class="language-C#">public static unsafe void Replace&lt;T&gt;(this Span&lt;T&gt; span, T oldValue, T newValue) where T : IEquatable&lt;T&gt;?;</code></pre><p>and <a href="https://github.com/dotnet/runtime/pull/83120">dotnet/runtime#83120</a> added a copying variant:</p><pre><code class="language-C#">public static unsafe void Replace&lt;T&gt;(this ReadOnlySpan&lt;T&gt; source, Span&lt;T&gt; destination, T oldValue, T newValue) where T : IEquatable&lt;T&gt;?;</code></pre><p>As an example of where this comes in handy, <code>Uri</code> has some code paths that need to normalize directory separators to be <code>&#39;/&#39;</code>, such that any <code>&#39;\\&#39;</code> characters need to be replaced. This previously used an <code>IndexOf</code> loop as was shown in the previous <code>Count</code> benchmark, and now it can just use <code>Replace</code>. Here‚Äôs a comparison (which, purely for benchmarking purposes, is normalizing back and forth so that each time the benchmark runs it finds things in the original state):</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly char[] _uri = &quot;server/somekindofpathneeding/normalizationofitsslashes&quot;.ToCharArray();

    [Benchmark(Baseline = true)]
    public void Replace_ForLoop()
    {
        Replace(_uri, &#39;/&#39;, &#39;\\&#39;);
        Replace(_uri, &#39;\\&#39;, &#39;/&#39;);

        static void Replace(char[] chars, char from, char to)
        {
            for (int i = 0; i &lt; chars.Length; i++)
            {
                if (chars[i] == from)
                {
                    chars[i] = to;
                }
            }
        }
    }

    [Benchmark]
    public void Replace_IndexOf()
    {
        Replace(_uri, &#39;/&#39;, &#39;\\&#39;);
        Replace(_uri, &#39;\\&#39;, &#39;/&#39;);

        static void Replace(char[] chars, char from, char to)
        {
            Span&lt;char&gt; remaining = chars;
            int pos;
            while ((pos = remaining.IndexOf(from)) &gt;= 0)
            {
                remaining[pos] = to;
                remaining = remaining.Slice(pos + 1);
            }
        }
    }

    [Benchmark]
    public void Replace_Replace()
    {
        _uri.AsSpan().Replace(&#39;/&#39;, &#39;\\&#39;);
        _uri.AsSpan().Replace(&#39;\\&#39;, &#39;/&#39;);
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Replace_ForLoop</td><td style="text-align: right">40.28 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Replace_IndexOf</td><td style="text-align: right">29.26 ns</td><td style="text-align: right">0.73</td></tr><tr><td>Replace_Replace</td><td style="text-align: right">18.88 ns</td><td style="text-align: right">0.47</td></tr></tbody></table><p>The new <code>Replace</code> does better than both the manual loop and the <code>IndexOf</code> loop. As with <code>Count</code>, <code>Replace</code> has a fairly simple and tight inner loop; again, here‚Äôs the <code>Vector128</code> variant of that loop:</p><pre><code class="language-C#">do
{
    original = Vector128.LoadUnsafe(ref src, idx);
    mask = Vector128.Equals(oldValues, original);
    result = Vector128.ConditionalSelect(mask, newValues, original);
    result.StoreUnsafe(ref dst, idx);

    idx += (uint)Vector128&lt;T&gt;.Count;
}
while (idx &lt; lastVectorIndex);</code></pre><p>This is loading the next vector‚Äôs worth of data (<code>Vector128.LoadUnsafe</code>) and comparing that with a vector filled with the <code>oldValue</code>, which produces a new <code>mask</code> vector with <code>1</code>s for equality and <code>0</code> for inequality. It then calls the super handy <code>Vector128.ConditionalSelect</code>. This is a branchless SIMD condition operation: it produces a new vector that has an element from one vector if mask‚Äôs bits were <code>1</code>s and from another vector if the mask‚Äôs bits were <code>0</code>s (think a ternary operator). That resulting vector is then saved out as the result. In this manner, it‚Äôs overwriting the whole span, in some cases just writing back the value that was previously there, and in cases where the original value was the target <code>oldValue</code>, writing out the <code>newValue</code> instead. This loop body is branch-free and doesn‚Äôt change in cost based on how many elements need to be replaced. In an extreme case where there‚Äôs nothing to be replaced, an <code>IndexOf</code>-based loop could end up being a tad bit faster, since the body of <code>IndexOf</code>‚Äòs inner loop has even fewer instructions, but such an <code>IndexOf</code> loop pays a relatively high cost for every replacement that needs to be done.</p><p><code>StringBuilder</code> also had such an <code>IndexOf</code>-based implementation for its <code>Replace(char oldChar, char newChar)</code> and <code>Replace(char oldChar, char newChar, int startIndex, int count)</code> methods, and they‚Äôre now based on <code>MemoryExtensions.Replace</code>, so the improvements accrue there as well.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly StringBuilder _sb = new StringBuilder(&quot;http://server\\this\\is\\a\\test\\of\\needing\\to\\normalize\\directory\\separators\\&quot;);

    [Benchmark]
    public void Replace()
    {
        _sb.Replace(&#39;\\&#39;, &#39;/&#39;);
        _sb.Replace(&#39;/&#39;, &#39;\\&#39;);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Replace</td><td>.NET 7.0</td><td style="text-align: right">150.47 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Replace</td><td>.NET 8.0</td><td style="text-align: right">24.79 ns</td><td style="text-align: right">0.16</td></tr></tbody></table><p>Interestingly, whereas <code>StringBuilder.Replace(char, char)</code> was using <code>IndexOf</code> and switched to use <code>Replace</code>, <code>StringBuilder.Replace(string, string)</code> wasn‚Äôt using <code>IndexOf</code> at all, a gap that‚Äôs been fixed in <a href="https://github.com/dotnet/runtime/pull/81098">dotnet/runtime#81098</a>. <code>IndexOf</code> when dealing with strings is more complicated in <code>StringBuilder</code> because of its segmented nature. <code>StringBuilder</code> isn‚Äôt just backed by an array: it‚Äôs actually a linked list of segments, each of which stores an array. With the <code>char</code>-based <code>Replace</code>, it can simply operate on each segment individually, but for the <code>string</code>-based <code>Replace</code>, it needs to deal with the possibility that the value being searched for crosses a segment boundary. <code>StringBuilder.Replace(string, string)</code> was thus walking each segment character-by-character, doing an equality check at each position. Now with this PR, it‚Äôs using <code>IndexOf</code> and only falling back to a character-by-character check when close enough to a segment boundary that it might be crossed.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly StringBuilder _sb = new StringBuilder()
        .Append(&quot;Shall I compare thee to a summer&#39;s day? &quot;)
        .Append(&quot;Thou art more lovely and more temperate: &quot;)
        .Append(&quot;Rough winds do shake the darling buds of May, &quot;)
        .Append(&quot;And summer&#39;s lease hath all too short a date; &quot;)
        .Append(&quot;Sometime too hot the eye of heaven shines, &quot;)
        .Append(&quot;And often is his gold complexion dimm&#39;d; &quot;)
        .Append(&quot;And every fair from fair sometime declines, &quot;)
        .Append(&quot;By chance or nature&#39;s changing course untrimm&#39;d; &quot;)
        .Append(&quot;But thy eternal summer shall not fade, &quot;)
        .Append(&quot;Nor lose possession of that fair thou ow&#39;st; &quot;)
        .Append(&quot;Nor shall death brag thou wander&#39;st in his shade, &quot;)
        .Append(&quot;When in eternal lines to time thou grow&#39;st: &quot;)
        .Append(&quot;So long as men can breathe or eyes can see, &quot;)
        .Append(&quot;So long lives this, and this gives life to thee.&quot;);

    [Benchmark]
    public void Replace()
    {
        _sb.Replace(&quot;summer&quot;, &quot;winter&quot;);
        _sb.Replace(&quot;winter&quot;, &quot;summer&quot;);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Replace</td><td>.NET 7.0</td><td style="text-align: right">5,158.0 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Replace</td><td>.NET 8.0</td><td style="text-align: right">476.4 ns</td><td style="text-align: right">0.09</td></tr></tbody></table><p>As long as we‚Äôre on the subject of <code>StringBuilder</code>, it saw some other nice improvements in .NET 8. <a href="https://github.com/dotnet/runtime/pull/85894">dotnet/runtime#85894</a> from <a href="https://github.com/yesmey">@yesmey</a> tweaked both <code>StringBuilder.Append(string value)</code> and the JIT to enable the JIT to unroll the memory copies that occur as part of appending a constant string.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly StringBuilder _sb = new();

    [Benchmark]
    public void Append()
    {
        _sb.Clear();
        _sb.Append(&quot;This is a test of appending a string to StringBuilder&quot;);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Append</td><td>.NET 7.0</td><td style="text-align: right">7.597 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Append</td><td>.NET 8.0</td><td style="text-align: right">3.756 ns</td><td style="text-align: right">0.49</td></tr></tbody></table><p>And <a href="https://github.com/dotnet/runtime/pull/86287">dotnet/runtime#86287</a> from <a href="https://github.com/yesmey">@yesmey</a> changed <code>StringBuilder.Append(char value, int repeatCount)</code> to use <code>Span&lt;T&gt;.Fill</code> instead of manually looping, taking advantage of the optimized <code>Fill</code> implementation, even for reasonably small counts.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly StringBuilder _sb = new();

    [Benchmark]
    public void Append()
    {
        _sb.Clear();
        _sb.Append(&#39;x&#39;, 8);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Append</td><td>.NET 7.0</td><td style="text-align: right">11.520 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Append</td><td>.NET 8.0</td><td style="text-align: right">5.292 ns</td><td style="text-align: right">0.46</td></tr></tbody></table><p>Back to <code>MemoryExtensions</code>, another new helpful method is <code>MemoryExtensions.Split</code> (and <code>MemoryExtensions.SplitAny</code>). This is a span-based counterpart to <code>string.Split</code> for <em>some</em> uses of <code>string.Split</code>. I say ‚Äúsome‚Äù because there are effectively two main patterns for using <code>string.Split</code>: when you expect a certain number of parts, and when there are an unknown number of parts. For example, if you want to parse a version string as would be used by <code>System.Version</code>, there are at most four parts (‚Äúmajor.minor.build.revision‚Äù). But if you want to split, say, the contents of a file into all of the lines in the file (delimited by a <code>\n</code>), that‚Äôs an unknown (and potentially quite large) number of parts. The new <code>MemoryExtensions.Split</code> method is focused on the situations where there‚Äôs a known (and reasonably small) maximum number of parts expected. In such a case, it can be significantly more efficient than <code>string.Split</code>, especially from an allocation perspective.</p><p><code>string.Split</code> has overloads that accept an <code>int count</code>, and <code>MemoryExtensions.Split</code> behaves identically to these overloads; however, rather than giving it an <code>int count</code>, you give it a <code>Span&lt;Range&gt; destination</code> whose length is the same value you would have used for <code>count</code>. For example, let‚Äôs say you want to split a key/value pair separated by an <code>&#39;=&#39;</code>. If this were <code>string.Split</code>, you could write that as:</p><pre><code class="language-C#">string[] parts = keyValuePair.Split(&#39;=&#39;);</code></pre><p>Of course, if the input was actually erroneous for what you were expecting and there were 100 equal signs, you‚Äôd end up creating an array of 101 strings. So instead, you might write that as:</p><pre><code class="language-C#">string[] parts = keyValuePair.Split(&#39;=&#39;, 3);</code></pre><p>Wait, ‚Äú3‚Äù? Aren‚Äôt there only two parts, and if so, why not pass ‚Äú2‚Äù? Because of the behavior of what happens with the last part. The last part contains the remainder of the string after the separator before it, so for example the call:</p><pre><code class="language-C#">&quot;shall=i=compare=thee&quot;.Split(new[] { &#39;=&#39; }, 2)</code></pre><p>produces the array:</p><pre><code class="language-C#">string[2] { &quot;shall&quot;, &quot;i=compare=thee&quot; }</code></pre><p>If you want to know whether there were more than two parts, you need to request at least one more, and then if that last one was produced, you know the input was erroneous. For example, this:</p><pre><code class="language-C#">&quot;shall=i=compare=thee&quot;.Split(new[] { &#39;=&#39; }, 3)</code></pre><p>produces this:</p><pre><code class="language-C#">string[3] { &quot;shall&quot;, &quot;i&quot;, &quot;compare=thee&quot; }</code></pre><p>and this:</p><pre><code class="language-C#">&quot;shall=i&quot;.Split(new[] { &#39;=&#39; }, 3)</code></pre><p>produces this:</p><pre><code class="language-C#">string[2] { &quot;shall&quot;, &quot;i&quot; }</code></pre><p>We can do the same thing with the new overload, except a) the caller provides the destination span to write the results into, and b) the results are stored as a <code>System.Range</code> rather than as a <code>string</code>. That means that the whole operation is allocation-free. And thanks to the indexer on <code>Span&lt;T&gt;</code> that lets you pass in a <code>Range</code> and slice the span, you can easily use the written ranges to access the relevant portions of the input.</p><pre><code class="language-C#">Span&lt;Range&gt; parts = stackalloc Range[3];
int count = keyValuePairSpan.Split(parts, &#39;=&#39;);
if (count == 2)
{
    Console.WriteLine($&quot;Key={keyValuePairSpan[parts[0]]}, Value={keyValuePairSpan[parts[1]]}&quot;);&quot;
}</code></pre><p>Here‚Äôs an example from <a href="https://github.com/dotnet/runtime/pull/80211">dotnet/runtime#80211</a>, which used <code>SplitAny</code> to reduce the cost of <code>MimeBasePart.DecodeEncoding</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly string _input = &quot;=?utf-8?B?RmlsZU5hbWVf55CG0Y3Qq9C60I5jw4TRicKq0YIM0Y1hSsSeTNCy0Klh?=&quot;;
    private static readonly char[] s_decodeEncodingSplitChars = new char[] { &#39;?&#39;, &#39;\r&#39;, &#39;\n&#39; };

    [Benchmark(Baseline = true)]
    public Encoding Old()
    {
        if (string.IsNullOrEmpty(_input))
        {
            return null;
        }

        string[] subStrings = _input.Split(s_decodeEncodingSplitChars);
        if (subStrings.Length &lt; 5 || 
            subStrings[0] != &quot;=&quot; || 
            subStrings[4] != &quot;=&quot;)
        {
            return null;
        }

        string charSet = subStrings[1];
        return Encoding.GetEncoding(charSet);
    }

    [Benchmark]
    public Encoding New()
    {
        if (string.IsNullOrEmpty(_input))
        {
            return null;
        }

        ReadOnlySpan&lt;char&gt; valueSpan = _input;
        Span&lt;Range&gt; subStrings = stackalloc Range[6];
        if (valueSpan.SplitAny(subStrings, &quot;?\r\n&quot;) &lt; 5 ||
            valueSpan[subStrings[0]] is not &quot;=&quot; ||
            valueSpan[subStrings[4]] is not &quot;=&quot;)
        {
            return null;
        }

        return Encoding.GetEncoding(_input[subStrings[1]]);
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Old</td><td style="text-align: right">143.80 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">304 B</td><td style="text-align: right">1.00</td></tr><tr><td>New</td><td style="text-align: right">94.52 ns</td><td style="text-align: right">0.66</td><td style="text-align: right">32 B</td><td style="text-align: right">0.11</td></tr></tbody></table><p>More examples of <code>MemoryExtensions.Split</code> and <code>MemoryExtensions.SplitAny</code> being used are in <a href="https://github.com/dotnet/runtime/pull/80471">dotnet/runtime#80471</a> and <a href="https://github.com/dotnet/runtime/pull/82007">dotnet/runtime#82007</a>. Both of those remove allocations from various <code>System.Net</code> types that were previously using <code>string.Split</code>.</p><p><code>MemoryExtensions</code> also includes a new set of <code>IndexOf</code> methods for ranges, thanks to <a href="https://github.com/dotnet/runtime/pull/76803">dotnet/runtime#76803</a>:</p><pre><code class="language-C#">public static int IndexOfAnyInRange&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T lowInclusive, T highInclusive) where T : IComparable&lt;T&gt;;
public static int IndexOfAnyExceptInRange&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T lowInclusive, T highInclusive) where T : IComparable&lt;T&gt;;
public static int LastIndexOfAnyInRange&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T lowInclusive, T highInclusive) where T : IComparable&lt;T&gt;;
public static int LastIndexOfAnyExceptInRange&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T lowInclusive, T highInclusive) where T : IComparable&lt;T&gt;;</code></pre><p>Want to find the index of the next ASCII digit? No problem:</p><pre><code class="language-C#">int pos = text.IndexOfAnyInRange(&#39;0&#39;, &#39;9&#39;);</code></pre><p>Want to determine whether some input contains any non-ASCII or control characters? You got it:</p><pre><code class="language-C#">bool nonAsciiOrControlCharacters = text.IndexOfAnyExceptInRange((char)0x20, (char)0x7e);</code></pre><p>For example, <a href="https://github.com/dotnet/runtime/pull/78658">dotnet/runtime#78658</a> uses <code>IndexOfAnyInRange</code> to quickly determine whether portions of a <code>Uri</code> might contain a bidirectional control character, searching for anything in the range <code>[\u200E, \u202E]</code>, and then only examining further if anything in that range is found. And <a href="https://github.com/dotnet/runtime/pull/79357">dotnet/runtime#79357</a> uses <code>IndexOfAnyExceptInRange</code> to determine whether to use <code>Encoding.UTF8</code> or <code>Encoding.ASCII</code>. It was previously implemented with a simple <code>foreach</code> loop, and it‚Äôs now implemented with an even simpler call to <code>IndexOfAnyExceptInRange</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly string _text =
        &quot;Shall I compare thee to a summer&#39;s day? &quot; +
        &quot;Thou art more lovely and more temperate: &quot; +
        &quot;Rough winds do shake the darling buds of May, &quot; +
        &quot;And summer&#39;s lease hath all too short a date; &quot; +
        &quot;Sometime too hot the eye of heaven shines, &quot; +
        &quot;And often is his gold complexion dimm&#39;d; &quot; +
        &quot;And every fair from fair sometime declines, &quot; +
        &quot;By chance or nature&#39;s changing course untrimm&#39;d; &quot; +
        &quot;But thy eternal summer shall not fade, &quot; +
        &quot;Nor lose possession of that fair thou ow&#39;st; &quot; +
        &quot;Nor shall death brag thou wander&#39;st in his shade, &quot; +
        &quot;When in eternal lines to time thou grow&#39;st: &quot; +
        &quot;So long as men can breathe or eyes can see, &quot; +
        &quot;So long lives this, and this gives life to thee.&quot;;

    [Benchmark(Baseline = true)]
    public Encoding Old()
    {
        foreach (char c in _text)
            if (c &gt; 126 || c &lt; 32)
                return Encoding.UTF8;

        return Encoding.ASCII;
    }

    [Benchmark]
    public Encoding New() =&gt;
        _text.AsSpan().IndexOfAnyExceptInRange((char)32, (char)126) &gt;= 0 ?
            Encoding.UTF8 :
            Encoding.ASCII;
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Old</td><td style="text-align: right">297.56 ns</td><td style="text-align: right">1.00</td></tr><tr><td>New</td><td style="text-align: right">20.69 ns</td><td style="text-align: right">0.07</td></tr></tbody></table><p>More of a productivity thing than performance (at least today), but .NET 8 also includes new <code>ContainsAny</code> methods (<a href="https://github.com/dotnet/runtime/pull/87621">dotnet/runtime#87621</a>) that allow writing these kind of <code>IndexOf</code> calls that are then compared against 0 in a slightly cleaner fashion, e.g. the previous example could have been simplified slightly to:</p><pre><code class="language-C#">public Encoding New() =&gt;
    _text.AsSpan().ContainsAnyExceptInRange((char)32, (char)126) ?
        Encoding.UTF8 :
        Encoding.ASCII;</code></pre><p>One of the things I love about these kinds of helpers is that code can simplify down to use them, and then as the helpers improve, so too does the code that relies on them. And in .NET 8, there‚Äôs a lot of ‚Äúthe helpers improve.‚Äù</p><p><a href="https://github.com/dotnet/runtime/pull/86655">dotnet/runtime#86655</a> from <a href="https://github.com/DeepakRajendrakumaran">@DeepakRajendrakumaran</a> added support for <code>Vector512</code> to most of these span-based helpers in <code>MemoryExtensions</code>. That means that when running on hardware which supports AVX512, many of these operations simply get faster. This benchmark uses environment variables to explicitly disable support for the various instruction sets, such that we can compare performance of a given operation when nothing is vectorized, when <code>Vector128</code> is used and hardware accelerated, when <code>Vector256</code> is used and hardware accelerated, and when <code>Vector512</code> is used and hardware accelerated. I‚Äôve run this on my Dev Box that does support AVX512:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Toolchains.CoreRun;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;Scalar&quot;).WithEnvironmentVariable(&quot;DOTNET_EnableHWIntrinsic&quot;, &quot;0&quot;).AsBaseline())
    .AddJob(Job.Default.WithId(&quot;Vector128&quot;).WithEnvironmentVariable(&quot;DOTNET_EnableAVX512F&quot;, &quot;0&quot;).WithEnvironmentVariable(&quot;DOTNET_EnableAVX2&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;Vector256&quot;).WithEnvironmentVariable(&quot;DOTNET_EnableAVX512F&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;Vector512&quot;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;)]
public class Tests
{
    private readonly char[] _sourceChars = Enumerable.Repeat(&#39;a&#39;, 1024).ToArray();

    [Benchmark]
    public bool Contains() =&gt; _sourceChars.AsSpan().IndexOfAny(&#39;b&#39;, &#39;c&#39;) &gt;= 0;
}</code></pre><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Contains</td><td>Scalar</td><td style="text-align: right">491.50 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Contains</td><td>Vector128</td><td style="text-align: right">53.77 ns</td><td style="text-align: right">0.11</td></tr><tr><td>Contains</td><td>Vector256</td><td style="text-align: right">34.75 ns</td><td style="text-align: right">0.07</td></tr><tr><td>Contains</td><td>Vector512</td><td style="text-align: right">21.12 ns</td><td style="text-align: right">0.04</td></tr></tbody></table><p>So, not <em>quite</em> a halving going from 128-bit to 256-bit or another halving going from 256-bit to 512-bit, but pretty close.</p><p><a href="https://github.com/dotnet/runtime/pull/77947">dotnet/runtime#77947</a> vectorized <code>Equals(..., StringComparison.OrdinalIgnoreCase)</code> for large enough inputs (the same underlying implementation is used for both <code>string</code> and <code>ReadOnlySpan&lt;char&gt;</code>). In a loop, it loads the next two vectors. It then checks to see whether anything in those vectors is non-ASCII; it can do so efficiently by OR‚Äôing them together (<code>vec1 | vec2</code>) and then seeing whether the high bit of any of the elements is set‚Ä¶ if none are, then all the elements in both of the input vectors are ASCII (<code>((vec1 | vec2) &amp; Vector128.Create(unchecked((ushort)~0x007F))) == Vector128&lt;ushort&gt;.Zero</code>). If it finds anything non-ASCII, it just continues on with the old mode of comparison. But as long as everything is ASCII, then it can proceed to do the comparison in a vectorized manner. For each vector, it uses some bit hackery to create a lowercased version of the vector, and then compares the lowercased versions for equality.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly string _a = &quot;shall i compare thee to a summer&#39;s day? thou art more lovely and more temperate&quot;;
    private readonly string _b = &quot;SHALL I COMPARE THEE TO A SUMMER&#39;S DAY? THOU ART MORE LOVELY AND MORE TEMPERATE&quot;;

    [Benchmark]
    public bool Equals() =&gt; _a.AsSpan().Equals(_b, StringComparison.OrdinalIgnoreCase);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Equals</td><td>.NET 7.0</td><td style="text-align: right">47.97 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Equals</td><td>.NET 8.0</td><td style="text-align: right">18.93 ns</td><td style="text-align: right">0.39</td></tr></tbody></table><p><a href="https://github.com/dotnet/runtime/pull/78262">dotnet/runtime#78262</a> uses the same tricks to vectorize <code>ToLowerInvariant</code> and <code>ToUpperInvariant</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly string _a = &quot;shall i compare thee to a summer&#39;s day? thou art more lovely and more temperate&quot;;
    private readonly char[] _b = new char[100];

    [Benchmark]
    public int ToUpperInvariant() =&gt; _a.AsSpan().ToUpperInvariant(_b);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>ToUpperInvariant</td><td>.NET 7.0</td><td style="text-align: right">33.22 ns</td><td style="text-align: right">1.00</td></tr><tr><td>ToUpperInvariant</td><td>.NET 8.0</td><td style="text-align: right">16.16 ns</td><td style="text-align: right">0.49</td></tr></tbody></table><p><a href="https://github.com/dotnet/runtime/pull/78650">dotnet/runtime#78650</a> from <a href="https://github.com/yesmey">@yesmey</a> also streamlined <code>MemoryExtensions.Reverse</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly byte[] _bytes = Enumerable.Range(0, 32).Select(i =&gt; (byte)i).ToArray();

    [Benchmark]
    public void Reverse() =&gt; _bytes.AsSpan().Reverse();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Reverse</td><td>.NET 7.0</td><td style="text-align: right">3.801 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Reverse</td><td>.NET 8.0</td><td style="text-align: right">2.052 ns</td><td style="text-align: right">0.54</td></tr></tbody></table><p><a href="https://github.com/dotnet/runtime/pull/75640">dotnet/runtime#75640</a> improves the internal <code>RuntimeHelpers.IsBitwiseEquatable</code> method that‚Äôs used by the vast majority of <code>MemoryExtensions</code>. If you look in the source for <code>MemoryExtensions</code>, you‚Äôll find a fairly common pattern: special-case <code>byte</code>, <code>ushort</code>, <code>uint</code>, and <code>ulong</code> with a vectorized implementation, and then fall back to a general non-vectorized implementation for everything else. Except it‚Äôs not exactly ‚Äúspecial-case <code>byte</code>, <code>ushort</code>, <code>uint</code>, and <code>ulong</code>‚Äú, but rather ‚Äúspecial-case bitwise-equatable types that are the same size as <code>byte</code>, <code>ushort</code>, <code>uint</code>, or <code>ulong</code>.‚Äù If something is ‚Äúbitwise equatable,‚Äù that means we don‚Äôt need to worry about any <code>IEquatable&lt;T&gt;</code> implementation it might provide or any <code>Equals</code> override it might have, and we can instead simply rely on the value‚Äôs bits being the same or different from another value to identify whether the values are the same or different. And if such bitwise equality semantics apply for a type, then the intrinsics that determine equality for <code>byte</code>, <code>ushort</code>, <code>uint</code>, and <code>ulong</code> can be used for any type that‚Äôs 1, 2, 4, or 8 bytes, respectively. In .NET 7, <code>RuntimeHelpers.IsBitwiseEquatable</code> would be true only for a finite and hardcoded list in the runtime: <code>bool</code>, <code>byte</code>, <code>sbyte</code>, <code>char</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>nint</code>, <code>nuint</code>, <code>Rune</code>, and <code>enum</code>s. Now in .NET 8, that list is extended to a dynamically discoverable set where the runtime can easily see that the type itself doesn‚Äôt provide any equality implementation.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private MyColor[] _values1, _values2;

    [GlobalSetup]
    public void Setup()
    {
        _values1 = Enumerable.Range(0, 1_000).Select(i =&gt; new MyColor { R = (byte)i, G = (byte)i, B = (byte)i, A = (byte)i }).ToArray();
        _values2 = (MyColor[])_values1.Clone();
    }

    [Benchmark] public int IndexOf() =&gt; Array.IndexOf(_values1, new MyColor { R = 1, G = 2, B = 3, A = 4 });

    [Benchmark] public bool SequenceEquals() =&gt; _values1.AsSpan().SequenceEqual(_values2);

    struct MyColor { public byte R, G, B, A; }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>IndexOf</td><td>.NET 7.0</td><td style="text-align: right">24,912.42 ns</td><td style="text-align: right">1.000</td><td style="text-align: right">48000 B</td><td style="text-align: right">1.00</td></tr><tr><td>IndexOf</td><td>.NET 8.0</td><td style="text-align: right">70.44 ns</td><td style="text-align: right">0.003</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>SequenceEquals</td><td>.NET 7.0</td><td style="text-align: right">25,041.00 ns</td><td style="text-align: right">1.000</td><td style="text-align: right">48000 B</td><td style="text-align: right">1.00</td></tr><tr><td>SequenceEquals</td><td>.NET 8.0</td><td style="text-align: right">68.40 ns</td><td style="text-align: right">0.003</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>Note this not only means the result gets vectorized, it also ends up avoiding excessive boxing (hence all that allocation), as it‚Äôs no longer calling <code>Equals(object)</code> on each value type instance.</p><p><a href="https://github.com/dotnet/runtime/pull/85437">dotnet/runtime#85437</a> improved the vectorization of <code>IndexOf(string/span, StringComparison.OrdinalIgnoreCase)</code>. Imagine we‚Äôre searching some text for the word ‚Äúelementary.‚Äù In .NET 7, it would end up doing an <code>IndexOfAny(&#39;E&#39;, &#39;e&#39;)</code> in order to find the first possible place ‚Äúelementary‚Äù could match, and would then do the equivalent of a <code>Equals(&quot;elementary&quot;, textAtFoundPosition, StringComparison.OrdinalIgnoreCase)</code>. If the <code>Equals</code> fails, then it loops around to search for the next possible starting location. This is ok if the the characters being searched for are rare, but in this example, <code>&#39;e&#39;</code> is the most common letter in the English alphabet, and so an <code>IndexOfAny(&#39;E&#39;, &#39;e&#39;)</code> is frequently stopping, breaking out of the vectorized inner loop, in order to do the full <code>Equals</code> comparison. In contrast to this, in .NET 7 <code>IndexOf(string/span, StringComparison.Ordinal)</code> was improved using the algorithm <a href="http://0x80.pl/articles/simd-strfind.html#algorithm-1-generic-simd">outlined by Mula</a>; the idea there is that rather than just searching for one character (e.g. the first), you have a vector for another character as well (e.g. the last), you offset them appropriately, and you AND their comparison results together as part of the inner loop. Even if <code>&#39;e&#39;</code> is very common, <code>&#39;e&#39;</code> and then a <code>&#39;y&#39;</code> nine characters later is much, much less common, and thus it can stay in its tight inner loop for longer. Now in .NET 8, we apply the same trick to <code>OrdinalIgnoreCase</code> when we can find two ASCII characters in the input, e.g. it‚Äôll simultaneously search for <code>&#39;E&#39;</code> or <code>&#39;e&#39;</code> followed by a <code>&#39;Y&#39;</code> or <code>&#39;y</code>‚Äò nine characters later.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    private readonly string _needle = &quot;elementary&quot;;

    [Benchmark]
    public int Count()
    {
        ReadOnlySpan&lt;char&gt; haystack = s_haystack;
        ReadOnlySpan&lt;char&gt; needle = _needle;
        int count = 0;

        int pos;
        while ((pos = haystack.IndexOf(needle, StringComparison.OrdinalIgnoreCase)) &gt;= 0)
        {
            count++;
            haystack = haystack.Slice(pos + needle.Length);
        }

        return count;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Count</td><td>.NET 7.0</td><td style="text-align: right">676.91 us</td><td style="text-align: right">1.00</td></tr><tr><td>Count</td><td>.NET 8.0</td><td style="text-align: right">62.04 us</td><td style="text-align: right">0.09</td></tr></tbody></table><p>Even just a simple <code>IndexOf(char)</code> is also significantly improved in .NET 8. Here I‚Äôm searching ‚ÄúThe Adventures of Sherlock Holmes‚Äù for an <code>&#39;@&#39;</code>, which I happen to know doesn‚Äôt appear, such that the entire search will be spent in <code>IndexOf(char)</code>‚Äòs tight inner loop.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    [Benchmark]
    public int IndexOfAt() =&gt; s_haystack.AsSpan().IndexOf(&#39;@&#39;);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>IndexOfAt</td><td>.NET 7.0</td><td style="text-align: right">32.17 us</td><td style="text-align: right">1.00</td></tr><tr><td>IndexOfAt</td><td>.NET 8.0</td><td style="text-align: right">20.84 us</td><td style="text-align: right">0.64</td></tr></tbody></table><p>That improvement is thanks to <a href="https://github.com/dotnet/runtime/pull/78861">dotnet/runtime#78861</a>. The goal of SIMD and vectorization is to do more with the same; rather than processing one thing at a time, process 2 or 4 or 8 or 16 or 32 or 64 things at a time. For <code>char</code>s, which are 16 bits in size, in a 128-bit vector you can process 8 of them at a time; double that for 256-bit, and double it again for 512-bit. But it‚Äôs not just about the size of the vector; you can also find creative ways to use a vector to process more than you otherwise could. For example, in a 128-bit vector, you can process 8 <code>char</code>s at a time‚Ä¶ but you can process 16 <code>byte</code>s at a time. What if you could process the <code>char</code>s instead as <code>byte</code>s? You could of course reinterpret the 8 <code>char</code>s as 16 <code>byte</code>s, but for most algorithms you‚Äôd end up with the wrong answer (since each <code>byte</code> of the <code>char</code> would be treated independently). What if instead you could condense two vectors‚Äô worth of <code>char</code>s down to a single vector of <code>byte</code>, and then do the subsequent processing on that single vector of <code>byte</code>? Then as long as you were doing a few instructions-worth of processing on the <code>byte</code> vector and the cost of that condensing was cheap enough, you could approach doubling your algorithm‚Äôs performance. And that‚Äôs exactly what this PR does, at least for very common needles, and on hardware that supports SSE2. SSE2 has dedicated instructions for taking two vectors and narrowing them down to a single vector, e.g. take a <code>Vector128&lt;short&gt; a</code> and a <code>Vector128&lt;short&gt; b</code>, and combine them into a <code>Vector&lt;byte&gt; c</code> by taking the low <code>byte</code> from each <code>short</code> in the input. However, these particular instructions don‚Äôt simply ignore the other <code>byte</code> in each <code>short</code> completely; instead, they ‚Äúsaturate.‚Äù That means if casting the <code>short</code> value to a <code>byte</code> would overflow, it produces 255, and if it would underflow, it produces 0. That means we can take two vectors of 16-bit values, pack them into a single vector of 8-bit values, and then as long as the thing we‚Äôre searching for is in the range [1, 254], we can be sure that equality checks against the vector will be accurate (comparisons against 0 or 255 might lead to false positives). Note that while Arm does have support for similar ‚Äúnarrowing with saturation,‚Äù the cost of those particular instructions was measured to be high enough that it wasn‚Äôt feasible to use them here (they are used elsewhere). This improvement applies to several other <code>char</code>-based methods as well, including <code>IndexOfAny(char, char)</code> and <code>IndexOfAny(char, char, char)</code>.</p><p>One last <code>Span</code>-centric improvement to highlight. The <code>Memory&lt;T&gt;</code> and <code>ReadOnlyMemory&lt;T&gt;</code> types don‚Äôt implement <code>IEnumerable&lt;T&gt;</code>, but the <code>MemoryMarshal.ToEnumerable</code> method does exist to enable getting an enumerable from them. It‚Äôs buried away in <code>MemoryMarshal</code> primarily so as to guide developers not to iterate through the <code>Memory&lt;T&gt;</code> directly, but to instead iterate through its <code>Span</code>, e.g.</p><pre><code class="language-C#">foreach (T value in memory.Span) { ... }</code></pre><p>The driving force behind this is that the <code>Memory&lt;T&gt;.Span</code> property has some overhead, as a <code>Memory&lt;T&gt;</code> can be backed by multiple different object types (namely a <code>T[]</code>, a <code>string</code> if it‚Äôs a <code>ReadOnlyMemory&lt;char&gt;</code>, or a <code>MemoryManager&lt;T&gt;</code>), and <code>Span</code> needs to fetch a <code>Span&lt;T&gt;</code> for the right one. Even so, from time to time you do actually need an <code>IEnumerable&lt;T&gt;</code> from a <code>{ReadOnly}Memory&lt;T&gt;</code>, and <code>ToEnumerable</code> provides that. In such situations, it‚Äôs actually beneficial from a performance perspective that one doesn‚Äôt just pass the <code>{ReadOnly}Memory&lt;T&gt;</code> as an <code>IEnumerable&lt;T&gt;</code>, since doing so would box the value, and then enumerating that enumerable would require a second allocation for the <code>IEnumerator&lt;T&gt;</code>. In contrast, <code>MemoryMarshal.ToEnumerable</code> can return an <code>IEnumerable&lt;T&gt;</code> instance that is both the <code>IEnumerable&lt;T&gt;</code> and the <code>IEnumerator&lt;T&gt;</code>. In fact, that‚Äôs what it‚Äôs done since it was added, with the entirety of the implementation being:</p><pre><code class="language-C#">public static IEnumerable&lt;T&gt; ToEnumerable&lt;T&gt;(ReadOnlyMemory&lt;T&gt; memory)
{
    for (int i = 0; i &lt; memory.Length; i++)
        yield return memory.Span[i];
}</code></pre><p>The C# compiler generates an <code>IEnumerable&lt;T&gt;</code> for such an iterator that does in fact also implement <code>IEnumerator&lt;T&gt;</code> and return itself from <code>GetEnumerator</code> to avoid an extra allocation, so that‚Äôs good. As noted, though, <code>Memory&lt;T&gt;.Span</code> has some overhead, and this is accessing <code>.Span</code> once per element‚Ä¶ not ideal. <a href="https://github.com/dotnet/runtime/pull/89274">dotnet/runtime#89274</a> addresses this in multiple ways. First, <code>ToEnumerable</code> itself can check the type of the underlying object behind the <code>Memory&lt;T&gt;</code>, and for a <code>T[]</code> or a <code>string</code> can return a different iterator that just directly indexes into the array or string rather than going through <code>.Span</code> on every access. Moreover, <code>ToEnumerable</code> can check to see whether the bounds represented by the <code>Memory&lt;T&gt;</code> are for the full length of the array or string‚Ä¶ if they are, then <code>ToEnumerable</code> can just return the original object, without any additional allocation. The net result is a much more efficient enumeration scheme for anything other than a <code>MemoryManager&lt;T&gt;</code>, which is much more rare (but also not negatively impacted by the improvements for the other types).</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers;
using System.Runtime.InteropServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly Memory&lt;char&gt; _array = Enumerable.Repeat(&#39;a&#39;, 1000).ToArray();

    [Benchmark]
    public int Count() =&gt; Count(MemoryMarshal.ToEnumerable&lt;char&gt;(_array));

    [Benchmark]
    public int CountLINQ() =&gt; Enumerable.Count(MemoryMarshal.ToEnumerable&lt;char&gt;(_array));

    private static int Count&lt;T&gt;(IEnumerable&lt;T&gt; source)
    {
        int count = 0;
        foreach (T item in source) count++;
        return count;
    }

    private sealed class WrapperMemoryManager&lt;T&gt;(Memory&lt;T&gt; memory) : MemoryManager&lt;T&gt;
    {
        public override Span&lt;T&gt; GetSpan() =&gt; memory.Span;
        public override MemoryHandle Pin(int elementIndex = 0) =&gt; throw new NotSupportedException();
        public override void Unpin() =&gt; throw new NotSupportedException();
        protected override void Dispose(bool disposing) { }
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Count</td><td>.NET 7.0</td><td style="text-align: right">6,336.147 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Count</td><td>.NET 8.0</td><td style="text-align: right">1,323.376 ns</td><td style="text-align: right">0.21</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>CountLINQ</td><td>.NET 7.0</td><td style="text-align: right">4,972.580 ns</td><td style="text-align: right">1.000</td></tr><tr><td>CountLINQ</td><td>.NET 8.0</td><td style="text-align: right">9.200 ns</td><td style="text-align: right">0.002</td></tr></tbody></table><h2 id="searchvalues">SearchValues</h2><p>As should be obvious from the length of this document, there are a sheer ton of performance-focused improvements in .NET 8. As I previously noted, I think the most valuable addition in .NET 8 is enabling dynamic PGO by default. After that, I think the next most exciting addition is the new <code>System.Buffers.SearchValues</code> type. It is simply awesome, in my humble opinion.</p><p>Functionally, <code>SearchValues</code> doesn‚Äôt do anything you couldn‚Äôt already do. For example, let‚Äôs say you wanted to search for the next ASCII letter or digit in text. You can already do that via <code>IndexOfAny</code>:</p><pre><code class="language-C#">ReadOnlySpan&lt;char&gt; text = ...;
int pos = text.IndexOfAny(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;);</code></pre><p>And that works, but it hasn‚Äôt been particularly fast. In .NET 7, <code>IndexOfAny(ReadOnlySpan&lt;char&gt;)</code> is optimized for searching for up to 5 target characters, e.g. it could efficiently vectorize a search for English vowels (<code>IndexOfAny(&quot;aeiou&quot;)</code>). But with a target set of 62 characters like in the previous example, it would no longer vectorize, and instead of trying to see how many characters it could process per instruction, switches to trying to see how few instructions it can employ per character (meaning we‚Äôre no longer talking about fractions of an instruction per character in the haystack and now talking about multiple instructions per character in the haystack). It does this via a <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>, referred to in the implementation as a ‚Äúprobabilistic map.‚Äù The idea is to maintain a bitmap of 256 bits. For every needle character, it sets 2 bits in that bitmap. Then when searching the haystack, for each character it looks to see whether both bits are set in the bitmap; if at least one isn‚Äôt set, then this character can‚Äôt be in the needle and the search can continue, but if both bits are in the bitmap, then it‚Äôs likely but not confirmed that the haystack character is in the needle, and the needle is then searched for the character to see whether we‚Äôve found a match.</p><p>There are actually known algorithms for doing these searches more efficiently. For example, the <a href="http://0x80.pl/articles/simd-byte-lookup.html#universal-algorithm">‚ÄúUniversal‚Äù algorithm described by Mula</a> is a great choice when searching for an arbitrary set of ASCII characters, enabling us to efficiently vectorize a search for a needle composed of any subset of ASCII. Doing so requires some amount of computation to analyze the needle and build up the relevant bitmaps and vectors that are required for performing the search, just as we have to do so for the Bloom filter (albeit generating different artifacts). <a href="https://github.com/dotnet/runtime/pull/76740">dotnet/runtime#76740</a> implements these techniques in <code>{Last}IndexOfAny{Except}</code>. Rather than always building up a probabilistic map, it first examines the needle to see if all of the values are ASCII, and if they are, then it switches over to this optimized ASCII-based search; if they‚Äôre not, it falls back to the same probabilistic map approach used previously. The PR also recognizes that it‚Äôs only worth attempting either optimization under the right conditions; if the haystack is really short, for example, we‚Äôre better off just doing the naive <code>O(M*N)</code> search, where for every character in the haystack we search through the needle to see if the <code>char</code> is a target.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    [Benchmark]
    public int CountEnglishVowelsAndSometimeVowels()
    {
        ReadOnlySpan&lt;char&gt; remaining = s_haystack;
        int count = 0, pos;
        while ((pos = remaining.IndexOfAny(&quot;aeiouyAEIOUY&quot;)) &gt;= 0)
        {
            count++;
            remaining = remaining.Slice(pos + 1);
        }

        return count;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>CountEnglishVowelsAndSometimeVowels</td><td>.NET 7.0</td><td style="text-align: right">6.823 ms</td><td style="text-align: right">1.00</td></tr><tr><td>CountEnglishVowelsAndSometimeVowels</td><td>.NET 8.0</td><td style="text-align: right">3.735 ms</td><td style="text-align: right">0.55</td></tr></tbody></table><p>Even with those improvements, this work of building up these vectors is quite repetitive, and it‚Äôs not free. If you have such an <code>IndexOfAny</code> in a loop, you‚Äôre paying to build up those vectors over and over and over again. There‚Äôs also additional work we could do to further examine the data to choose an even more optimal approach, but every additional check performed comes at the cost of more overhead for the <code>IndexOfAny</code> call. This is where <code>SearchValues</code> comes in. The idea behind <code>SearchValues</code> is to perform all this work once and then cache it. Almost invariably, the pattern for using a <code>SearchValues</code> is to create one, store it in a <code>static readonly</code> field, and then use that <code>SearchValues</code> for all searching operations for that target set. And there are now overloads of methods like <code>IndexOfAny</code> that take a <code>SearchValues&lt;char&gt;</code> or <code>SearchValues&lt;byte&gt;</code>, for example, instead of a <code>ReadOnlySpan&lt;char&gt;</code> or <code>ReadOnlySpan&lt;byte&gt;</code>, respectively. Thus, my previous ASCII letter or digit example would instead look like this:</p><pre><code class="language-C#">private static readonly SearchValues&lt;char&gt; s_asciiLettersOrDigits = SearchValues.Create(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;);
...
int pos = text.IndexOfAny(s_asciiLettersOrDigits);</code></pre><p><a href="https://github.com/dotnet/runtime/pull/78093">dotnet/runtime#78093</a> provided the initial implementation of <code>SearchValues</code> (it was originally named <code>IndexOfAnyValues</code>, but we renamed it subsequently to the more general <code>SearchValues</code> so that we can use it now and in the future with other methods, like <code>Count</code> or <code>Replace</code>). If you peruse the implementation, you‚Äôll see that the <code>Create</code> factory methods don‚Äôt just return a concrete <code>SearchValues&lt;T&gt;</code> type; rather, <code>SearchValues&lt;T&gt;</code> provides an internal abstraction that‚Äôs then implemented by more than fifteen derived implementations, each specialized for a different scenario. You can see this fairly easily in code by running the following program:</p><pre><code class="language-C#">// dotnet run -f net8.0

using System.Buffers;

Console.WriteLine(SearchValues.Create(&quot;&quot;));
Console.WriteLine(SearchValues.Create(&quot;a&quot;));
Console.WriteLine(SearchValues.Create(&quot;ac&quot;));
Console.WriteLine(SearchValues.Create(&quot;ace&quot;));
Console.WriteLine(SearchValues.Create(&quot;ab\u05D0\u05D1&quot;));
Console.WriteLine(SearchValues.Create(&quot;abc\u05D0\u05D1&quot;));
Console.WriteLine(SearchValues.Create(&quot;abcdefghijklmnopqrstuvwxyz&quot;));
Console.WriteLine(SearchValues.Create(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;));
Console.WriteLine(SearchValues.Create(&quot;\u00A3\u00A5\u00A7\u00A9\u00AB\u00AD&quot;));
Console.WriteLine(SearchValues.Create(&quot;abc\u05D0\u05D1\u05D2&quot;));</code></pre><p>and you‚Äôll see output like the following:</p><pre><code class="language-text">System.Buffers.EmptySearchValues`1[System.Char]
System.Buffers.SingleCharSearchValues`1[System.Buffers.SearchValues+TrueConst]
System.Buffers.Any2CharSearchValues`1[System.Buffers.SearchValues+TrueConst]
System.Buffers.Any3CharSearchValues`1[System.Buffers.SearchValues+TrueConst]
System.Buffers.Any4SearchValues`2[System.Char,System.Int16]
System.Buffers.Any5SearchValues`2[System.Char,System.Int16]
System.Buffers.RangeCharSearchValues`1[System.Buffers.SearchValues+TrueConst]
System.Buffers.AsciiCharSearchValues`1[System.Buffers.IndexOfAnyAsciiSearcher+Default]
System.Buffers.ProbabilisticCharSearchValues
System.Buffers.ProbabilisticWithAsciiCharSearchValues`1[System.Buffers.IndexOfAnyAsciiSearcher+Default]</code></pre><p>highlighting that each of these different inputs ends up getting mapped to a different <code>SearchValues&lt;T&gt;</code>-derived type.</p><p>After that initial PR, <code>SearchValues</code> has been successively improved and refined. <a href="https://github.com/dotnet/runtime/pull/78863">dotnet/runtime#78863</a>, for example, added AVX2 support, such that with 256-bit vectors being employed (when available) instead of 128-bit vectors, some benchmarks close to doubled in throughput, and <a href="https://github.com/dotnet/runtime/pull/83122">dotnet/runtime#83122</a> enabled WASM support. <a href="https://github.com/dotnet/runtime/pull/78996">dotnet/runtime#78996</a> added a <code>Contains</code> method to be used when implementing scalar fallback paths. And <a href="https://github.com/dotnet/runtime/pull/86046">dotnet/runtime#86046</a> reduced the overhead of calling <code>IndexOfAny</code> with a <code>SearchValues</code> simply by tweaking how the relevant bitmaps and vectors are internally passed around. But two of my favorite tweaks are <a href="https://github.com/dotnet/runtime/pull/82866">dotnet/runtime#82866</a> and <a href="https://github.com/dotnet/runtime/pull/84184">dotnet/runtime#84184</a>, which improve overheads when ‚Äò\0‚Äô (null) is one of the characters in the needle. Why would this matter? Surely searching for ‚Äò\0‚Äô can‚Äôt be so common? Interestingly, in a variety of scenarios it can be. Imagine you have an algorithm that‚Äôs really good at searching for any subset of ASCII, but you want to use it to search for either a specific subset of ASCII <em>or</em> something non-ASCII. If you just search for the subset, you won‚Äôt learn about non-ASCII hits. And if you search for everything other than the subset, you‚Äôll learn about non-ASCII hits but also all the wrong ASCII characters. Instead what you want to do is invert the ASCII subset, e.g. if your target characters are ‚ÄòA‚Äô through ‚ÄòZ‚Äô and ‚Äòa‚Äô through ‚Äòz‚Äô, you instead create the subset including ‚Äò\u0000‚Äô through ‚Äò\u0040‚Äô, ‚Äò\u005B‚Äô through ‚Äò\u0060‚Äô, and ‚Äò\u007B‚Äô through ‚Äò\u007F‚Äô. Then, rather than doing an <code>IndexOfAny</code> with that inverted subset, you instead do <code>IndexOfAnyExcept</code> with that inverted subset; this is a true case of ‚Äútwo wrongs make a right,‚Äù as we‚Äôll end up with our desired behavior of searching for the original subset of ASCII letter plus anything non-ASCII. And as you‚Äôll note, ‚Äò\0‚Äô is in our inverted subset, making the performance when ‚Äò\0‚Äô is in there more important than it otherwise would be.</p><p>Interestingly, the probabilistic map code path in .NET 8 actually also enjoys some amount of vectorization, even without <code>SearchValues</code>, thanks to <a href="https://github.com/dotnet/runtime/pull/80963">dotnet/runtime#80963</a> (it was also further improved in <a href="https://github.com/dotnet/runtime/pull/85189">dotnet/runtime#85189</a> that used better instructions on Arm, and in <a href="https://github.com/dotnet/runtime/pull/85203">dotnet/runtime#85203</a> that avoided some wasted work). That means that whether or not <code>SearchValues</code> is used, searches involving probabilistic map get much faster than in .NET 7. For example, here‚Äôs a benchmark that again searches ‚ÄúThe Adventures of Sherlock Holmes‚Äù and counts the number of line endings in it, using the same needle that <code>string.ReplaceLineEndings</code> uses:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    [Benchmark]
    public int CountLineEndings()
    {
        int count = 0;
        ReadOnlySpan&lt;char&gt; haystack = s_haystack;

        int pos;
        while ((pos = haystack.IndexOfAny(&quot;\n\r\f\u0085\u2028\u2029&quot;)) &gt;= 0)
        {
            count++;
            haystack = haystack.Slice(pos + 1);
        }

        return count;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>CountLineEndings</td><td>.NET 7.0</td><td style="text-align: right">2.155 ms</td><td style="text-align: right">1.00</td></tr><tr><td>CountLineEndings</td><td>.NET 8.0</td><td style="text-align: right">1.323 ms</td><td style="text-align: right">0.61</td></tr></tbody></table><p><code>SearchValues</code> can then be used to improve upon that. It does so not only by caching the probabilistic map that each call to <code>IndexOfAny</code> above needs to recompute, but also by recognizing that when a needle contains ASCII, that‚Äôs a good indication (heuristically) that ASCII haystacks will be prominent. As such, <a href="https://github.com/dotnet/runtime/pull/89155">dotnet/runtime#89155</a> adds a fast path that performs a search for either any of the ASCII needle values or any non-ASCII value, and if it finds a non-ASCII value, then it falls back to performing the vectorized probabilistic map search. </p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;
    private static readonly SearchValues&lt;char&gt; s_lineEndings = SearchValues.Create(&quot;\n\r\f\u0085\u2028\u2029&quot;);

    [Benchmark]
    public int CountLineEndings_Chars()
    {
        int count = 0;
        ReadOnlySpan&lt;char&gt; haystack = s_haystack;

        int pos;
        while ((pos = haystack.IndexOfAny(&quot;\n\r\f\u0085\u2028\u2029&quot;)) &gt;= 0)
        {
            count++;
            haystack = haystack.Slice(pos + 1);
        }

        return count;
    }

    [Benchmark]
    public int CountLineEndings_SearchValues()
    {
        int count = 0;
        ReadOnlySpan&lt;char&gt; haystack = s_haystack;

        int pos;
        while ((pos = haystack.IndexOfAny(s_lineEndings)) &gt;= 0)
        {
            count++;
            haystack = haystack.Slice(pos + 1);
        }

        return count;
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th></tr></thead><tbody><tr><td>CountLineEndings_Chars</td><td style="text-align: right">1,300.3 us</td></tr><tr><td>CountLineEndings_SearchValues</td><td style="text-align: right">430.9 us</td></tr></tbody></table><p><a href="https://github.com/dotnet/runtime/pull/89224">dotnet/runtime#89224</a> further augments that heuristic by guarding that ASCII fast path behind a quick check to see if the very next character is non-ASCII, skipping the ASCII-based search if it is and thereby avoiding the overhead when dealing with an all non-ASCII input. For example, here‚Äôs the result of running the previous benchmark, with the exact same code, except changing the URL to be <code>https://www.gutenberg.org/files/39963/39963-0.txt</code>, which is an almost entirely Greek document containing Aristotle‚Äôs ‚ÄúThe Constitution of the Athenians‚Äù:</p><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th></tr></thead><tbody><tr><td>CountLineEndings_Chars</td><td style="text-align: right">542.6 us</td></tr><tr><td>CountLineEndings_SearchValues</td><td style="text-align: right">283.6 us</td></tr></tbody></table><p>With all of that goodness imbued in <code>SearchValues</code>, it‚Äôs now being used extensively throughout <a href="https://github.com/dotnet/runtime">dotnet/runtime</a>. For example, <code>System.Text.Json</code> previously had its own dedicated implementation of a function <code>IndexOfQuoteOrAnyControlOrBackSlash</code> that it used to search for any character with an ordinal value less than 32, or a quote, or a backslash. That implementation in .NET 7 was <a href="https://github.com/dotnet/runtime/blob/release/7.0/src/libraries/System.Text.Json/src/System/Text/Json/Reader/JsonReaderHelper.cs#L62-L239">~200 lines of complicated <code>Vector&lt;T&gt;</code>-based code</a>. Now in .NET 8 thanks to <a href="https://github.com/dotnet/runtime/pull/82789">dotnet/runtime#82789</a>, it‚Äôs simply this:</p><pre><code class="language-C#">[MethodImpl(MethodImplOptions.AggressiveInlining)]
public static int IndexOfQuoteOrAnyControlOrBackSlash(this ReadOnlySpan&lt;byte&gt; span) =&gt;
    span.IndexOfAny(s_controlQuoteBackslash);

private static readonly SearchValues&lt;byte&gt; s_controlQuoteBackslash = SearchValues.Create(
    &quot;\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\u0008\u0009\u000A\u000B\u000C\u000D\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F&quot;u8 + // Any Control, &lt; 32 (&#39; &#39;)
    &quot;\&quot;&quot;u8 + // Quote
    &quot;\\&quot;u8); // Backslash</code></pre><p>Such use was rolled out in a bunch of PRs, for example <a href="https://github.com/dotnet/runtime/pull/78664">dotnet/runtime#78664</a> that used <code>SearchValues</code> in <code>System.Private.Xml</code>,
<a href="https://github.com/dotnet/runtime/pull/81976">dotnet/runtime#81976</a> in <code>JsonSerializer</code>, <a href="https://github.com/dotnet/runtime/pull/78676">dotnet/runtime#78676</a> in <code>X500NameEncoder</code>, <a href="https://github.com/dotnet/runtime/pull/78667">dotnet/runtime#78667</a> in <code>Regex.Escape</code>, <a href="https://github.com/dotnet/runtime/pull/79025">dotnet/runtime#79025</a> in <code>ZipFile</code> and <code>TarFile</code>,
<a href="https://github.com/dotnet/runtime/pull/79974">dotnet/runtime#79974</a> in <code>WebSocket</code>,
<a href="https://github.com/dotnet/runtime/pull/81486">dotnet/runtime#81486</a> in <code>System.Net.Mail</code>, and <a href="https://github.com/dotnet/runtime/pull/78896">dotnet/runtime#78896</a> in <code>Cookie</code>. <a href="https://github.com/dotnet/runtime/pull/78666">dotnet/runtime#78666</a> and <a href="https://github.com/dotnet/runtime/pull/79024">dotnet/runtime#79024</a> in <code>Uri</code> are particularly nice, including optimizing the commonly-used <code>Uri.EscapeDataString</code> helper with <code>SearchValues</code>; this shows up as a sizable improvement, especially when there‚Äôs nothing to escape.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private string _value = Convert.ToBase64String(&quot;How did I escape? With difficulty. How did I plan this moment? With pleasure. &quot;u8);

    [Benchmark]
    public string EscapeDataString() =&gt; Uri.EscapeDataString(_value);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>EscapeDataString</td><td>.NET 7.0</td><td style="text-align: right">85.468 ns</td><td style="text-align: right">1.00</td></tr><tr><td>EscapeDataString</td><td>.NET 8.0</td><td style="text-align: right">8.443 ns</td><td style="text-align: right">0.10</td></tr></tbody></table><p>All in all, just in <a href="https://github.com/dotnet/runtime">dotnet/runtime</a>, <code>SearchValues.Create</code> is now used in more than 40 places, and that‚Äôs not including all the uses that get generated as part of <code>Regex</code> (more on that in a bit). This is helped along by <a href="https://github.com/dotnet/roslyn-analyzers/pull/6898">dotnet/roslyn-analyzers#6898</a>, which adds a new analyzer that will flag opportunities for <code>SearchValues</code> and update the code to use it:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1870.png" alt="CA1870" /></p><p>Throughout this discussion, I‚Äôve mentioned <code>ReplaceLineEndings</code> several times, using it as an example of the kind of thing that wants to efficiently search for multiple characters. After <a href="https://github.com/dotnet/runtime/pull/78678">dotnet/runtime#78678</a> and <a href="https://github.com/dotnet/runtime/pull/81630">dotnet/runtime#81630</a>, it now also uses <code>SearchValues</code>, plus has been enhanced with other optimizations. Given the discussion of <code>SearchValues</code>, it‚Äôll be obvious how it‚Äôs employed here, at least the basics of it. Previously, <code>ReplaceLineEndings</code> relied on an internal helper <code>IndexOfNewlineChar</code> which did this:</p><pre><code class="language-C#">internal static int IndexOfNewlineChar(ReadOnlySpan&lt;char&gt; text, out int stride)
{
    const string Needles = &quot;\r\n\f\u0085\u2028\u2029&quot;;
    int idx = text.IndexOfAny(needles);
    ...
}</code></pre><p>Now, it does:</p><pre><code class="language-C#">int idx = text.IndexOfAny(SearchValuesStorage.NewLineChars);</code></pre><p>where that <code>NewLineChars</code> is just:</p><pre><code class="language-C#">internal static class SearchValuesStorage
{
    public static readonly SearchValues&lt;char&gt; NewLineChars = SearchValues.Create(&quot;\r\n\f\u0085\u2028\u2029&quot;);
}</code></pre><p>Straightforward. However, it takes things a bit further. Note that there are 6 characters in that list, some of which are ASCII, some of which aren‚Äôt. Knowing the algorithms <code>SearchValues</code> currently employs, we know that this will knock it off the
path of just doing an ASCII search, and it‚Äôll instead use the algorithm that does a search for one of the 3 ASCII characters plus anything non-ASCII, and if it finds anything non-ASCII, will then fallback to doing the probabilistic map search. If we could remove just one of those characters, we‚Äôd be back into the range of just being able to use the <code>IndexOfAny</code> implementation that can work with any 5 characters. On non-Windows systems, we‚Äôre in luck. <code>ReplaceLineEndings</code> by default replaces a line ending with <code>Environment.NewLine</code>; on Windows, that‚Äôs <code>&quot;\r\n&quot;</code>, but on Linux and macOS, that‚Äôs <code>&quot;\n&quot;</code>. If the replacement text is <code>&quot;\n&quot;</code> (which can also be opted-into on Windows by using the <code>ReplaceLineEndings(string replacementText)</code> overload), then searching for <code>&#39;\n&#39;</code> only to replace it with <code>&#39;\n&#39;</code> is a nop, which means we can remove <code>&#39;\n&#39;</code> from the search list when the replacement text is <code>&quot;\n&quot;</code>, bringing us down to only 5 target characters, and giving us a little edge. And while that‚Äôs a nice little gain, the bigger gain is that we won‚Äôt end up breaking out of the vectorized loop as frequently, or at all if all of the line endings are the replacement text. Further, the .NET 7 implementation was always creating a new string to return, but we can avoid allocating it if we didn‚Äôt actually replace anything with anything new. The net result of all of this are huge improvements to <code>ReplaceLineEndings</code>, some due to <code>SearchValues</code> and some beyond.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    // NOTE: This text uses \r\n as its line endings
    private static readonly string s_text = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    [Benchmark]
    [Arguments(&quot;\r\n&quot;)]
    [Arguments(&quot;\n&quot;)]
    public string ReplaceLineEndings(string replacement) =&gt; s_text.ReplaceLineEndings(replacement);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th>replacement</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>ReplaceLineEndings</td><td>.NET 7.0</td><td>\n</td><td style="text-align: right">2,746.3 us</td><td style="text-align: right">1.00</td><td style="text-align: right">1163121 B</td><td style="text-align: right">1.00</td></tr><tr><td>ReplaceLineEndings</td><td>.NET 8.0</td><td>\n</td><td style="text-align: right">995.9 us</td><td style="text-align: right">0.36</td><td style="text-align: right">1163121 B</td><td style="text-align: right">1.00</td></tr><tr><td></td><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>ReplaceLineEndings</td><td>.NET 7.0</td><td>\r\n</td><td style="text-align: right">2,920.1 us</td><td style="text-align: right">1.00</td><td style="text-align: right">1187729 B</td><td style="text-align: right">1.00</td></tr><tr><td>ReplaceLineEndings</td><td>.NET 8.0</td><td>\r\n</td><td style="text-align: right">356.5 us</td><td style="text-align: right">0.12</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>The <code>SearchValue</code> changes also accrue to the span-based non-allocating <code>EnumerateLines</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_text = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    [Benchmark]
    public int CountLines()
    {
        int count = 0;
        foreach (ReadOnlySpan&lt;char&gt; _ in s_text.AsSpan().EnumerateLines()) count++;
        return count;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>CountLines</td><td>.NET 7.0</td><td style="text-align: right">2,029.9 us</td><td style="text-align: right">1.00</td></tr><tr><td>CountLines</td><td>.NET 8.0</td><td style="text-align: right">353.2 us</td><td style="text-align: right">0.17</td></tr></tbody></table><h2 id="regex">Regex</h2><p>Having just examined <code>SearchValues</code>, it‚Äôs a good time to talk about <code>Regex</code>, as the former now plays an integral role in the latter. <code>Regex</code> was significantly improved in <a href="https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/">.NET 5</a>, and then again was overhauled for <a href="https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7/">.NET 7</a>, which saw the introduction of the regex source generator. Now in .NET 8, <code>Regex</code> continues to receive significant investment, in particular this release in taking advantage of much of the work already discussed that was introduced lower in the stack to enable more efficient searching.</p><p>As a reminder, there are effectively three different ‚Äúengines‚Äù within <code>System.Text.RegularExpressions</code>, meaning effectively three different components for actually processing a regex. The simplest engine is the ‚Äúinterpreter‚Äù; the <code>Regex</code> constructor translates the regular expression into a series of <a href="https://github.com/dotnet/runtime/blob/d1fc57ea18ee90aee8690697caed2b9f162409eb/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexOpcode.cs#L23">regex opcodes</a> which the <a href="https://github.com/dotnet/runtime/blob/d1fc57ea18ee90aee8690697caed2b9f162409eb/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexInterpreter.cs#L32">RegexInterpreter</a> then evaluates against the incoming text. This is done in a ‚Äúscan‚Äù loop, which (simplified) looks like this:</p><pre><code class="language-C#">while (TryFindNextStartingPosition(text))
{
    if (TryMatchAtCurrentPosition(text) || _currentPosition == text.Length) break;
    _currentPosition++;
}</code></pre><p><code>TryFindNextStartingPosition</code> tries to move through as much of the input text as possible until it finds a position in the input that could feasibly start a match, and then <code>TryMatchAtCurrentPosition</code> evaluates the pattern at that position against the input. That evaluation in the interpreter involves a loop like this, processing the opcodes that were produced from the pattern:</p><pre><code class="language-C#">while (true)
{
    switch (_opcode)
    {
        case RegexOpcode.Stop:
            return match.FoundMatch;
        case RegexOpcode.Goto:
            Goto(Operand(0));
            continue;
        ... // cases for ~50 other opcodes
    }
}</code></pre><p>Then there‚Äôs the non-backtracking engine, which is what you get when you select the <code>RegexOptions.NonBacktracking</code> option introduced in .NET 7. This engine shares the same <code>TryFindNextStartingPosition</code> implementation as the interpreter, such that all of the optimizations involved in skipping through as much text as possible (ideally via vectorized <code>IndexOf</code> operations) accrue to both the interpreter and the non-backtracking engine. However, that‚Äôs where the similarities end. Rather than processing regex opcodes, the non-backtracking engine works by converting the regular expression pattern into a lazily-constructed deterministic finite automata (DFA) or non-deterministic finite automata (NFA), which it then uses to evaluate the input text. The key benefit of the non-backtracking engine is that it provides linear-time execution guarantees in the length of the input. For a lot more detail, please read <a href="https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7/">Regular Expression Improvements in .NET 7</a>.</p><p>The third engine actually comes in two forms: <code>RegexOptions.Compiled</code> and the regex source generator (introduced in .NET 7). Except for a few corner-cases, these are effectively the same as each other in terms of how they work. They both generate custom code specific to the input pattern provided, with the former generating IL at run-time and the latter generating C# (which is then compiled to IL by the C# compiler) at build-time. The structure of the resulting code, and 99% of the optimizations applied, are identical between them; in fact, in .NET 7, the <a href="https://github.com/dotnet/runtime/blob/d1fc57ea18ee90aee8690697caed2b9f162409eb/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexCompiler.cs#L21"><code>RegexCompiler</code></a> was completely rewritten to be a block-by-block translation of the C# code the regex source generator emits. For both, the actual emitted code is fully customized to the exact pattern supplied, with both trying to generate code that processes the regex as efficiently as possible, and with the source generator trying to do so by generating code that is as close as possible to what an expert .NET developer might write. That‚Äôs in large part because the source it generates is visible, even in Visual Studio live as you edit your pattern:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/GeneratedRegexInVisualStudio.png" alt="GeneratedRegex in Visual Studio" /></p><p>I mention all of this because there is ample opportunity throughout <code>Regex</code>, both in the <code>TryFindNextStartingPosition</code> used by the interpreter and non-backtracking engines and throughout the code generated by <code>RegexCompiler</code> and the regex source generator, to use APIs introduced to make searching faster. I‚Äôm looking at you, <code>IndexOf</code> and friends.</p><p>As noted earlier, new <code>IndexOf</code> variants have been introduced in .NET 8 for searching for ranges, and as of <a href="https://github.com/dotnet/runtime/pull/76859">dotnet/runtime#76859</a>, <code>Regex</code> will now take full advantage of them in generated code. For example, consider <code>[GeneratedRegex(@&quot;[0-9]{5}&quot;)]</code>, which might be used to search for a zip code in the United States. The regex source generator in .NET 7 would emit code for <code>TryFindNextStartingPosition</code> that contained this:</p><pre><code class="language-C#">// The pattern begins with &#39;0&#39; through &#39;9&#39;.
// Find the next occurrence. If it can&#39;t be found, there&#39;s no match.
ReadOnlySpan&lt;char&gt; span = inputSpan.Slice(pos);
for (int i = 0; i &lt; span.Length - 4; i++)
{
    if (char.IsAsciiDigit(span[i]))
    ...
}</code></pre><p>Now in .NET 8, that same attribute instead generates this:</p><pre><code class="language-C#">// The pattern begins with a character in the set [0-9].
// Find the next occurrence. If it can&#39;t be found, there&#39;s no match.
ReadOnlySpan&lt;char&gt; span = inputSpan.Slice(pos);
for (int i = 0; i &lt; span.Length - 4; i++)
{
    int indexOfPos = span.Slice(i).IndexOfAnyInRange(&#39;0&#39;, &#39;9&#39;);
    ...
}</code></pre><p>That .NET 7 implementation is examining one character at a time, whereas the .NET 8 code is vectorizing the search via <code>IndexOfAnyInRange</code>, examining multiple characters at a time. This can lead to significant speedups.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    private readonly Regex _regex = new Regex(&quot;[0-9]{5}&quot;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; _regex.Count(s_haystack);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Count</td><td>.NET 7.0</td><td style="text-align: right">423.88 us</td><td style="text-align: right">1.00</td></tr><tr><td>Count</td><td>.NET 8.0</td><td style="text-align: right">29.91 us</td><td style="text-align: right">0.07</td></tr></tbody></table><p>The generated code can use these APIs in other places as well, even as part of validating the match itself. Let‚Äôs say your pattern was instead <code>[GeneratedRegex(@&quot;(\w{3,})[0-9]&quot;)]</code>, which is going to look for and capture a sequence of at least three word characters that is then followed by an ASCII digit. This is a standard greedy loop, so it‚Äôs going to consume as many word characters as it can (which includes ASCII digits), and will then backtrack, giving back some of the word characters consumed, until it can find a digit. Previously, that was implemented just by giving back a single character, seeing if it was a digit, giving back a single character, seeing if it was a digit, and so on. Now? The source generator emits code that includes this:</p><pre><code class="language-C#">charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, charloop_ending_pos - charloop_starting_pos).LastIndexOfAnyInRange(&#39;0&#39;, &#39;9&#39;)</code></pre><p>In other words, it‚Äôs using <code>LastIndexOfAnyInRange</code> to optimize that backwards search for the next viable backtracking location.</p><p>Another significant improvement that builds on improvements lower in the stack is <a href="https://github.com/dotnet/runtime/pull/85438">dotnet/runtime#85438</a>. As was previously covered, the vectorization of <code>span.IndexOf(&quot;...&quot;, StringComparison.OrdinalIgnoreCase)</code> has been improved in .NET 8. Previously, <code>Regex</code> wasn‚Äôt utilizing this API, as it was often able to do better with its own custom-generated code. But now that the API has been optimized, this PR changes <code>Regex</code> to use it, making the generated code both simpler and faster. Here I‚Äôm searching case-insensitively for the whole word ‚Äúyear‚Äù:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    private readonly Regex _regex = new Regex(@&quot;\byear\b&quot;, RegexOptions.Compiled | RegexOptions.IgnoreCase);

    [Benchmark]
    public int Count() =&gt; _regex.Count(s_haystack);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Count</td><td>.NET 7.0</td><td style="text-align: right">181.80 us</td><td style="text-align: right">1.00</td></tr><tr><td>Count</td><td>.NET 8.0</td><td style="text-align: right">63.10 us</td><td style="text-align: right">0.35</td></tr></tbody></table><p>In addition to learning how to use the existing <code>IndexOf(..., StringComparison.OrdinalIgnoreCase)</code> and the new <code>IndexOfAnyInRange</code> and <code>IndexOfAnyExceptInRange</code>, <code>Regex</code> in .NET 8 also learns how to use the new <code>SearchValues&lt;char&gt;</code>. This is a big boost for <code>Regex</code>, as it now means that it can vectorize searches for many more sets than it previously could. For example, let‚Äôs say you wanted to search for all hex numbers. You might use a pattern like <code>[0123456789ABCDEFabcdef]+</code>. If you plug that into the regex source generator in .NET 7, you‚Äôll get a <code>TryFindNextPossibleStartingPosition</code> emitted that contains code like this:</p><pre><code class="language-C#">// The pattern begins with a character in the set [0-9A-Fa-f].
// Find the next occurrence. If it can&#39;t be found, there&#39;s no match.
ReadOnlySpan&lt;char&gt; span = inputSpan.Slice(pos);
for (int i = 0; i &lt; span.Length; i++)
{
    if (char.IsAsciiHexDigit(span[i]))
    {
        base.runtextpos = pos + i;
        return true;
    }
}</code></pre><p>Now in .NET 8, thanks in large part to <a href="https://github.com/dotnet/runtime/pull/78927">dotnet/runtime#78927</a>, you‚Äôll instead get code like this:</p><pre><code class="language-C#">// The pattern begins with a character in the set [0-9A-Fa-f].
// Find the next occurrence. If it can&#39;t be found, there&#39;s no match.
int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_asciiHexDigits);
if (i &gt;= 0)
{
    base.runtextpos = pos + i;
    return true;
}</code></pre><p>What is that <code>Utilities.s_asciiHexDigits</code>? It‚Äôs a <code>SearchValues&lt;char&gt;</code> emitted into the file‚Äôs <code>Utilities</code> class:</p><pre><code class="language-C#">/// &lt;summary&gt;Supports searching for characters in or not in &quot;0123456789ABCDEFabcdef&quot;.&lt;/summary&gt;
internal static readonly SearchValues&lt;char&gt; s_asciiHexDigits = SearchValues.Create(&quot;0123456789ABCDEFabcdef&quot;);</code></pre><p>The source generator explicitly recognized this set and so created a nice name for it, but that‚Äôs purely about readability; it can still use <code>SearchValues&lt;char&gt;</code> even if it doesn‚Äôt recognize the set as something that‚Äôs well-known and easily nameable. For example, if I instead augment the set to be all valid hex digits and an underscore, I then instead get this:</p><pre><code class="language-C#">/// &lt;summary&gt;Supports searching for characters in or not in &quot;0123456789ABCDEF_abcdef&quot;.&lt;/summary&gt;
internal static readonly SearchValues&lt;char&gt; s_ascii_FF037E0000807E000000 = SearchValues.Create(&quot;0123456789ABCDEF_abcdef&quot;);</code></pre><p>When initially added to <code>Regex</code>, <code>SearchValues&lt;char&gt;</code> was only used when the input set was all ASCII. But as <code>SearchValues&lt;char&gt;</code> improved over the development of .NET 8, so too did <code>Regex</code>‚Äòs use of it. With <a href="https://github.com/dotnet/runtime/pull/89205">dotnet/runtime#89205</a>, <code>Regex</code> now relies on <code>SearchValues</code>‚Äòs ability to efficiently search for both ASCII and non-ASCII, and will similarly emit a <code>SearchValues&lt;char&gt;</code> if it‚Äôs able to efficiently enumerate the contents of a set and that set contains a reasonably small number of characters (today, that means no more than 128). Interestingly, <code>SearchValues</code>‚Äòs optimization to first do a search for the ASCII subset of a target and then fallback to a vectorized probabilistic map search was first prototyped in <code>Regex</code> (<a href="https://github.com/dotnet/runtime/pull/89140">dotnet/runtime#89140</a>), after which we decided to push the optimization downwards into <code>SearchValues</code> so that <code>Regex</code> could generate simpler code and so that other non-<code>Regex</code> consumers would benefit.</p><p>That still, however, leaves the cases where we can‚Äôt efficiently enumerate the set in order to determine every character it includes, nor would we want to pass a gigantic number of characters off to <code>SearchValues</code>. Consider the set <code>\w</code>, i.e. ‚Äúword characters.‚Äù Of the 65,536 <code>char</code> values, 50,409 match the set <code>\w</code>. It would be inefficient to enumerate all of those characters in order to try to create a <code>SearchValues&lt;char&gt;</code> for them, and <code>Regex</code> doesn‚Äôt try. Instead, as of <a href="https://github.com/dotnet/runtime/pull/83992">dotnet/runtime#83992</a>, <code>Regex</code> employs a similar approach as noted above, but with a scalar fallback. For example, for the pattern <code>\w+</code>, it emits the following helper into <code>Utilities</code>:</p><pre><code class="language-C#">internal static int IndexOfAnyWordChar(this ReadOnlySpan&lt;char&gt; span)
{
    int i = span.IndexOfAnyExcept(Utilities.s_asciiExceptWordChars);
    if ((uint)i &lt; (uint)span.Length)
    {
        if (char.IsAscii(span[i]))
        {
            return i;
        }

        do
        {
            if (Utilities.IsWordChar(span[i]))
            {
                return i;
            }
            i++;
        }
        while ((uint)i &lt; (uint)span.Length);
    }

    return -1;
}

/// &lt;summary&gt;Supports searching for characters in or not in &quot;\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\\]^`{|}~\u007f&quot;.&lt;/summary&gt;
internal static readonly SearchValues&lt;char&gt; s_asciiExceptWordChars = SearchValues.Create(&quot;\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\\]^`{|}~\u007f&quot;);</code></pre><p>The fact that it named the helper ‚ÄúIndexOfAnyWordChar‚Äù is, again, separate from the fact that it was able to generate this helper; it simply recognizes the set here as part of determining a name and was able to come up with a nicer one, but if it didn‚Äôt recognize it, the body of the method would be the same and the name would just be less readable, as it would come up with something fairly gibberish but unique.</p><p>As an interesting aside, I noted that the source generator and <code>RegexCompiler</code> are effectively the same, just with one generating C# and one generating IL. That‚Äôs 99% correct. There is one interesting difference around their use of <code>SearchValues</code>, though, one which makes the source generator a bit more efficient in how it‚Äôs able to utilize the type. Any time the source generator needs a <code>SearchValues</code> instance for a new combination of characters, it can just emit another <code>static readonly</code> field for that instance, and because it‚Äôs <code>static readonly</code>, the JIT‚Äôs optimizations around devirtualization and inlining can kick in, with calls to use this seeing the actual type of the instance and optimizing based on that. Yay. <code>RegexCompiler</code> is a different story. <code>RegexCompiler</code> emits IL for a given <code>Regex</code>, and it does so using <code>DynamicMethod</code>; this provides the lightest-weight solution to reflection emit, also allowing the generated methods to be garbage collected when they‚Äôre no longer referenced. <code>DynamicMethod</code>s, however, are just that, methods. There‚Äôs no support for creating additional static fields on demand, without growing up into the much more expensive <code>TypeBuilder</code>-based solution. How then can <code>RegexCompiler</code> create and store an arbitrary number of <code>SearchValue</code> instances, and how can it do so in a way that similarly enables devirtualization? It employs a few tricks. First, a field was added to the internal <code>CompiledRegexRunner</code> type that stores the delegate to the generated method: <code>private readonly SearchValues&lt;char&gt;[]? _searchValues;</code> As an array, this enables any number of <code>SearchValues</code> to be stored; the emitted IL can access the field, grab the array, and index into it to grab the relevant <code>SearchValues&lt;char&gt;</code> instance. Just doing that, of course, would not allow for devirtualization, and even dynamic PGO doesn‚Äôt help here because currently <code>DynamicMethod</code>s don‚Äôt participate in tiering; compilation goes straight to tier 1, so there‚Äôd be no opportunity for instrumentation to see the actual <code>SearchValues&lt;char&gt;</code>-derived type employed. Thankfully, there are available solutions. The JIT can learn about the type of an instance from the type of a local in which it‚Äôs stored, so one solution is to create a local of the concrete and sealed <code>SearchValues&lt;char&gt;</code> derived type (we‚Äôre writing IL at this point, so we can do things like that without actually having access to the type in question), read the <code>SearchValues&lt;char&gt;</code> from the array, store it into the local, and then use the local for the subsequent access. And, in fact, we did that for a while during the .NET 8 development process. However, that does require a local, and requires an extra read/write of that local. Instead, a tweak in <a href="https://github.com/dotnet/runtime/pull/85954">dotnet/runtime#85954</a> allows the JIT to use the <code>T</code> in <code>Unsafe.As&lt;T&gt;(object o)</code> to learn about the actual type of <code>T</code>, and so <code>RegexCompiler</code> can just use <code>Unsafe.As</code> to inform the JIT as to the actual type of the instance such that it‚Äôs then devirtualized. The code <code>RegexCompiler</code> uses then to emit the IL to load a <code>SearchValues&lt;char&gt;</code> is this:</p><pre><code class="language-C#">// from RegexCompiler.cs, tweaked for readability in this post
private void LoadSearchValues(ReadOnlySpan&lt;char&gt; chars)
{
    List&lt;SearchValues&lt;char&gt;&gt; list = _searchValues ??= new();
    int index = list.Count;
    list.Add(SearchValues.Create(chars));

    // Unsafe.As&lt;DerivedSearchValues&gt;(Unsafe.Add(ref MemoryMarshal.GetArrayDataReference(this._searchValues), index));
    _ilg.Emit(OpCodes.Ldarg_0);
    _ilg.Emit(OpCodes.Ldfld, s_searchValuesArrayField);
    _ilg.Emit(OpCodes.Call, s_memoryMarshalGetArrayDataReferenceSearchValues);
    _ilg.Emit(OpCodes.Ldc_I4, index * IntPtr.Size);
    _ilg.Emit(OpCodes.Add);
    _ilg.Emit(OpCodes.Ldind_Ref);
    _ilg.Emit(OpCodes.Call, typeof(Unsafe).GetMethod(&quot;As&quot;, new[] { typeof(object) })!.MakeGenericMethod(list[index].GetType()));
}</code></pre><p>We can see all of this in action with a benchmark like this:</p><pre><code class="language-C#">using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public partial class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    private static readonly Regex s_names = new Regex(&quot;Holmes|Watson|Lestrade|Hudson|Moriarty|Adler|Moran|Morstan|Gregson&quot;, RegexOptions.Compiled);

    [Benchmark]
    public int Count() =&gt; s_names.Count(s_haystack);
}</code></pre><p>Here we‚Äôre searching the same Sherlock Holmes text for the names of some of the most common characters in the detective stories. The regex pattern analyzer will try to find something for which it can vectorize a search, and it will look at all of the characters that can validly exist at each position in a match, e.g. all matches begin with ‚ÄòH‚Äô, ‚ÄòW‚Äô, ‚ÄòL‚Äô, ‚ÄòM‚Äô, ‚ÄòA‚Äô, or ‚ÄòG‚Äô. And since the shortest match is five letters (‚ÄúAdler‚Äù), it‚Äôll end up looking at the first five positions, coming up with these sets:</p><pre><code class="language-text">0: [AGHLMW]
1: [adeoru]
2: [delrst]
3: [aegimst]
4: [aenorst]</code></pre><p>All of those sets have more than five characters in them, though, an important delineation as in .NET 7 that is the largest number of characters for which <code>IndexOfAny</code> will vectorize a search. Thus, in .NET 7, <code>Regex</code> ends up emitting code that walks the input checking character by character (though it does match the set using a fast branch-free bitmap mechanism):</p><pre><code class="language-C#">ReadOnlySpan&lt;char&gt; span = inputSpan.Slice(pos);
for (int i = 0; i &lt; span.Length - 4; i++)
{
    if (((long)((0x8318020000000000UL &lt;&lt; (int)(charMinusLow = (uint)span[i] - &#39;A&#39;)) &amp; (charMinusLow - 64)) &lt; 0) &amp;&amp;
    ...</code></pre><p>Now in .NET 8, with <code>SearchValues&lt;char&gt;</code> we <em>can</em> efficiently search for any of these sets, and the implementation ends up picking the one it thinks is statistically least likely to match:</p><pre><code class="language-C#">int indexOfPos = span.Slice(i).IndexOfAny(Utilities.s_ascii_8231800000000000);</code></pre><p>where that <code>s_ascii_8231800000000000</code> is defined as:</p><pre><code class="language-C#">/// &lt;summary&gt;Supports searching for characters in or not in &quot;AGHLMW&quot;.&lt;/summary&gt;
internal static readonly SearchValues&lt;char&gt; s_ascii_8231800000000000 = SearchValues.Create(&quot;AGHLMW&quot;);</code></pre><p>This leads the overall searching process to be much more efficient.</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Count</td><td>.NET 7.0</td><td style="text-align: right">630.5 us</td><td style="text-align: right">1.00</td></tr><tr><td>Count</td><td>.NET 8.0</td><td style="text-align: right">142.3 us</td><td style="text-align: right">0.23</td></tr></tbody></table><p>Other PRs like <a href="https://github.com/dotnet/runtime/pull/84370">dotnet/runtime#84370</a>, <a href="https://github.com/dotnet/runtime/pull/89099">dotnet/runtime#89099</a>, and <a href="https://github.com/dotnet/runtime/pull/77925">dotnet/runtime#77925</a> have also contributed to how <code>IndexOf</code> and friends are used, tweaking the various heuristics involved. But there have been improvements to <code>Regex</code> as well outside of this realm.
<a href="https://github.com/dotnet/runtime/pull/84003">dotnet/runtime#84003</a>, for example, streamlines the matching performance of <code>\w</code> when matching against non-ASCII characters by using a bit-twiddling trick. And <a href="https://github.com/dotnet/runtime/pull/84843">dotnet/runtime#84843</a> changes the underlying type of an internal enum from <code>int</code> to <code>byte</code>, and in doing so ends up shrinking the size of the object containing a value of this enum by 8 bytes (in a 64-bit process). More impactful is <a href="https://github.com/dotnet/runtime/pull/85564">dotnet/runtime#85564</a>, which makes a measurable improvement for <code>Regex.Replace</code>. <code>Replace</code> was maintaining a list of <code>ReadOnlyMemory&lt;char&gt;</code> segments to be composed back into the final string; some segments would come from the original <code>string</code>, while some would be the replacement <code>string</code>. As it turns out, though, the string reference contained in that <code>ReadOnlyMemory&lt;char&gt;</code> is unnecessary. We can instead just maintain a list of <code>ints</code>, where every time we add a segment we add to the list the <code>int offset</code> and the <code>int count</code>, and with the nature of replace, we can simply rely on the fact that we‚Äôll need to insert the replacement text between every pair of values.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly string s_haystack = new HttpClient().GetStringAsync(&quot;https://www.gutenberg.org/files/1661/1661-0.txt&quot;).Result;

    private static readonly Regex s_vowels = new Regex(&quot;[aeiou]&quot;, RegexOptions.Compiled);

    [Benchmark]
    public string RemoveVowels() =&gt; s_vowels.Replace(s_haystack, &quot;&quot;);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>RemoveVowels</td><td>.NET 7.0</td><td style="text-align: right">8.763 ms</td><td style="text-align: right">1.00</td></tr><tr><td>RemoveVowels</td><td>.NET 8.0</td><td style="text-align: right">7.084 ms</td><td style="text-align: right">0.81</td></tr></tbody></table><p>One last improvement in <code>Regex</code> to highlight isn‚Äôt actually due to anything in <code>Regex</code>, but actually in a primitive <code>Regex</code> uses on every operation: <code>Interlocked.Exchange</code>. Consider this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.RegularExpressions;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly Regex s_r = new Regex(&quot;&quot;, RegexOptions.Compiled);

    [Benchmark]
    public bool Overhead() =&gt; s_r.IsMatch(&quot;&quot;);
}</code></pre><p>This is purely measuring the overhead of calling into a <code>Regex</code> instance; the matching routine will complete immediately as the pattern matches any input. Since we‚Äôre only talking about tens of nanoseconds, your numbers may vary here, but I routinely get results like this:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Overhead</td><td>.NET 7.0</td><td style="text-align: right">32.01 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Overhead</td><td>.NET 8.0</td><td style="text-align: right">28.81 ns</td><td style="text-align: right">0.90</td></tr></tbody></table><p>That several nanosecond improvement is primarily due to <a href="https://github.com/dotnet/runtime/pull/79181">dotnet/runtime#79181</a>, which made <code>Interlocked.CompareExchange</code> and <code>Interlocked.Exchange</code> for reference types into intrinsics, special-casing when the JIT can see that the new value to be written is <code>null</code>. These APIs need to employ a GC write barrier as part of writing the object reference into the shared location, for the same reasons previously discussed earlier in this post, but when writing <code>null</code>, no such barrier is required. This benefits <code>Regex</code>, which uses <code>Interlocked.Exchange</code> as part of renting a <code>RegexRunner</code> to use to actually process the match. Each <code>Regex</code> instance caches a runner object, and every operation tries to rent and return it‚Ä¶ that renting is done with <code>Interlocked.Exchange</code>:</p><pre><code class="language-C#">RegexRunner runner = Interlocked.Exchange(ref _runner, null) ?? CreateRunner();
try { ... }
finally { _runner = runner; }</code></pre><p>Many object pool implementations employ a similar use of <code>Interlocked.Exchange</code> and will similarly benefit.</p><h2 id="hashing">Hashing</h2><p>The <code>System.IO.Hashing</code> library was introduced in .NET 6 to provide <em>non-cryptographic hash algorithm</em> implementations; initially, it shipped with four types: <code>Crc32</code>, <code>Crc64</code>, <code>XxHash32</code>, and <code>XxHash64</code>. In .NET 8, it gets significant investment, in adding new optimized algorithms, in improving the performance of existing implementations, and in adding new surface area across all of the algorithms.</p><p>The xxHash family of hash algorithms has become quite popular of late due to its high performance on both large and small inputs and its overall level of quality (e.g. how few collisions are produced, how well inputs are dispersed, etc.) <code>System.IO.Hashing</code> previously included implementations of the older XXH32 and XXH64 algorithms (as <code>XxHash32</code> and <code>XxHash64</code>, respectively). Now in .NET 8, thanks to <a href="https://github.com/dotnet/runtime/pull/76641">dotnet/runtime#76641</a>, it includes the XXH3 algorithm (as <code>XxHash3</code>), and thanks to <a href="https://github.com/dotnet/runtime/pull/77944">dotnet/runtime#77944</a> from <a href="https://github.com/xoofx">@xoofx</a>, it includes the XXH128 algorithm (as <code>XxHash128</code>). The <code>XxHash3</code> algorithm was also further optimized in <a href="https://github.com/dotnet/runtime/pull/77756">dotnet/runtime#77756</a> from <a href="https://github.com/xoofx">@xoofx</a> by amortizing the costs of some loads and stores, and in <a href="https://github.com/dotnet/runtime/pull/77881">dotnet/runtime#77881</a> from <a href="https://github.com/xoofx">@xoofx</a>, which improved throughput on Arm by making better use of the <code>AdvSimd</code> hardware intrinsics.</p><p>To see overall performance of these hash functions, here‚Äôs a microbenchmark comparing the throughput of the cryptographic SHA256 with each of these non-cryptographic hash functions. I‚Äôve also included an implementation of FNV-1a, which is the hash algorithm that may be used by the C# compiler for <code>switch</code> statements (when it needs to <code>switch</code> over a string, for example, and it can‚Äôt come up with a better scheme, it hashes the input, and then does a binary search through the pregenerated hashes for each of the cases), as well as an implementation based on <code>System.HashCode</code> (noting that <code>HashCode</code> is different from the rest of these, in that it‚Äôs focused on enabling the hashing of arbitrary .NET types, and includes per-process randomization, whereas a goal of these other hash functions is to be 100% deterministic across process boundaries).</p><pre><code class="language-C#">// For this test, you&#39;ll also need to add:
//     &lt;PackageReference Include=&quot;System.IO.Hashing&quot; Version=&quot;8.0.0-rc.1.23419.4&quot; /&gt;
// to the benchmarks.csproj&#39;s &lt;ItemGroup&gt;.
// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Buffers.Binary;
using System.IO.Hashing;
using System.Security.Cryptography;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly byte[] _result = new byte[100];
    private byte[] _source;

    [Params(3, 33_333)]
    public int Length { get; set; }

    [GlobalSetup]
    public void Setup() =&gt; _source = Enumerable.Range(0, Length).Select(i =&gt; (byte)i).ToArray();

    // Cryptographic
    [Benchmark(Baseline = true)] public void TestSHA256() =&gt; SHA256.HashData(_source, _result);

    // Non-cryptographic
    [Benchmark] public void TestCrc32() =&gt; Crc32.Hash(_source, _result);
    [Benchmark] public void TestCrc64() =&gt; Crc64.Hash(_source, _result);
    [Benchmark] public void TestXxHash32() =&gt; XxHash32.Hash(_source, _result);
    [Benchmark] public void TestXxHash64() =&gt; XxHash64.Hash(_source, _result);
    [Benchmark] public void TestXxHash3() =&gt; XxHash3.Hash(_source, _result);
    [Benchmark] public void TestXxHash128() =&gt; XxHash128.Hash(_source, _result);

    // Algorithm used by the C# compiler for switch statements
    [Benchmark]
    public void TestFnv1a()
    {
        int hash = unchecked((int)2166136261);
        foreach (byte b in _source) hash = (hash ^ b) * 16777619;
        BinaryPrimitives.WriteInt32LittleEndian(_result, hash);
    }

    // Randomized with a custom seed per process
    [Benchmark]
    public void TestHashCode()
    {
        HashCode hc = default;
        hc.AddBytes(_source);
        BinaryPrimitives.WriteInt32LittleEndian(_result, hc.ToHashCode());
    }
}</code></pre><table><thead><tr><th>Method</th><th>Length</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>TestSHA256</td><td>3</td><td style="text-align: right">856.168 ns</td><td style="text-align: right">1.000</td></tr><tr><td>TestHashCode</td><td>3</td><td style="text-align: right">9.933 ns</td><td style="text-align: right">0.012</td></tr><tr><td>TestXxHash64</td><td>3</td><td style="text-align: right">7.724 ns</td><td style="text-align: right">0.009</td></tr><tr><td>TestXxHash128</td><td>3</td><td style="text-align: right">5.522 ns</td><td style="text-align: right">0.006</td></tr><tr><td>TestXxHash32</td><td>3</td><td style="text-align: right">5.457 ns</td><td style="text-align: right">0.006</td></tr><tr><td>TestCrc32</td><td>3</td><td style="text-align: right">3.954 ns</td><td style="text-align: right">0.005</td></tr><tr><td>TestCrc64</td><td>3</td><td style="text-align: right">3.405 ns</td><td style="text-align: right">0.004</td></tr><tr><td>TestXxHash3</td><td>3</td><td style="text-align: right">3.343 ns</td><td style="text-align: right">0.004</td></tr><tr><td>TestFnv1a</td><td>3</td><td style="text-align: right">1.617 ns</td><td style="text-align: right">0.002</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>TestSHA256</td><td>33333</td><td style="text-align: right">60,407.625 ns</td><td style="text-align: right">1.00</td></tr><tr><td>TestFnv1a</td><td>33333</td><td style="text-align: right">31,027.249 ns</td><td style="text-align: right">0.51</td></tr><tr><td>TestHashCode</td><td>33333</td><td style="text-align: right">4,879.262 ns</td><td style="text-align: right">0.08</td></tr><tr><td>TestXxHash32</td><td>33333</td><td style="text-align: right">4,444.116 ns</td><td style="text-align: right">0.07</td></tr><tr><td>TestXxHash64</td><td>33333</td><td style="text-align: right">3,636.989 ns</td><td style="text-align: right">0.06</td></tr><tr><td>TestCrc64</td><td>33333</td><td style="text-align: right">1,571.445 ns</td><td style="text-align: right">0.03</td></tr><tr><td>TestXxHash3</td><td>33333</td><td style="text-align: right">1,491.740 ns</td><td style="text-align: right">0.03</td></tr><tr><td>TestXxHash128</td><td>33333</td><td style="text-align: right">1,474.551 ns</td><td style="text-align: right">0.02</td></tr><tr><td>TestCrc32</td><td>33333</td><td style="text-align: right">1,295.663 ns</td><td style="text-align: right">0.02</td></tr></tbody></table><p>A key reason <code>XxHash3</code> and <code>XxHash128</code> do so much better than <code>XxHash32</code> and <code>XxHash64</code> is that their design is focused on being vectorizable. As such, the .NET implementations employ the support in <code>System.Runtime.Intrinsics</code> to take full advantage of the underlying hardware. This data also hints at why the C# compiler uses FNV-1a: it‚Äôs really simple and also really low overhead for small inputs, which are the most common form of input used in <code>switch</code> statements, but it would be a poor choice if you expected primarily longer inputs.</p><p>You‚Äôll note that in the previous example, <code>Crc32</code> and <code>Crc64</code> both end up in the same ballpark as <code>XxHash3</code> in terms of throughput (XXH3 generally ranks better than CRC32/64 in terms of quality). CRC32 in that comparison benefits significantly from <a href="https://github.com/dotnet/runtime/pull/83321">dotnet/runtime#83321</a> from <a href="https://github.com/brantburnett">@brantburnett</a>, <a href="https://github.com/dotnet/runtime/pull/86539">dotnet/runtime#86539</a> from <a href="https://github.com/brantburnett">@brantburnett</a>, and <a href="https://github.com/dotnet/runtime/pull/85221">dotnet/runtime#85221</a> from <a href="https://github.com/brantburnett">@brantburnett</a>. These vectorize the <code>Crc32</code> and <code>Crc64</code> implementations, based on a decade-old paper from Intel titled ‚ÄúFast CRC Computation for Generic Polynomials Using PCLMULQDQ Instruction.‚Äù The cited <code>PCLMULQDQ</code> instruction is part of SSE2, however the PR is also able to vectorize on Arm by taking advantage of Arm‚Äôs <code>PMULL</code> instruction. The net result is huge gains over .NET 7, in particular for larger inputs being hashed.</p><pre><code class="language-C#">// For this test, you&#39;ll also need to add:
//     &lt;PackageReference Include=&quot;System.IO.Hashing&quot; Version=&quot;7.0.0&quot; /&gt;
// to the benchmarks.csproj&#39;s &lt;ItemGroup&gt;.
// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.IO.Hashing;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core70).WithNuGet(&quot;System.IO.Hashing&quot;, &quot;7.0.0&quot;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80).WithNuGet(&quot;System.IO.Hashing&quot;, &quot;8.0.0-rc.1.23419.4&quot;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;NuGetReferences&quot;)]
public class Tests
{
    private readonly byte[] _source = Enumerable.Range(0, 1024).Select(i =&gt; (byte)i).ToArray();
    private readonly byte[] _destination = new byte[4];

    [Benchmark]
    public void Hash() =&gt; Crc32.Hash(_source, _destination);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Hash</td><td>.NET 7.0</td><td style="text-align: right">2,416.24 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Hash</td><td>.NET 8.0</td><td style="text-align: right">39.01 ns</td><td style="text-align: right">0.02</td></tr></tbody></table><p>Another change also further improves performance of some of these algorithms, but with a primary purpose of actually making them easier to use in a variety of scenarios. The original design of <code>NonCryptographicHashAlgorithm</code> was focused on creating non-cryptographic alternatives to the existing cryptographic algorithms folks were using, and thus the APIs are all focused on writing out the resulting digests, which are opaque bytes, e.g. CRC32 produces a 4-byte hash. However, especially for these non-cryptographic algorithms, many developers are more familiar with getting back a numerical result, e.g. CRC32 produces an <code>uint</code>. Same data, just a different representation. Interestingly, as well, some of these algorithms operate in terms of such integers, so getting back bytes actually requires a separate step, both ensuring some kind of storage location is available in which to write the resulting bytes and then extracting the result to that location. To address all of this, <a href="https://github.com/dotnet/runtime/pull/78075">dotnet/runtime#78075</a> adds to all of the types in <code>System.IO.Hashing</code> new utility methods for producing such numbers. For example, <code>Crc32</code> has two new methods added to it:</p><pre><code class="language-C#">public static uint HashToUInt32(ReadOnlySpan&lt;byte&gt; source);
public uint GetCurrentHashAsUInt32();</code></pre><p>If you just want the <code>uint</code>-based CRC32 hash for some input bytes, you can simply call this one-shot static method <code>HashToUInt32</code>. Or if you‚Äôre building up the hash incrementally, having created an instance of the <code>Crc32</code> type and having appended data to it, you can get the current <code>uint</code> hash via <code>GetCurrentHashAsUInt32</code>. This also shaves off a few instructions for an algorithm like <code>XxHash3</code> which actually needs to do more work to produce the result as bytes, only to then need to get those bytes back as a <code>ulong</code>:</p><pre><code class="language-C#">// For this test, you&#39;ll also need to add:
//     &lt;PackageReference Include=&quot;System.IO.Hashing&quot; Version=&quot;8.0.0-rc.1.23419.4&quot; /&gt;
// to the benchmarks.csproj&#39;s &lt;ItemGroup&gt;.
// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.IO.Hashing;
using System.Runtime.InteropServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly byte[] _source = new byte[] { 1, 2, 3 };

    [Benchmark(Baseline = true)]
    public ulong HashToBytesThenGetUInt64()
    {
        ulong hash = 0;
        XxHash3.Hash(_source, MemoryMarshal.AsBytes(new Span&lt;ulong&gt;(ref hash)));
        return hash;
    }

    [Benchmark]
    public ulong HashToUInt64() =&gt; XxHash3.HashToUInt64(_source);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>HashToBytesThenGetUInt64</td><td style="text-align: right">3.686 ns</td><td style="text-align: right">1.00</td></tr><tr><td>HashToUInt64</td><td style="text-align: right">3.095 ns</td><td style="text-align: right">0.84</td></tr></tbody></table><p>Also on the hashing front, <a href="https://github.com/dotnet/runtime/pull/61558">dotnet/runtime#61558</a> from <a href="https://github.com/deeprobin">@deeprobin</a> adds new <code>BitOperations.Crc32C</code> methods that allow for iterative crc32c hash computation. A nice aspect of crc32c is that multiple platforms provide instructions for this operation, including SSE 4.2 and Arm, and the .NET method will employ whatever hardware support is available, by delegating into the relevant hardware intrinsics in <code>System.Runtime.Intrinsics</code>, e.g.</p><pre><code class="language-C#">if (Sse42.X64.IsSupported) return (uint)Sse42.X64.Crc32(crc, data);
if (Sse42.IsSupported) return Sse42.Crc32(Sse42.Crc32(crc, (uint)(data)), (uint)(data &gt;&gt; 32));
if (Crc32.Arm64.IsSupported) return Crc32.Arm64.ComputeCrc32C(crc, data);</code></pre><p>We can see the impact those intrinsics have by comparing a manual implementation of the crc32c algorithm against the now built-in implementation:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Numerics;
using System.Security.Cryptography;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly byte[] _data = RandomNumberGenerator.GetBytes(1024 * 1024);

    [Benchmark(Baseline = true)]
    public uint Crc32c_Manual()
    {
        uint c = 0;
        foreach (byte b in _data) c = Tests.Crc32C(c, b);
        return c;
    }

    [Benchmark]
    public uint Crc32c_BitOperations()
    {
        uint c = 0;
        foreach (byte b in _data) c = BitOperations.Crc32C(c, b);
        return c;
    }

    private static readonly uint[] s_crcTable = Generate(0x82F63B78u);

    internal static uint Crc32C(uint crc, byte data) =&gt;
        s_crcTable[(byte)(crc ^ data)] ^ (crc &gt;&gt; 8);

    internal static uint[] Generate(uint reflectedPolynomial)
    {
        var table = new uint[256];

        for (int i = 0; i &lt; 256; i++)
        {
            uint val = (uint)i;
            for (int j = 0; j &lt; 8; j++)
            {
                if ((val &amp; 0b0000_0001) == 0)
                {
                    val &gt;&gt;= 1;
                }
                else
                {
                    val = (val &gt;&gt; 1) ^ reflectedPolynomial;
                }
            }

            table[i] = val;
        }

        return table;
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Crc32c_Manual</td><td style="text-align: right">1,977.9 us</td><td style="text-align: right">1.00</td></tr><tr><td>Crc32c_BitOperations</td><td style="text-align: right">739.9 us</td><td style="text-align: right">0.37</td></tr></tbody></table><h2 id="initialization">Initialization</h2><p>Several releases ago, the C# compiler added a valuable optimization that‚Äôs now heavily employed throughout the core libraries, and that newer C# constructs (like <code>u8</code>) rely on heavily. It‚Äôs quite common to want to store and access sequences or tables of data in code. For example, let‚Äôs say I want to quickly look up how many days there are in a month in the Gregorian calendar, based on that month‚Äôs 0-based index. I can use a lookup table like this (ignoring leap years for explanatory purposes):</p><pre><code class="language-C#">byte[] daysInMonth = new byte[] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };</code></pre><p>Of course, now I‚Äôm allocating a <code>byte[]</code>, so I should move that out to a <code>static readonly</code> field. Even then, though, that array has to be allocated, and the data loaded into it, incurring some startup overhead the first time it‚Äôs used. Instead, I can write it as:</p><pre><code class="language-C#">ReadOnlySpan&lt;byte&gt; daysInMonth = new byte[] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };</code></pre><p>While this looks like it‚Äôs allocating, it‚Äôs actually not. The C# compiler recognizes that all of the data being used to initialize the <code>byte[]</code> is constant and that the array is being stored directly into a <code>ReadOnlySpan&lt;byte&gt;</code>, which doesn‚Äôt provide any means for extracting the array back out. As such, the compiler instead lowers this into code that effectively does this (we can‚Äôt exactly express in C# the IL that gets generated, so this is pseudo-code):</p><pre><code class="language-C#">ReadOnlySpan&lt;byte&gt; daysInMonth = new ReadOnlySpan&lt;byte&gt;(
    &amp;&lt;PrivateImplementationDetails&gt;.9D61D7D7A1AA7E8ED5214C2F39E0C55230433C7BA728C92913CA4E1967FAF8EA,
    12);</code></pre><p>It blits the data for the array into the assembly, and then constructing the span isn‚Äôt via an array allocation, but rather just wrapping the span around a pointer directly into the assembly‚Äôs data. This not only avoids the startup overhead and the extra object on the heap, it also better enables various JIT optimizations, especially when the JIT is able to see what offset is being accessed. If I run this benchmark:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[DisassemblyDiagnoser]
public class Tests
{
    private static readonly byte[] s_daysInMonthArray = new byte[] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    private static ReadOnlySpan&lt;byte&gt; DaysInMonthSpan =&gt; new byte[] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    [Benchmark] public int ViaArray() =&gt; s_daysInMonthArray[0];

    [Benchmark] public int ViaSpan() =&gt; DaysInMonthSpan[0];
}</code></pre><p>it produces this assembly:</p><pre><code class="language-assembly">; Tests.ViaArray()
       mov       rax,1B860002028
       mov       rax,[rax]
       movzx     eax,byte ptr [rax+10]
       ret
; Total bytes of code 18

; Tests.ViaSpan()
       mov       eax,1F
       ret
; Total bytes of code 6</code></pre><p>In other words, for the array, it‚Äôs reading the address of the array and is then reading the element at offset 0x10, or decimal 16, which is where the array‚Äôs data begins. For the span, it‚Äôs simply loading the value 0x1F, or decimal 31, as it‚Äôs directly reading the data from the assembly data. (This isn‚Äôt a case of a missing optimization in the JIT for the array example‚Ä¶ arrays are mutable, so the JIT can‚Äôt constant fold based on the current value stored in the array, since technically it could change.)</p><p>However, this compiler optimization only applied to <code>byte</code>, <code>sbyte</code>, and <code>bool</code>. Any other primitive, and the compiler would simply do exactly what you asked it to do: allocate the array. Far from ideal. The reason for the limitation was endianness. The compiler needs to generate binaries that work on both little-endian and big-endian systems; for single-byte types, there‚Äôs no endianness concern (since endianness is about the ordering of the bytes, and if there‚Äôs only one byte, there‚Äôs only one ordering), but for multi-byte types, the generated code could no longer just point directly into the data, as on some systems the data‚Äôs bytes would be reversed.</p><p>.NET 7 added a new API to help with this, <code>RuntimeHelpers.CreateSpan&lt;T&gt;</code>. Rather than just emitting <code>new ReadOnlySpan&lt;T&gt;(ptrIntoData, dataLength)</code>, the idea was that the compiler would emit a call to <code>CreateSpan&lt;T&gt;</code>, passing in a reference to the field containing the data. The JIT and VM would then collude to ensure the data was loaded correctly and efficiently; on a little-endian system, the code would be emitted as if the call weren‚Äôt there (replaced by the equivalent of wrapping a span around the pointer and length), and on a big-endian system, the data would be loaded, reversed, and cached into an array, and the code gen would then be creating a span wrapping that array. Unfortunately, although the API shipped in .NET 7, the compiler support for it didn‚Äôt, and because no one was then actually using it, there were a variety of issues in the toolchain that went unnoticed.</p><p>Thankfully, all of these issues are now addressed in .NET 8 and the C# compiler (and also backported to .NET 7). <a href="https://github.com/dotnet/roslyn/pull/61414">dotnet/roslyn#61414</a> added support to the C# compiler for also supporting <code>short</code>, <code>ushort</code>, <code>char</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>double</code>, <code>float</code>, and <code>enum</code>s based on these. On target frameworks where <code>CreateSpan&lt;T&gt;</code> is available (.NET 7+), the compiler generates code that uses it. On frameworks where the function isn‚Äôt available, the compiler falls back to emitting a <code>static readonly</code> array to cache the data and wrapping a span around that. This was an important consideration for libraries that build for multiple target frameworks, so that when building ‚Äúdownlevel‚Äù, the implementation doesn‚Äôt fall off the proverbial performance cliff due to relying on this optimization (this optimization is a bit of an oddity, as you actually need to write your code in a way that, without the optimization, ends up performing worse than what you would have otherwise had). With the compiler implementation in place, and fixes to the Mono runtime in <a href="https://github.com/dotnet/runtime/pull/82093">dotnet/runtime#82093</a> and <a href="https://github.com/dotnet/runtime/pull/81695">dotnet/runtime#81695</a>, and with fixes to the trimmer (which needs to preserve the alignment of the data that‚Äôs emitted by the compiler) in <a href="https://github.com/dotnet/cecil/pull/60">dotnet/cecil#60</a>, the rest of the runtime was then able to consume the feature, which it did in <a href="https://github.com/dotnet/runtime/pull/79461">dotnet/runtime#79461</a>. So now, for example, <code>System.Text.Json</code> can use this to store not only how many days there are in a (non-leap) year, but also store how many days there are before a given month, something that wasn‚Äôt previously possible efficiently in this form due to there being values larger than can be stored in a <code>byte</code>.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter **

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;i&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
[DisassemblyDiagnoser]
public class Tests
{
    private static ReadOnlySpan&lt;int&gt; DaysToMonth365 =&gt; new int[] { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };

    [Benchmark]
    [Arguments(1)]
    public int DaysToMonth(int i) =&gt; DaysToMonth365[i];
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Code Size</th><th style="text-align: right">Allocated</th></tr></thead><tbody><tr><td>DaysToMonth</td><td style="text-align: right">0.0469 ns</td><td style="text-align: right">35 B</td><td style="text-align: right">‚Äì</td></tr></tbody></table><pre><code class="language-assembly">; Tests.DaysToMonth(Int32)
       sub       rsp,28
       cmp       edx,0D
       jae       short M00_L00
       mov       eax,edx
       mov       rcx,12B39072DD0
       mov       eax,[rcx+rax*4]
       add       rsp,28
       ret
M00_L00:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 35</code></pre><p><a href="https://github.com/dotnet/roslyn/pull/69820">dotnet/roslyn#69820</a> (which hasn‚Äôt yet merged but should soon) then rounds things out by ensuring that the pattern of initializing a <code>ReadOnlySpan&lt;T&gt;</code> to a <code>new T[] { const of T, const of T, ... /* all const values */ }</code> will always avoid the array allocation, regardless of the type of <code>T</code> being used. The <code>T</code> need only be expressible as a constant in C#. That means this optimization now also applies to <code>string</code>, <code>decimal</code>, <code>nint</code>, and <code>nuint</code>. For these, the compiler will fallback to using a cached array singleton. With that, this code:</p><pre><code class="language-C#">// dotnet build -c Release -f net8.0

internal static class Program
{
    private static void Main() { }

    private static ReadOnlySpan&lt;bool&gt; Booleans =&gt; new bool[] { false, true };
    private static ReadOnlySpan&lt;sbyte&gt; SBytes =&gt; new sbyte[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;byte&gt; Bytes =&gt; new byte[] { 0, 1, 2 };

    private static ReadOnlySpan&lt;short&gt; Shorts =&gt; new short[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;ushort&gt; UShorts =&gt; new ushort[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;char&gt; Chars =&gt; new char[] { &#39;0&#39;, &#39;1&#39;, &#39;2&#39; };
    private static ReadOnlySpan&lt;int&gt; Ints =&gt; new int[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;uint&gt; UInts =&gt; new uint[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;long&gt; Longs =&gt; new long[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;ulong&gt; ULongs =&gt; new ulong[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;float&gt; Floats =&gt; new float[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;double&gt; Doubles =&gt; new double[] { 0, 1, 2 };

    private static ReadOnlySpan&lt;nint&gt; NInts =&gt; new nint[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;nuint&gt; NUInts =&gt; new nuint[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;decimal&gt; Decimals =&gt; new decimal[] { 0, 1, 2 };
    private static ReadOnlySpan&lt;string&gt; Strings =&gt; new string[] { &quot;0&quot;, &quot;1&quot;, &quot;2&quot; };
}</code></pre><p>now compiles down to something like this (again, this is pseudo-code, since we can‚Äôt exactly represent in C# what‚Äôs emitted in IL):</p><pre><code class="language-C#">internal static class Program
{
    private static void Main() { }

    //
    // No endianness concerns. Create a span that points directly into the assembly data,
    // using the `ReadOnlySpan&lt;T&gt;(void*, int)` constructor.
    //

    private static ReadOnlySpan&lt;bool&gt; Booleans =&gt; new ReadOnlySpan&lt;bool&gt;(
        &amp;&lt;PrivateImplementationDetails&gt;.B413F47D13EE2FE6C845B2EE141AF81DE858DF4EC549A58B7970BB96645BC8D2, 2);

    private static ReadOnlySpan&lt;sbyte&gt; SBytes =&gt; new ReadOnlySpan&lt;sbyte&gt;(
        &amp;&lt;PrivateImplementationDetails&gt;.AE4B3280E56E2FAF83F414A6E3DABE9D5FBE18976544C05FED121ACCB85B53FC, 3);

    private static ReadOnlySpan&lt;byte&gt; Bytes =&gt; new ReadOnlySpan&lt;byte&gt;(
        &amp;&lt;PrivateImplementationDetails&gt;.AE4B3280E56E2FAF83F414A6E3DABE9D5FBE18976544C05FED121ACCB85B53FC, 3);

    //
    // Endianness concerns but with data that a span could point to directly if
    // of the correct byte ordering. Go through the RuntimeHelpers.CreateSpan intrinsic.
    //

    private static ReadOnlySpan&lt;short&gt; Shorts =&gt; RuntimeHelpers.CreateSpan&lt;short&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.90C2698921CA9FD02950BE353F721888760E33AB5095A21E50F1E4360B6DE1A02);

    private static ReadOnlySpan&lt;ushort&gt; UShorts =&gt; RuntimeHelpers.CreateSpan&lt;ushort&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.90C2698921CA9FD02950BE353F721888760E33AB5095A21E50F1E4360B6DE1A02);

    private static ReadOnlySpan&lt;char&gt; Chars =&gt; RuntimeHelpers.CreateSpan&lt;char&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.9B9A3CBF2B718A8F94CE348CB95246738A3A9871C6236F4DA0A7CC126F03A8B42);

    private static ReadOnlySpan&lt;int&gt; Ints =&gt; RuntimeHelpers.CreateSpan&lt;int&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.AD5DC1478DE06A4C2728EA528BD9361A4B945E92A414BF4D180CEDAAEAA5F4CC4);

    private static ReadOnlySpan&lt;uint&gt; UInts =&gt; RuntimeHelpers.CreateSpan&lt;uint&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.AD5DC1478DE06A4C2728EA528BD9361A4B945E92A414BF4D180CEDAAEAA5F4CC4);

    private static ReadOnlySpan&lt;long&gt; Longs =&gt; RuntimeHelpers.CreateSpan&lt;long&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.AB25350E3E65EFEBE24584461683ECDA68725576E825E550038B90E7B14799468);

    private static ReadOnlySpan&lt;ulong&gt; ULongs =&gt; RuntimeHelpers.CreateSpan&lt;ulong&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.AB25350E3E65EFEBE24584461683ECDA68725576E825E550038B90E7B14799468);

    private static ReadOnlySpan&lt;float&gt; Floats =&gt; RuntimeHelpers.CreateSpan&lt;float&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.75664B4DA1C08DE9E8FAD52303CC458B3E420EDDE6591E58761E138CC5E3F1634);

    private static ReadOnlySpan&lt;double&gt; Doubles =&gt; RuntimeHelpers.CreateSpan&lt;double&gt;((RuntimeFieldHandle)
        &amp;&lt;PrivateImplementationDetails&gt;.B0C45303F7F11848CB5E6E5B2AF2FB2AECD0B72C28748B88B583AB6BB76DF1748);

    //
    // Create a span around a cached array.
    //

    private unsafe static ReadOnlySpan&lt;nuint&gt; NUInts =&gt; new ReadOnlySpan&lt;nuint&gt;(
        &lt;PrivateImplementationDetails&gt;.AD5DC1478DE06A4C2728EA528BD9361A4B945E92A414BF4D180CEDAAEAA5F4CC_B16
            ??= new nuint[] { 0, 1, 2 });

    private static ReadOnlySpan&lt;nint&gt; NInts =&gt; new ReadOnlySpan&lt;nint&gt;(
        &lt;PrivateImplementationDetails&gt;.AD5DC1478DE06A4C2728EA528BD9361A4B945E92A414BF4D180CEDAAEAA5F4CC_B8
            ??= new nint[] { 0, 1, 2 });

    private static ReadOnlySpan&lt;decimal&gt; Decimals =&gt; new ReadOnlySpan&lt;decimal&gt;(
        &lt;PrivateImplementationDetails&gt;.93AF9093EDC211A9A941BDE5EF5640FD395604257F3D945F93C11BA9E918CC74_B18
            ??= new decimal[] { 0, 1, 2 });

    private static ReadOnlySpan&lt;string&gt; Strings =&gt; new ReadOnlySpan&lt;string&gt;(
        &lt;PrivateImplementationDetails&gt;.9B9A3CBF2B718A8F94CE348CB95246738A3A9871C6236F4DA0A7CC126F03A8B4_B11
            ??= new string[] { &quot;0&quot;, &quot;1&quot;, &quot;2&quot; });
}</code></pre><p>Another closely-related C# compiler improvement comes in <a href="https://github.com/dotnet/roslyn/pull/66251">dotnet/runtime#66251</a> from <a href="https://github.com/alrz">@alrz</a>. The previously mentioned optimization around single-byte types also applies to <code>stackalloc</code> initialization. If I write:</p><pre><code class="language-C#">Span&lt;int&gt; span = stackalloc int[] { 1, 2, 3 };</code></pre><p>the C# compiler emits code similar to if I‚Äôd written the following:</p><pre><code class="language-C#">byte* ptr = stackalloc byte[12];
*(int*)ptr = 1;
*(int*)(ptr) = 2;
*(int*)(ptr + (nint)2 * (nint)4) = 3;
Span&lt;int&gt; span = new Span&lt;int&gt;(ptr);</code></pre><p>If, however, I switch from the multi-byte <code>int</code> to the single-byte <code>byte</code>:</p><pre><code class="language-C#">Span&lt;byte&gt; span = stackalloc byte[] { 1, 2, 3 };</code></pre><p>then I get something closer to this:</p><pre><code class="language-C#">byte* ptr = stackalloc byte[3];
Unsafe.CopyBlock(ptr, ref &lt;PrivateImplementationDetails&gt;.039058C6F2C0CB492C533B0A4D14EF77CC0F78ABCCCED5287D84A1A2011CFB81, 3); // actually the cpblk instruction
Span&lt;byte&gt; span = new Span&lt;byte&gt;(ptr, 3);</code></pre><p>Unlike the the <code>new[]</code> case, however, which optimized not only for <code>byte</code>, <code>sbyte</code>, and <code>bool</code> but also for <code>enum</code>s with <code>byte</code> and <code>sbyte</code> as an underlying type, the <code>stackalloc</code> optimization didn‚Äôt. Thanks to this PR, it now does.</p><p>There‚Äôs another semi-related new feature spanning C# 12 and .NET 8: <code>InlineArrayAttribute</code>. <code>stackalloc</code> has long provided a way to use stack space as a buffer, rather than needing to allocate memory on the heap; however, for most of .NET‚Äôs history, this was ‚Äúunsafe,‚Äù in that it produced a pointer:</p><pre><code class="language-C#">byte* buffer = stackalloc byte[8];</code></pre><p>C# 7.2 introduced the immensely useful improvement to stack allocate directly into a span, at which point it becomes ‚Äúsafe,‚Äù not requiring being in an <code>unsafe</code> context and with all access to the span bounds checked appropriately, as with any other span:</p><pre><code class="language-C#">Span&lt;byte&gt; buffer = stackalloc byte[8];</code></pre><p>The C# compiler will lower that to something along the lines of:</p><pre><code class="language-C#">Span&lt;byte&gt; buffer;
unsafe
{
    byte* tmp = stackalloc byte[8];
    buffer = new Span&lt;byte&gt;(tmp, 8);
}</code></pre><p>However, this is still limited to the kinds of things that can be <code>stackalloc</code>‚Äòd, namely <code>unmanaged</code> types (types which don‚Äôt contain any managed references), and it‚Äôs limited in where it can be used. That‚Äôs not only because <code>stackalloc</code> can‚Äôt be used in places like <code>catch</code> and <code>finally</code> blocks, but also because there are places where you want to be able to have such buffers that aren‚Äôt limited to the stack: inside of other types. C# has long supported the notion of ‚Äúfixed-size buffers,‚Äù e.g.</p><pre><code class="language-C#">struct C
{
    internal unsafe fixed char name[30];
}</code></pre><p>but these require being in an <code>unsafe</code> context since they present to a consumer as a pointer (in the above example, the type of <code>C.name</code> is a <code>char*</code>) and they‚Äôre not bounds-checked, and they‚Äôre limited in the element type supported (it can only be <code>bool</code>, <code>sbyte</code>, <code>byte</code>, <code>short</code>, <code>ushort</code>, <code>char</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>double</code>, or <code>float</code>).</p><p>.NET 8 and C# 12 provide an answer for this: <code>[InlineArray]</code>. This new attribute can be placed onto a <code>struct</code> containing a single field, like this:</p><pre><code class="language-C#">[InlineArray(8)]
internal struct EightStrings
{
    private string _field;
}</code></pre><p>The runtime then expands that struct to be logically the same as if you wrote:</p><pre><code class="language-C#">internal struct EightStrings
{
    private string _field0;
    private string _field1;
    private string _field2;
    private string _field3;
    private string _field4;
    private string _field5;
    private string _field6;
    private string _field7;
}</code></pre><p>ensuring that all of the storage is appropriately contiguous and aligned. Why is that important? Because C# 12 then makes it easy to get a span from one of these instances, e.g.</p><pre><code class="language-C#">EightStrings strings = default;
Span&lt;string&gt; span = strings;</code></pre><p>This is all ‚Äúsafe,‚Äù and the type of the field can be anything that‚Äôs valid as a generic type argument. That means pretty much anything other than <code>ref</code>s, <code>ref struct</code>s, and pointers. This is a constraint imposed by the C# language, since with such a field type <code>T</code> you wouldn‚Äôt be able to construct a <code>Span&lt;T&gt;</code>, but the warning can be suppressed, as the runtime itself does support anything as the field type. The compiler-generated code for getting a span is equivalent to if you wrote:</p><pre><code class="language-C#">EightStrings strings = default;
Span&lt;string&gt; span = MemoryMarshal.CreateSpan(ref Unsafe.As&lt;EightStrings, string&gt;(ref strings), 8);</code></pre><p>which is obviously complicated and not something you‚Äôd want to be writing frequently. In fact, the compiler doesn‚Äôt want to emit that frequently, either, so it puts it into a helper in the assembly that it can reuse.</p><pre><code class="language-C#">[CompilerGenerated]
internal sealed class &lt;PrivateImplementationDetails&gt;
{
    internal static Span&lt;TElement&gt; InlineArrayAsSpan&lt;TBuffer, TElement&gt;(ref TBuffer buffer, int length) =&gt;
        MemoryMarshal.CreateSpan(ref Unsafe.As&lt;TBuffer, TElement&gt;(ref buffer), length);
    ...
}</code></pre><p>(<code>&lt;PrivateImplementationDetails&gt;</code> is a class the C# compiler emits to contain helpers and other compiler-generated artifacts used by code it emits elsewhere in the program. You saw it in the previous discussion as well, as it‚Äôs where it emits the data in support of array and span initialization from constants.)</p><p>The <code>[InlineArray]</code>-attributed type is also a normal <code>struct</code> like any other, and can be used anywhere any other <code>struct</code> can be used; that it‚Äôs using <code>[InlineArray]</code> is effectively an implementation detail. So, for example, you can embed it into another type, and the following code will print out ‚Äú0‚Äù through ‚Äú7‚Äù as you‚Äôd expect:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0

using System.Runtime.CompilerServices;

MyData data = new();
Span&lt;string&gt; span = data.Strings;

for (int i = 0; i &lt; span.Length; i++) span[i] = i.ToString();

foreach (string s in data.Strings) Console.WriteLine(s);

public class MyData
{
    private EightStrings _strings;

    public Span&lt;string&gt; Strings =&gt; _strings;

    [InlineArray(8)]
    private unsafe struct EightStrings { private string _field; }
}</code></pre><p><a href="https://github.com/dotnet/runtime/pull/82744">dotnet/runtime#82744</a> provided the CoreCLR runtime support for <code>InlineArray</code>, <a href="https://github.com/dotnet/runtime/pull/83776">dotnet/runtime#83776</a> and <a href="https://github.com/dotnet/runtime/pull/84097">dotnet/runtime#84097</a> provided the Mono runtime support, and <a href="https://github.com/dotnet/roslyn/pull/68783">dotnet/roslyn#68783</a> merged the C# compiler support.</p><p>This feature isn‚Äôt just about you using it directly, either. The compiler itself also uses <code>[InlineArray]</code> as an implementation detail behind other new and planned features‚Ä¶ we‚Äôll talk more about that when discussing collections.</p><h3 id="analyzers">Analyzers</h3><p>Lastly, even though the runtime and core libraries have made great strides in improving the performance of existing functionality and adding new performance-focused support, sometimes the best fix is actually in the consuming code. That‚Äôs where analyzers come in. Several new analyzers have been added in .NET 8 to help find particular classes of string-related performance issues.</p><p><a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/CA1858">CA1858</a>, added in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6295">dotnet/roslyn-analyzers#6295</a> from <a href="https://github.com/Youssef1313">@Youssef1313</a>, looks for calls to <code>IndexOf</code> where the result is then being checked for equality with 0. This is functionally the same as a call to <code>StartsWith</code>, but is much more expensive as it could end up examining the entire source string rather than just the starting position (<a href="https://github.com/dotnet/runtime/pull/79896">dotnet/runtime#79896</a> fixes a few such uses in <a href="https://github.com/dotnet/runtime">dotnet/runtime</a>).
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1858.png" alt="CA1858" /></p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly string _haystack = &quot;&quot;&quot;
        It was the best of times, it was the worst of times,
        it was the age of wisdom, it was the age of foolishness,
        it was the epoch of belief, it was the epoch of incredulity,
        it was the season of light, it was the season of darkness,
        it was the spring of hope, it was the winter of despair.
        &quot;&quot;&quot;;
    private readonly string _needle = &quot;hello&quot;;

    [Benchmark(Baseline = true)]
    public bool StartsWith_IndexOf0() =&gt;
        _haystack.IndexOf(_needle, StringComparison.OrdinalIgnoreCase) == 0;

    [Benchmark]
    public bool StartsWith_StartsWith() =&gt;
        _haystack.StartsWith(_needle, StringComparison.OrdinalIgnoreCase);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>StartsWith_IndexOf0</td><td style="text-align: right">31.327 ns</td><td style="text-align: right">1.00</td></tr><tr><td>StartsWith_StartsWith</td><td style="text-align: right">4.501 ns</td><td style="text-align: right">0.14</td></tr></tbody></table><p>CA1865, CA1866, and CA1867 are all related to each other. Added in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6799">dotnet/roslyn-analyzers#6799</a> from <a href="https://github.com/mrahhal">@mrahhal</a>, these look for calls to <code>string</code> methods like <code>StartsWith</code>, searching for calls passing in a single-character <code>string</code> argument, e.g. <code>str.StartsWith(&quot;@&quot;)</code>, and recommending the argument be converted into a <code>char</code>. Which diagnostic ID the analyzer raises depends on whether the transformation is 100% equivalent behavior or whether a change in behavior could potentially result, e.g. switching from a linguistic comparison to an ordinal comparison.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1865.png" alt="CA1865" /></p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly string _haystack = &quot;All we have to decide is what to do with the time that is given us.&quot;;

    [Benchmark(Baseline = true)]
    public int IndexOfString() =&gt; _haystack.IndexOf(&quot;v&quot;);

    [Benchmark]
    public int IndexOfChar() =&gt; _haystack.IndexOf(&#39;v&#39;);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>IndexOfString</td><td style="text-align: right">37.634 ns</td><td style="text-align: right">1.00</td></tr><tr><td>IndexOfChar</td><td style="text-align: right">1.979 ns</td><td style="text-align: right">0.05</td></tr></tbody></table><p>CA1862, added in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6662">dotnet/roslyn-analyzers#6662</a>, looks for places where code is performing a case-insensitive comparison (which is fine) but doing so by first lower/uppercasing an input string and then comparing that (which is far from fine). It‚Äôs much more efficient to just use a <code>StringComparison</code>. <a href="https://github.com/dotnet/runtime/pull/89539">dotnet/runtime#89539</a> fixes a few such cases.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1862.png" alt="CA1862" /></p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly string _input = &quot;https://dot.net&quot;;

    [Benchmark(Baseline = true)]
    public bool IsHttps_ToUpper() =&gt; _input.ToUpperInvariant().StartsWith(&quot;HTTPS://&quot;);

    [Benchmark]
    public bool IsHttps_StringComparison() =&gt; _input.StartsWith(&quot;HTTPS://&quot;, StringComparison.OrdinalIgnoreCase);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>IsHttps_ToUpper</td><td style="text-align: right">46.3702 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">56 B</td><td style="text-align: right">1.00</td></tr><tr><td>IsHttps_StringComparison</td><td style="text-align: right">0.4781 ns</td><td style="text-align: right">0.01</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>And <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/CA1861">CA1861</a>, added in <a href="https://github.com/dotnet/roslyn-analyzers/pull/5383">dotnet/roslyn-analyzers#5383</a> from <a href="https://github.com/steveberdy">@steveberdy</a>, looks for opportunities to lift and cache arrays being passed as arguments. <a href="https://github.com/dotnet/runtime/pull/86229">dotnet/runtime#86229</a> addresses the issues found by the analyzer in <a href="https://github.com/dotnet/runtime">dotnet/runtime</a>.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1861.png" alt="CA1861" /></p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private static readonly char[] s_separator = new[] { &#39;,&#39;, &#39;:&#39; };
    private readonly string _value = &quot;1,2,3:4,5,6&quot;;

    [Benchmark(Baseline = true)]
    public string[] Split_Original() =&gt; _value.Split(new[] { &#39;,&#39;, &#39;:&#39; });

    [Benchmark]
    public string[] Split_Refactored() =&gt; _value.Split(s_separator);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Split_Original</td><td style="text-align: right">108.6 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">248 B</td><td style="text-align: right">1.00</td></tr><tr><td>Split_Refactored</td><td style="text-align: right">104.0 ns</td><td style="text-align: right">0.96</td><td style="text-align: right">216 B</td><td style="text-align: right">0.87</td></tr></tbody></table><h2 id="collections">Collections</h2><p>Collections are the bread and butter of practically every application and service. Have more than one of something? You need a collection to manage them. And since they‚Äôre so commonly needed and used, every release of .NET invests meaningfully in improving their performance and driving down their overheads.</p><h3 id="general">General</h3><p>Some of the changes made in .NET 8 are largely collection-agnostic and affect a large number of collections. For example, <a href="https://github.com/dotnet/runtime/pull/82499">dotnet/runtime#82499</a> special-cases ‚Äúempty‚Äù on a bunch of the built-in collection types to return an empty singleton enumerator, thus avoiding allocating a largely useless object. This is wide-reaching, affecting <code>List&lt;T&gt;</code>, <code>Queue&lt;T&gt;</code>, <code>Stack&lt;T&gt;</code>, <code>LinkedList&lt;T&gt;</code>, <code>PriorityQueue&lt;TElement, TPriority&gt;</code>, <code>SortedDictionary&lt;TKey, TValue&gt;</code>, <code>SortedList&lt;TKey, TValue&gt;</code>, <code>HashSet&lt;T&gt;</code>, <code>Dictionary&lt;TKey, TValue&gt;</code>, and <code>ArraySegment&lt;T&gt;</code>. Interestingly, <code>T[]</code> was already on this plan (as were a few other collections, like <code>ConditionalWeakTable&lt;TKey, TValue&gt;</code>); if you called <code>IEnumerable&lt;T&gt;.GetEnumerator</code> on any <code>T[]</code> of length 0, you already got back a singleton enumerator hardcoded to return <code>false</code> from its <code>MoveNext</code>. That same enumerator singleton is what‚Äôs now returned from the <code>GetEnumerator</code> implementations of all of those cited collection types when they‚Äôre empty at the moment <code>GetEnumerator</code> is called.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;.NET 7&quot;).WithRuntime(CoreRuntime.Core70).AsBaseline())
    .AddJob(Job.Default.WithId(&quot;.NET 8 w/o PGO&quot;).WithRuntime(CoreRuntime.Core80).WithEnvironmentVariable(&quot;DOTNET_TieredPGO&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;.NET 8&quot;).WithRuntime(CoreRuntime.Core80));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;, &quot;Runtime&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly IEnumerable&lt;int&gt; _list = new List&lt;int&gt;();
    private readonly IEnumerable&lt;int&gt; _queue = new Queue&lt;int&gt;();
    private readonly IEnumerable&lt;int&gt; _stack = new Stack&lt;int&gt;();
    private readonly IEnumerable&lt;int&gt; _linkedList = new LinkedList&lt;int&gt;();
    private readonly IEnumerable&lt;int&gt; _hashSet = new HashSet&lt;int&gt;();
    private readonly IEnumerable&lt;int&gt; _segment = new ArraySegment&lt;int&gt;(Array.Empty&lt;int&gt;());
    private readonly IEnumerable&lt;KeyValuePair&lt;int, int&gt;&gt; _dictionary = new Dictionary&lt;int, int&gt;();
    private readonly IEnumerable&lt;KeyValuePair&lt;int, int&gt;&gt; _sortedDictionary = new SortedDictionary&lt;int, int&gt;();
    private readonly IEnumerable&lt;KeyValuePair&lt;int, int&gt;&gt; _sortedList = new SortedList&lt;int, int&gt;();
    private readonly IEnumerable&lt;(int, int)&gt; _priorityQueue = new PriorityQueue&lt;int, int&gt;().UnorderedItems;

    [Benchmark] public IEnumerator&lt;int&gt; GetList() =&gt; _list.GetEnumerator();
    [Benchmark] public IEnumerator&lt;int&gt; GetQueue() =&gt; _queue.GetEnumerator();
    [Benchmark] public IEnumerator&lt;int&gt; GetStack() =&gt; _stack.GetEnumerator();
    [Benchmark] public IEnumerator&lt;int&gt; GetLinkedList() =&gt; _linkedList.GetEnumerator();
    [Benchmark] public IEnumerator&lt;int&gt; GetHashSet() =&gt; _hashSet.GetEnumerator();
    [Benchmark] public IEnumerator&lt;int&gt; GetArraySegment() =&gt; _segment.GetEnumerator();
    [Benchmark] public IEnumerator&lt;KeyValuePair&lt;int, int&gt;&gt; GetDictionary() =&gt; _dictionary.GetEnumerator();
    [Benchmark] public IEnumerator&lt;KeyValuePair&lt;int, int&gt;&gt; GetSortedDictionary() =&gt; _sortedDictionary.GetEnumerator();
    [Benchmark] public IEnumerator&lt;KeyValuePair&lt;int, int&gt;&gt; GetSortedList() =&gt; _sortedList.GetEnumerator();
    [Benchmark] public IEnumerator&lt;(int, int)&gt; GetPriorityQueue() =&gt; _priorityQueue.GetEnumerator();
}</code></pre><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>GetList</td><td>.NET 7</td><td style="text-align: right">15.9046 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">40 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetList</td><td>.NET 8 w/o PGO</td><td style="text-align: right">2.1016 ns</td><td style="text-align: right">0.13</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetList</td><td>.NET 8</td><td style="text-align: right">0.8954 ns</td><td style="text-align: right">0.06</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetQueue</td><td>.NET 7</td><td style="text-align: right">16.5115 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">40 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetQueue</td><td>.NET 8 w/o PGO</td><td style="text-align: right">1.8934 ns</td><td style="text-align: right">0.11</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetQueue</td><td>.NET 8</td><td style="text-align: right">1.1068 ns</td><td style="text-align: right">0.07</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetStack</td><td>.NET 7</td><td style="text-align: right">16.2183 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">40 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetStack</td><td>.NET 8 w/o PGO</td><td style="text-align: right">4.5345 ns</td><td style="text-align: right">0.28</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetStack</td><td>.NET 8</td><td style="text-align: right">2.7712 ns</td><td style="text-align: right">0.17</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetLinkedList</td><td>.NET 7</td><td style="text-align: right">19.9335 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">48 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetLinkedList</td><td>.NET 8 w/o PGO</td><td style="text-align: right">4.6176 ns</td><td style="text-align: right">0.23</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetLinkedList</td><td>.NET 8</td><td style="text-align: right">2.5660 ns</td><td style="text-align: right">0.13</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetHashSet</td><td>.NET 7</td><td style="text-align: right">15.8322 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">40 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetHashSet</td><td>.NET 8 w/o PGO</td><td style="text-align: right">1.8871 ns</td><td style="text-align: right">0.12</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetHashSet</td><td>.NET 8</td><td style="text-align: right">1.1129 ns</td><td style="text-align: right">0.07</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetArraySegment</td><td>.NET 7</td><td style="text-align: right">17.0096 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">40 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetArraySegment</td><td>.NET 8 w/o PGO</td><td style="text-align: right">3.9111 ns</td><td style="text-align: right">0.23</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetArraySegment</td><td>.NET 8</td><td style="text-align: right">1.3438 ns</td><td style="text-align: right">0.08</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetDictionary</td><td>.NET 7</td><td style="text-align: right">18.3397 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">48 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetDictionary</td><td>.NET 8 w/o PGO</td><td style="text-align: right">2.3202 ns</td><td style="text-align: right">0.13</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetDictionary</td><td>.NET 8</td><td style="text-align: right">1.0185 ns</td><td style="text-align: right">0.06</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetSortedDictionary</td><td>.NET 7</td><td style="text-align: right">49.5423 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">112 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetSortedDictionary</td><td>.NET 8 w/o PGO</td><td style="text-align: right">5.6333 ns</td><td style="text-align: right">0.11</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetSortedDictionary</td><td>.NET 8</td><td style="text-align: right">2.9824 ns</td><td style="text-align: right">0.06</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetSortedList</td><td>.NET 7</td><td style="text-align: right">18.9600 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">48 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetSortedList</td><td>.NET 8 w/o PGO</td><td style="text-align: right">4.4282 ns</td><td style="text-align: right">0.23</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetSortedList</td><td>.NET 8</td><td style="text-align: right">2.2451 ns</td><td style="text-align: right">0.12</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>GetPriorityQueue</td><td>.NET 7</td><td style="text-align: right">17.4375 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">40 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetPriorityQueue</td><td>.NET 8 w/o PGO</td><td style="text-align: right">4.3855 ns</td><td style="text-align: right">0.25</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td>GetPriorityQueue</td><td>.NET 8</td><td style="text-align: right">2.8931 ns</td><td style="text-align: right">0.17</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>Enumerator allocations are avoided in other contexts, as well. <a href="https://github.com/dotnet/runtime/pull/78613">dotnet/runtime#78613</a> from <a href="https://github.com/madelson">@madelson</a> avoids an unnecessary enumerator allocation in <code>HashSet&lt;T&gt;.SetEquals</code> and <code>HashSet&lt;T&gt;.IsProperSupersetOf</code>, rearranging some code in order to use <code>HashSet&lt;T&gt;</code>‚Äòs struct-based enumerator rather than relying on it being boxed as an <code>IEnumerator&lt;T&gt;</code>. This both saves an allocation and avoids unnecessary interface dispatch.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly HashSet&lt;int&gt; _source1 = new HashSet&lt;int&gt; { 1, 2, 3, 4, 5 };
    private readonly IEnumerable&lt;int&gt; _source2 = new HashSet&lt;int&gt; { 1, 2, 3, 4, 5 };

    [Benchmark]
    public bool SetEquals() =&gt; _source1.SetEquals(_source2);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>SetEquals</td><td>.NET 7.0</td><td style="text-align: right">75.02 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">40 B</td><td style="text-align: right">1.00</td></tr><tr><td>SetEquals</td><td>.NET 8.0</td><td style="text-align: right">26.29 ns</td><td style="text-align: right">0.35</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>There are other places where ‚Äúempty‚Äù has been special-cased. <a href="https://github.com/dotnet/runtime/pull/76097">dotnet/runtime#76097</a> and <a href="https://github.com/dotnet/runtime/pull/76764">dotnet/runtime#76764</a> added an <code>Empty</code> singleton to <code>ReadOnlyCollection&lt;T&gt;</code>, <code>ReadOnlyDictionary&lt;TKey, TValue&gt;</code>, and <code>ReadOnlyObservableCollection&lt;T&gt;</code>, and then used that singleton in a bunch of places, multiple of which accrue further to many other places that consume them. For example, <code>Array.AsReadOnly</code> now checks whether the array being wrapped is empty, and if it is, <code>AsReadOnly</code> returns <code>ReadOnlyCollection&lt;T&gt;.Empty</code> rather than allocating a new <code>ReadOnlyCollection&lt;T&gt;</code> to wrap the empty array (it also makes a similar update to <code>ReadOnlyCollection&lt;T&gt;.GetEnumerator</code> as was discussed with the previous PRs). <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>‚Äòs <code>Keys</code> and <code>Values</code> will now return the same singleton if the count is known to be 0. And so on. These kinds of changes reduce the overall ‚Äúpeanut butter‚Äù layer of allocation across uses of collections.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.ObjectModel;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly int[] _array = new int[0];

    [Benchmark]
    public ReadOnlyCollection&lt;int&gt; AsReadOnly() =&gt; Array.AsReadOnly(_array);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>AsReadOnly</td><td>.NET 7.0</td><td style="text-align: right">13.380 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">24 B</td><td style="text-align: right">1.00</td></tr><tr><td>AsReadOnly</td><td>.NET 8.0</td><td style="text-align: right">1.460 ns</td><td style="text-align: right">0.11</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>Of course, there are many much more targeted and impactful improvements for specific collection types, too.</p><h2 id="list">List</h2><p>The most widely used collection in .NET, other than <code>T[]</code>, is <code>List&lt;T&gt;</code>. While that claim feels accurate, I also like to be data-driven, so as one measure, looking at the same NuGet packages we looked at earlier for enums, here‚Äôs a graph showing the number of references to the various concrete collection types:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CollectionPopularity.png" alt="References to collection types in NuGet packages" /></p><p>Given its ubiquity, <code>List&lt;T&gt;</code> sees a variety of improvements in .NET 8. <a href="https://github.com/dotnet/runtime/pull/76043">dotnet/runtime#76043</a> improves the performance of its <code>AddRange</code> method, in particular when dealing with non-<code>ICollection&lt;T&gt;</code> inputs. When adding an <code>ICollection&lt;T&gt;</code>, <code>AddRange</code> reads the collection‚Äôs <code>Count</code>, ensures the list‚Äôs array is large enough to store all the incoming data, and then copies it as efficiently as the source collection can muster by invoking the collection‚Äôs <code>CopyTo</code> method to propagate the data directly into the <code>List&lt;T&gt;</code>‚Äòs backing store. But if the input enumerable isn‚Äôt an <code>ICollection&lt;T&gt;</code>, <code>AddRange</code> has little choice but to enumerate the collection and add each item one at a time. Prior to this release, <code>AddRange(collection)</code> simply delegated to <code>InsertRange(Count, collection)</code>, which meant that when <code>InsertRange</code> discovered the source wasn‚Äôt an <code>ICollection&lt;T&gt;</code>, it would fall back to calling <code>Insert(i++, item)</code> with each item from the enumerable. That <code>Insert</code> method is too large to be inlined by default, plus involves additional checks that aren‚Äôt necessary for the <code>AddRange</code> usage (e.g. it needs to validate that the supplied position is within the range of the list, but for adding, we‚Äôre always just implicitly adding at the end, with a position implicitly known to be valid). This PR rewrote <code>AddRange</code> to not just delegate to <code>InsertRange</code>, at which point when it falls back to enumerating the non-<code>ICollection&lt;T&gt;</code> enumerable, it calls the optimized <code>Add</code>, which is inlineable, and which doesn‚Äôt have any extraneous checks.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithId(&quot;.NET 7&quot;).WithRuntime(CoreRuntime.Core70).AsBaseline())
    .AddJob(Job.Default.WithId(&quot;.NET 8 w/o PGO&quot;).WithRuntime(CoreRuntime.Core80).WithEnvironmentVariable(&quot;DOTNET_TieredPGO&quot;, &quot;0&quot;))
    .AddJob(Job.Default.WithId(&quot;.NET 8&quot;).WithRuntime(CoreRuntime.Core80));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;EnvironmentVariables&quot;, &quot;Runtime&quot;)]
public class Tests
{
    private readonly IEnumerable&lt;int&gt; _source = GetItems(1024);
    private readonly List&lt;int&gt; _list = new();

    [Benchmark]
    public void AddRange()
    {
        _list.Clear();
        _list.AddRange(_source);
    }

    private static IEnumerable&lt;int&gt; GetItems(int count)
    {
        for (int i = 0; i &lt; count; i++) yield return i;
    }
}</code></pre><p>For this test, I‚Äôve configured it to run with and without PGO on .NET 8, because this particular test benefits significantly from PGO, and I want to tease those improvements apart from those that come from the cited improvements to <code>AddRange</code>. Why does PGO help here? Because the <code>AddRange</code> method will see that the type of the enumerable is always the compiler-generated iterator for <code>GetItems</code> and will thus generate code specific to that type, enabling the calls that would otherwise involve interface dispatch to instead be devirtualized.</p><table><thead><tr><th>Method</th><th>Job</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>AddRange</td><td>.NET 7</td><td style="text-align: right">6.365 us</td><td style="text-align: right">1.00</td></tr><tr><td>AddRange</td><td>.NET 8 w/o PGO</td><td style="text-align: right">4.396 us</td><td style="text-align: right">0.69</td></tr><tr><td>AddRange</td><td>.NET 8</td><td style="text-align: right">2.445 us</td><td style="text-align: right">0.38</td></tr></tbody></table><p><code>AddRange</code> has improved in other ways, too. One of the long-requested features for <code>List&lt;T&gt;</code>, ever since spans were introduced in .NET Core 2.1, was better integration between <code>List&lt;T&gt;</code> and <code>{ReadOnly}Span&lt;T&gt;</code>. <a href="https://github.com/dotnet/runtime/pull/76274">dotnet/runtime#76274</a> provides that, adding support to both <code>AddRange</code> and <code>InsertRange</code> for data stored in a <code>ReadOnlySpan&lt;T&gt;</code>, and also support for copying all of the data in a <code>List&lt;T&gt;</code> to a <code>Span&lt;T&gt;</code> via a <code>CopyTo</code> method. It was of course previously possible to achieve this, but doing so required handling one element at a time, which when compared to vectorized copy implementations is significantly slower.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly int[] _source = new int[1024];
    private readonly List&lt;int&gt; _list = new();

    [Benchmark(Baseline = true)]
    public void OpenCoded()
    {
        _list.Clear();
        foreach (int i in (ReadOnlySpan&lt;int&gt;)_source)
        {
            _list.Add(i);
        }
    }

    [Benchmark]
    public void AddRange()
    {
        _list.Clear();
        _list.AddRange((ReadOnlySpan&lt;int&gt;)_source);
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>OpenCoded</td><td style="text-align: right">1,261.66 ns</td><td style="text-align: right">1.00</td></tr><tr><td>AddRange</td><td style="text-align: right">51.74 ns</td><td style="text-align: right">0.04</td></tr></tbody></table><p>You may note that these new <code>AddRange</code>, <code>InsertRange</code>, and <code>CopyTo</code> methods were added as extension methods rather than as instance methods on <code>List&lt;T&gt;</code>. That was done for a few reasons, but the primary motivating factor was avoiding ambiguity. Consider this example:</p><pre><code class="language-C#">var c = new MyCollection&lt;int&gt;();
c.AddRange(new int[] { 1, 2, 3 });

public class MyCollection&lt;T&gt;
{
    public void AddRange(IEnumerable&lt;T&gt; source) { }
    public void AddRange(ReadOnlySpan&lt;T&gt; source) { }
}</code></pre><p>This will fail to compile with:</p><blockquote><p>error CS0121: The call is ambiguous between the following methods or properties: ‚ÄòMyCollection.AddRange(IEnumerable)‚Äô and ‚ÄòMyCollection.AddRange(ReadOnlySpan)‚Äô</p></blockquote><p>because an array <code>T[]</code> both implements <code>IEnumerable&lt;T&gt;</code> and has an implicit conversion to <code>ReadOnlySpan&lt;T&gt;</code>, and as such the compiler doesn‚Äôt know which to use. It‚Äôs likely this ambiguity will be resolved in a future version of the language, but for now we resolved it ourselves by making the span-based overload an extension method:</p><pre><code class="language-C#">namespace System.Collections.Generic
{
    public static class CollectionExtensions
    {
        public static void AddRange&lt;T&gt;(this List&lt;T&gt; list, ReadOnlySpan&lt;T&gt; source) { ... }
    }
}</code></pre><p>The other significant addition for <code>List&lt;T&gt;</code> comes in <a href="https://github.com/dotnet/runtime/pull/82146">dotnet/runtime#82146</a> from <a href="https://github.com/MichalPetryka">@MichalPetryka</a>. In .NET 5, the <code>CollectionsMarshal.AsSpan(List&lt;T&gt;)</code> method was added; it returns a <code>Span&lt;T&gt;</code> for the in-use area of a <code>List&lt;T&gt;</code>‚Äòs backing store. For example, if you write:</p><pre><code class="language-C#">var list = new List&lt;int&gt;(42) { 1, 2, 3 };
Span&lt;int&gt; span = CollectionsMarshal.AsSpan(list);</code></pre><p>that will provide you with a <code>Span&lt;int&gt;</code> with length 3, since the list‚Äôs <code>Count</code> is 3. This is very useful for a variety of scenarios, in particular for consuming a <code>List&lt;T&gt;</code>‚Äòs data via span-based APIs. It doesn‚Äôt, however, enable scenarios that want to efficiently write to a <code>List&lt;T&gt;</code>, in particular where it would require increasing a <code>List&lt;T&gt;</code>‚Äòs count. Let‚Äôs say, for example, you wanted to create a new <code>List&lt;char&gt;</code> that contained 100 ‚Äòa‚Äô values. You might think you could write:</p><pre><code class="language-C#">var list = new List&lt;char&gt;(100);
Span&lt;char&gt; span = CollectionsMarshal.AsSpan(list); // oops
span.Fill(&#39;a&#39;);</code></pre><p>but that won‚Äôt impact the contents of the created list at all, because the span‚Äôs <code>Length</code> will match the <code>Count</code> of the list: 0. What we need to be able to do is change the count of the list, effectively telling it ‚Äúpretend like 100 values were just added to you, even though they weren‚Äôt.‚Äù This PR adds the new <code>SetCount</code> method, which does just that. We can now write the previous example like:</p><pre><code class="language-C#">var list = new List&lt;char&gt;();
CollectionsMarshal.SetCount(list, 100);
Span&lt;char&gt; span = CollectionsMarshal.AsSpan(list);
span.Fill(&#39;a&#39;); // yay!</code></pre><p>and we will successfully find ourselves with a list containing 100 ‚Äòa‚Äô elements.</p><h2 id="linq">LINQ</h2><p>That new <code>SetCount</code> method is not only exposed publicly, it‚Äôs also used as an implementation detail now in LINQ (Language-Integrated Query), thanks to <a href="https://github.com/dotnet/runtime/pull/85288">dotnet/runtime#85288</a>. <code>Enumerable</code>‚Äòs <code>ToList</code> method now benefits from this in a variety of places. For example, calling <code>Enumerable.Repeat(&#39;a&#39;, 100).ToList()</code> will behave very much like the previous example (albeit with an extra enumerable allocation for the <code>Repeat</code>), creating a new list, using <code>SetCount</code> to set its count to 100, getting the backing span, and calling <code>Fill</code> to populate it. The impact of directly writing to the span rather than going through <code>List&lt;T&gt;.Add</code> for each item is visible in the following examples:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly IEnumerable&lt;int&gt; _source = Enumerable.Range(0, 1024).ToArray();

    [Benchmark]
    public List&lt;int&gt; SelectToList() =&gt; _source.Select(i =&gt; i * 2).ToList();

    [Benchmark]
    public List&lt;byte&gt; RepeatToList() =&gt; Enumerable.Repeat((byte)&#39;a&#39;, 1024).ToList();

    [Benchmark]
    public List&lt;int&gt; RangeSelectToList() =&gt; Enumerable.Range(0, 1024).Select(i =&gt; i * 2).ToList();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>SelectToList</td><td>.NET 7.0</td><td style="text-align: right">2,627.8 ns</td><td style="text-align: right">1.00</td></tr><tr><td>SelectToList</td><td>.NET 8.0</td><td style="text-align: right">1,096.6 ns</td><td style="text-align: right">0.42</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>RepeatToList</td><td>.NET 7.0</td><td style="text-align: right">1,543.2 ns</td><td style="text-align: right">1.00</td></tr><tr><td>RepeatToList</td><td>.NET 8.0</td><td style="text-align: right">106.1 ns</td><td style="text-align: right">0.07</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>RangeSelectToList</td><td>.NET 7.0</td><td style="text-align: right">2,908.9 ns</td><td style="text-align: right">1.00</td></tr><tr><td>RangeSelectToList</td><td>.NET 8.0</td><td style="text-align: right">865.2 ns</td><td style="text-align: right">0.29</td></tr></tbody></table><p>In the case of <code>SelectToList</code> and <code>RangeSelectToList</code>, the benefit is almost entirely due to writing directly into the span for each element vs the overhead of <code>Add</code>. In the case of <code>RepeatToList</code>, because the <code>ToList</code> call has direct access to the span, it‚Äôs able to use the vectorized <code>Fill</code> method (as it was previously doing just for <code>ToArray</code>), achieving an even larger speedup.</p><p>You‚Äôll note that I didn‚Äôt include a test for <code>Enumerable.Range(...).ToList()</code> above. That‚Äôs because it was improved in other ways, and I didn‚Äôt want to conflate them in the measurements. In particular, <a href="https://github.com/dotnet/runtime/pull/87992">dotnet/runtime#87992</a> from <a href="https://github.com/neon-sunset">@neon-sunset</a> vectorized the internal <code>Fill</code> method that‚Äôs used by the specialization of both <code>ToArray</code> and <code>ToList</code> on the iterator returned from <code>Enumerable.Range</code>. That means that rather than writing one <code>int</code> at a time, on a system that supports 128-bit vectors (which is pretty much all hardware you might use today) it‚Äôll instead write four <code>int</code>s at a time, and on a system that supports 256-bit vectors, it‚Äôll write eight <code>int</code>s at a time. Thus, <code>Enumerable.Range(...).ToList()</code> benefits both from writing directly into the span and from the now vectorized implementation, which means it ends up with similar speedups as <code>RepeatToList</code> above. We can also tease apart these improvements by changing what instruction sets are seen as available.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    [Benchmark]
    public List&lt;int&gt; RangeToList() =&gt; Enumerable.Range(0, 16_384).ToList();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>RangeToList</td><td>.NET 7.0</td><td style="text-align: right">25.374 us</td><td style="text-align: right">1.00</td></tr><tr><td>RangeToList</td><td>.NET 8.0</td><td style="text-align: right">6.872 us</td><td style="text-align: right">0.27</td></tr></tbody></table><p>These optimized span-based implementations now also accrue to other usage beyond <code>ToArray</code> and <code>ToList</code>. If you look at the <code>Enumerable.Repeat</code> and <code>Enumerable.Range</code> implementations in .NET Framework, you‚Äôll see that they‚Äôre just normal C# iterators, e.g.</p><pre><code class="language-C#">static IEnumerable&lt;int&gt; RangeIterator(int start, int count)
{
    for (int i = 0; i &lt; count; i++)
    {
        yield return start + i;
    }
}</code></pre><p>but years ago, these methods were changed in .NET Core to return a custom iterator (just a normal class implementing <code>IEnumerator&lt;T&gt;</code> where we provide the full implementation rather than the compiler doing so). Once we have a dedicated type, we can add additional interfaces to it, and <a href="https://github.com/dotnet/runtime/pull/88249">dotnet/runtime#88249</a> does exactly that, making these internal <code>RangeIterator</code>, <code>RepeatIterator</code>, and several other types implement <code>IList&lt;T&gt;</code>. That then means that any code which queries an <code>IEnumerable&lt;T&gt;</code> for whether it implements <code>IList&lt;T&gt;</code>, such as to use its <code>Count</code> and <code>CopyTo</code> methods, will light up when passed one of these instances as well. And the same <code>Fill</code> implementation that‚Äôs used internally to implement <code>ToArray</code> and <code>ToList</code> is then used as well with <code>CopyTo</code>. That means if you write code like:</p><pre><code class="language-C#">List&lt;T&gt; list = ...;
IEnumerable&lt;T&gt; enumerable = ...;
list.AddRange(enumerable);</code></pre><p>and that <code>enumerable</code> came from one of these enlightened types, it‚Äôll now benefit from the exact same use of vectorization previously discussed, as the <code>List&lt;T&gt;</code> will ensure its array is appropriately sized to handle the incoming data and will then hand its array off to the iterator‚Äôs <code>ICollection&lt;T&gt;.CopyTo</code> method to write into directly.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly List&lt;byte&gt; _list = new();

    [Benchmark]
    public void AddRange()
    {
        _list.Clear();
        _list.AddRange(Enumerable.Repeat((byte)&#39;a&#39;, 1024));
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>AddRange</td><td>.NET 7.0</td><td style="text-align: right">6,826.89 ns</td><td style="text-align: right">1.000</td></tr><tr><td>AddRange</td><td>.NET 8.0</td><td style="text-align: right">20.30 ns</td><td style="text-align: right">0.003</td></tr></tbody></table><p>Vectorization with LINQ was also improved in other ways. In .NET 7, <code>Enumerable.Min</code> and <code>Enumerable.Max</code> were taught how to vectorize the handling of some inputs (when the enumerable was actually an array or list of <code>int</code> or <code>long</code> values), and in .NET 8 <a href="https://github.com/dotnet/runtime/pull/76144">dotnet/runtime#76144</a> expanded that to cover <code>byte</code>, <code>sbyte</code>, <code>ushort</code>, <code>short</code>, <code>uint</code>, <code>ulong</code>, <code>nint</code>, and <code>nuint</code> as well (it also switched the implementation from using <code>Vector&lt;T&gt;</code> to using both <code>Vector128&lt;T&gt;</code> and <code>Vector256&lt;T&gt;</code>, so that shorter inputs could still benefit from some level of vectorization).</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly byte[] _values = Enumerable.Range(0, 4096).Select(_ =&gt; (byte)Random.Shared.Next(0, 256)).ToArray();

    [Benchmark]
    public byte Max() =&gt; _values.Max();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Max</td><td>.NET 7.0</td><td style="text-align: right">16,496.96 ns</td><td style="text-align: right">1.000</td></tr><tr><td>Max</td><td>.NET 8.0</td><td style="text-align: right">53.77 ns</td><td style="text-align: right">0.003</td></tr></tbody></table><p><code>Enumerable.Sum</code> has now also been vectorized, for <code>int</code> and <code>long</code>, thanks to <a href="https://github.com/dotnet/runtime/pull/84519">dotnet/runtime#84519</a> from <a href="https://github.com/brantburnett">@brantburnett</a>. <code>Sum</code> in LINQ performs <code>checked</code> arithmetic, and normal <code>Vector&lt;T&gt;</code> operations are <code>unchecked</code>, which makes the vectorization of this method a bit more challenging. To achieve it, it takes advantage of a neat little bit hack trick for determining whether an addition of two signed twos-complement numbers underflow or overflow. The same logic applies for both <code>int</code> and <code>long</code> here, so we‚Äôll focus just on <code>int</code>. It‚Äôs impossible for the addition of a negative <code>int</code> to overflow when added to a positive <code>int</code>, so the only way two summed values can underflow or overflow is if they have the same sign. Further, if any wrapping occurs, it can‚Äôt wrap back to the same sign; if you add two positives numbers together and it overflows, the result will be negative, and if you add two negative numbers together and it underflows, the result will be positive. Thus, a function like this can tell us whether the sum wrapped:</p><pre><code class="language-C#">static int Sum(int a, int b, out bool overflow)
{
    int sum = a + b;
    overflow = (((sum ^ a) &amp; (sum ^ b)) &amp; int.MinValue) != 0;
    return sum;
}</code></pre><p>We‚Äôre <code>xor</code>‚Äòing the result with each of the inputs, and <code>and</code>‚Äòing those together. That will produce a number who‚Äôs top-most bit is 1 if there was overflow/underflow, and otherwise 0, so we can then mask off all the other bits and compare to 0 to determine whether wrapping occurred. This is useful for vectorization, because we can easily do the same thing with vectors, summing the two vectors and reporting on whether any of the elemental sums overflowed:</p><pre><code class="language-C#">static Vector128&lt;int&gt; Sum(Vector128&lt;int&gt; a, Vector128&lt;int&gt; b, out bool overflow)
{
    Vector128&lt;int&gt; sum = a + b;
    overflow = (((sum ^ a) &amp; (sum ^ b)) &amp; Vector128.Create(int.MinValue)) != Vector128&lt;int&gt;.Zero;
    return sum;
}</code></pre><p>With that, <code>Enumerable.Sum</code> can be vectorized. For sure, it‚Äôs not as efficient as if we didn‚Äôt need to care about the <code>checked</code>; after all, for every addition operation, there‚Äôs at least an extra set of instructions for the two <code>xor</code>s and the <code>and</code>‚Äòing of them (we can amortize the bit check across several operations by doing some loop unrolling). With 256-bit vectors, an ideal speedup for such a sum operation over <code>int</code> values would be 8x, since we can process eight 32-bit values at a time in a 256-bit vector. We‚Äôre then doing fairly well that we get a 4x speedup in that situation:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly IEnumerable&lt;int&gt; _values = Enumerable.Range(0, 1024).ToArray();

    [Benchmark]
    public int Sum() =&gt; _values.Sum();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Sum</td><td>.NET 7.0</td><td style="text-align: right">347.28 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Sum</td><td>.NET 8.0</td><td style="text-align: right">78.26 ns</td><td style="text-align: right">0.23</td></tr></tbody></table><p>LINQ has improved in .NET 8 beyond just vectorization; other operators have seen other kinds of optimization. Take <code>Order</code>/<code>OrderDescending</code>, for example. These LINQ operators implement a ‚Äústable sort‚Äù; that means that while sorting the data, if two items compare equally, they‚Äôll end up in the final result in the same order they were in the original (an ‚Äúunstable sort‚Äù doesn‚Äôt care about the ordering of two values that compare equally). The core sorting routine shared by spans, arrays, and lists in .NET (e.g. <code>Array.Sort</code>) provides an unstable sort, so to use that implementation and provide stable ordering guarantees, LINQ has to layer the stability on top, which it does by factoring into the comparison operation between keys the original location of the key in the input (e.g. if two values otherwise compare equally, then it proceeds to compare their original locations). That, however, means it needs to remember their original locations, which means it needs to allocate a separate <code>int[]</code> for positions. Interestingly, though, sometimes you can‚Äôt tell the difference between whether a sort is stable or unstable. <a href="https://github.com/dotnet/runtime/pull/76733">dotnet/runtime#76733</a> takes advantage of the fact that for primitive types like <code>int</code>, two values that compare equally with the default comparer are indistinguishable, in which case it‚Äôs fine to use an unstable sort because the only values that can compare equally have identical bits and thus trying to maintain an order between them doesn‚Äôt matter. It thus enables avoiding all of the overhead associated with maintaining a stable sort.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private IEnumerable&lt;int&gt; _source;

    [GlobalSetup]
    public void Setup() =&gt; _source = Enumerable.Range(0, 1000).Reverse();

    [Benchmark]
    public int EnumerateOrdered()
    {
        int sum = 0;
        foreach (int i in _source.Order()) 
        {
            sum += i;
        }
        return sum;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>EnumerateOrdered</td><td>.NET 7.0</td><td style="text-align: right">73.728 us</td><td style="text-align: right">1.00</td><td style="text-align: right">8.09 KB</td><td style="text-align: right">1.00</td></tr><tr><td>EnumerateOrdered</td><td>.NET 8.0</td><td style="text-align: right">9.753 us</td><td style="text-align: right">0.13</td><td style="text-align: right">4.02 KB</td><td style="text-align: right">0.50</td></tr></tbody></table><p><a href="https://github.com/dotnet/runtime/pull/76418">dotnet/runtime#76418</a> also improves sorting in LINQ, this time for <code>OrderBy</code>/<code>OrderByDescending</code>, and in particular when the type of the key used (the type returned by the <code>keySelector</code> delegate provided to <code>OrderBy</code>) is a value type and the default comparer is used. This change employs the same approach that some of the .NET collections like <code>Dictionary&lt;TKey, TValue&gt;</code> already do, which is to take advantage of the fact that value types when used as generics get a custom copy of the code dedicated to that type (‚Äúgeneric specialization‚Äù), and that <code>Comparer&lt;TValueType&gt;.Default.Compare</code> will get devirtualized and possibly inlined. As such, it adds a dedicated path for when the key is a value type, and that enables the comparison operation (which is invoked <code>O(n log n)</code> times) to be sped up.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly int[] _values = Enumerable.Range(0, 1_000_000).Reverse().ToArray();

    [Benchmark]
    public int OrderByToArray()
    {
        int sum = 0;
        foreach (int i in _values.OrderBy(i =&gt; i * 2)) sum += i;
        return sum;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>OrderByToArray</td><td>.NET 7.0</td><td style="text-align: right">187.17 ms</td><td style="text-align: right">1.00</td></tr><tr><td>OrderByToArray</td><td>.NET 8.0</td><td style="text-align: right">67.54 ms</td><td style="text-align: right">0.36</td></tr></tbody></table><p>Of course, sometimes the most efficient use of LINQ is simply not using it. It‚Äôs an amazing productivity tool, and it goes to great lengths to be efficient, but sometimes there are better answers that are just as simple. <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1860">CA1860</a>, added in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6236">dotnet/roslyn-analyzers#6236</a> from <a href="https://github.com/CollinAlpert">@CollinAlpert</a>, flags one such case. It looks for use of <code>Enumerable.Any</code> on collections that directly expose a <code>Count</code>, <code>Length</code>, or <code>IsEmpty</code> property that could be used instead. While <code>Any</code> does use <code>Enumerable.TryGetNonEnumeratedCount</code> in an attempt to check the collection‚Äôs number of items without allocating or using an enumerator, even if it‚Äôs successful in doing so it incurs the overhead of the interface check and dispatch. It‚Äôs faster to just use the properties directly. <a href="https://github.com/dotnet/runtime/pull/81583">dotnet/runtime#81583</a> fixed several cases of this.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1860.png" alt="CA1860" /></p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly string _str = &quot;hello&quot;;
    private readonly List&lt;int&gt; _list = new() { 1, 2, 3 };
    private readonly int[] _array = new int[] { 4, 5, 6 };

    [Benchmark(Baseline = true)]
    public bool AllNonEmpty_Any() =&gt;
        _str.Any() &amp;&amp;
        _list.Any() &amp;&amp;
        _array.Any();

    [Benchmark]
    public bool AllNonEmpty_Property() =&gt;
        _str.Length != 0 &amp;&amp;
        _list.Count != 0 &amp;&amp;
        _array.Length != 0;
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>AllNonEmpty_Any</td><td style="text-align: right">12.5302 ns</td><td style="text-align: right">1.00</td></tr><tr><td>AllNonEmpty_Property</td><td style="text-align: right">0.3701 ns</td><td style="text-align: right">0.03</td></tr></tbody></table><h2 id="dictionary">Dictionary</h2><p>In addition to making existing methods faster, LINQ has also gained some new methods in .NET 8. <a href="https://github.com/dotnet/runtime/pull/85811">dotnet/runtime#85811</a> from <a href="https://github.com/lateapexearlyspeed">@lateapexearlyspeed</a> added new overloads of <code>ToDictionary</code>. Unlike the existing overloads that are extensions on any arbitrary <code>IEnumerable&lt;TSource&gt;</code> and accept delegates for extracting from each <code>TSource</code> a <code>TKey</code> and/or <code>TValue</code>, these new overloads are extensions on <code>IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;</code> and <code>IEnumerable&lt;(TKey, TValue)&gt;</code>. This is primarily an addition for convenience, as it means that such an enumerable that previously used code like:</p><pre><code class="language-C#">return collection.ToDictionary(kvp =&gt; kvp.Key, kvp =&gt; kvp.Value);</code></pre><p>can instead be simplified to just be:</p><pre><code class="language-C#">return collection.ToDictionary();</code></pre><p>Beyond being simpler, this has the nice benefit of also being cheaper, as it means the method doesn‚Äôt need to invoke two delegates per item. It also means that this new method is a simple passthrough to <code>Dictionary&lt;TKey, TValue&gt;</code>‚Äòs constructor, which has its own optimizations that take advantage of knowing about <code>Dictionary&lt;TKey, TValue&gt;</code> internals, e.g. it can more efficiently copy the source data if it‚Äôs a <code>Dictionary&lt;TKey, TValue&gt;</code>.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly IEnumerable&lt;KeyValuePair&lt;string, int&gt;&gt; _source = Enumerable.Range(0, 1024).ToDictionary(i =&gt; i.ToString(), i =&gt; i);

    [Benchmark(Baseline = true)]
    public Dictionary&lt;string, int&gt; WithDelegates() =&gt; _source.ToDictionary(kvp =&gt; kvp.Key, kvp =&gt; kvp.Value);

    [Benchmark]
    public Dictionary&lt;string, int&gt; WithoutDelegates() =&gt; _source.ToDictionary();
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>WithDelegates</td><td style="text-align: right">21.208 us</td><td style="text-align: right">1.00</td></tr><tr><td>WithoutDelegates</td><td style="text-align: right">8.652 us</td><td style="text-align: right">0.41</td></tr></tbody></table><p>It also benefits from the <code>Dictionary&lt;TKey, TValue&gt;</code>‚Äòs constructor being optimized in additional ways. As noted, its constructor accepting an <code>IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;</code> already special-cased when the enumerable is actually a <code>Dictionary&lt;TKey, TValue&gt;</code>. With <a href="https://github.com/dotnet/runtime/pull/86254">dotnet/runtime#86254</a>, it now also special-cases when the enumerable is a <code>KeyValuePair&lt;TKey, TValue&gt;[]</code> or a <code>List&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;</code>. When such a source is found, a span is extracted from it (a simple cast for an array, or via <code>CollectionsMarshal.AsSpan</code> for a <code>List&lt;&gt;</code>), and then that span (rather than the original <code>IEnumerable&lt;&gt;</code>) is what‚Äôs enumerated. That saves an enumerator allocation and several interface dispatches per item for these reasonably common cases.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly List&lt;KeyValuePair&lt;int, int&gt;&gt; _list = Enumerable.Range(0, 1000).Select(i =&gt; new KeyValuePair&lt;int, int&gt;(i, i)).ToList();

    [Benchmark] public Dictionary&lt;int, int&gt; FromList() =&gt; new Dictionary&lt;int, int&gt;(_list);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>FromList</td><td>.NET 7.0</td><td style="text-align: right">12.250 us</td><td style="text-align: right">1.00</td></tr><tr><td>FromList</td><td>.NET 8.0</td><td style="text-align: right">6.780 us</td><td style="text-align: right">0.55</td></tr></tbody></table><p>The most common operation performed on a dictionary is looking up a key, whether to see if it exists, to add a value, or to get the current value. Previous .NET releases have seen significant improvements in this lookup time, but even better than optimizing a lookup is not needing to do one at all. One common place we‚Äôve seen unnecessary lookups is with guard clauses that end up being unnecessary, for example code that does:</p><pre><code class="language-C#">if (!dictionary.ContainsKey(key))
{
    dictionary.Add(key, value);
}</code></pre><p>This incurs two lookups, one as part of <code>ContainsKey</code>, and then if the key wasn‚Äôt in the dictionary, another as part of the <code>Add</code> call. Code can instead achieve the same operation with:</p><pre><code class="language-C#">dictionary.TryAdd(key, value);</code></pre><p>which incurs only one lookup. <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/CA1864">CA1864</a>, added in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6199">dotnet/roslyn-analyzers#6199</a> from <a href="https://github.com/CollinAlpert">@CollinAlpert</a>, looks for such places where an <code>Add</code> call is guarded by a <code>ContainsKey</code> call. <a href="https://github.com/dotnet/runtime/pull/88700">dotnet/runtime#88700</a> fixed a few occurrences of this in <a href="https://github.com/dotnet/runtime">dotnet/runtime</a>.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1864.png" alt="CA1864" /></p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly Dictionary&lt;string, string&gt; _dict = new();

    [Benchmark(Baseline = true)]
    public void ContainsThenAdd()
    {
        _dict.Clear();
        if (!_dict.ContainsKey(&quot;key&quot;))
        {
            _dict.Add(&quot;key&quot;, &quot;value&quot;);
        }
    }

    [Benchmark]
    public void TryAdd()
    {
        _dict.Clear();
        _dict.TryAdd(&quot;key&quot;, &quot;value&quot;);
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>ContainsThenAdd</td><td style="text-align: right">25.93 ns</td><td style="text-align: right">1.00</td></tr><tr><td>TryAdd</td><td style="text-align: right">19.50 ns</td><td style="text-align: right">0.75</td></tr></tbody></table><p>Similarly, <a href="https://github.com/dotnet/roslyn-analyzers/pull/6767">dotnet/roslyn-analyzers#6767</a> from <a href="https://github.com/mpidash">@mpidash</a> added <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/CA1868">CA1868</a>, which looks for <code>Add</code> or <code>Remove</code> calls on <code>ISet&lt;T&gt;</code>s where the call is guarded by a <code>Contains</code>, and recommends removing the <code>Contains</code> call. <a href="https://github.com/dotnet/runtime/pull/89652">dotnet/runtime#89652</a> from <a href="https://github.com/mpidash">@mpidash</a> fixes occurrences of this in <a href="https://github.com/dotnet/runtime">dotnet/runtime</a>.
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1868.png" alt="CA1868" /></p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly HashSet&lt;string&gt; _set = new();

    [Benchmark(Baseline = true)]
    public bool ContainsThenAdd()
    {
        _set.Clear();
        if (!_set.Contains(&quot;key&quot;))
        {
            _set.Add(&quot;key&quot;);
            return true;
        }

        return false;
    }

    [Benchmark]
    public bool Add()
    {
        _set.Clear();
        return _set.Add(&quot;key&quot;);
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>ContainsThenAdd</td><td style="text-align: right">22.98 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Add</td><td style="text-align: right">17.99 ns</td><td style="text-align: right">0.78</td></tr></tbody></table><p>Other related analyzers previously released have also been improved. <a href="https://github.com/dotnet/roslyn-analyzers/pull/6387">dotnet/roslyn-analyzers#6387</a> improved <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1854">CA1854</a> to find more opportunities for using <code>IDictionary&lt;TKey, TValue&gt;.TryGetValue</code>, with <a href="https://github.com/dotnet/runtime/pull/85613">dotnet/runtime#85613</a> and <a href="https://github.com/dotnet/runtime/pull/80996">dotnet/runtime#80996</a> using the analyzer to find and fix more occurrences.</p><p>Other dictionaries have also improved in .NET 8. <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> in particular got a nice boost from <a href="https://github.com/dotnet/runtime/pull/81557">dotnet/runtime#81557</a>, for all key types but especially for the very common case where <code>TKey</code> is <code>string</code> and the equality comparer is either the default comparer (whether that be <code>null</code>, <code>EqualityComparer&lt;TKey&gt;.Default</code>, or <code>StringComparer.Ordinal</code>, all of which behave identically) or <code>StringComparer.OrdinalIgnoreCase</code>. In .NET Core, <code>string</code> hash codes are randomized, meaning there‚Äôs a random seed value unique to any given process that‚Äôs incorporated into string hash codes. So if, for example, I run the following program:</p><pre><code class="language-C#">// dotnet run -f net8.0

string s = &quot;Hello, world!&quot;;
Console.WriteLine(s.GetHashCode());
Console.WriteLine(s.GetHashCode());
Console.WriteLine(s.GetHashCode());</code></pre><p>I get the following output, showing that the hash code for a given string is stable across multiple <code>GetHashCode</code> calls:</p><pre><code class="language-text">1442385232
1442385232
1442385232</code></pre><p>but when I run the program again, I get a different stable value:</p><pre><code class="language-text">740992523
740992523
740992523</code></pre><p>This randomization is done to help mitigate a class of denial-of-service (DoS) attacks involving dictionaries, where an attacker might be able to trigger the worst-case algorithmic complexity of a dictionary by forcing lots of collisions amongst the keys. However, the randomization also incurs some amount of overhead. It‚Äôs enough overhead so that <code>Dictionary&lt;TKey, TValue&gt;</code> actually special-cases <code>string</code> keys with a default or <code>OrdinalIgnoreCase</code> comparer to skip the randomization until a sufficient number of collisions has been detected. Now in .NET 8, <code>ConcurrentDictionary&lt;string, TValue&gt;</code> employs the same trick. When it starts life, a <code>ConcurrentDictionary&lt;string, TValue&gt;</code> instance using a default or <code>OrdinalIgnoreCase</code> comparer performs hashing using a non-randomized comparer. Then as it‚Äôs adding an item and traversing its internal data structure, it keeps track of how many keys it has to examine that had the same hash code. If that count surpasses a threshold, it then switches back to using a randomized comparer, rehashing the whole dictionary in order to mitigate possible attacks.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Concurrent;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private KeyValuePair&lt;string, string&gt;[] _pairs;
    private ConcurrentDictionary&lt;string, string&gt; _cd;

    [GlobalSetup]
    public void Setup()
    {
        _pairs =
            // from https://github.com/dotnet/runtime/blob/a30de6d40f69ef612b514344a5ec83fffd10b957/src/libraries/System.Formats.Asn1/src/System/Formats/Asn1/WellKnownOids.cs#L317-L419
            new[]
            {
                &quot;1.2.840.10040.4.1&quot;, &quot;1.2.840.10040.4.3&quot;, &quot;1.2.840.10045.2.1&quot;, &quot;1.2.840.10045.1.1&quot;, &quot;1.2.840.10045.1.2&quot;, &quot;1.2.840.10045.3.1.7&quot;, &quot;1.2.840.10045.4.1&quot;, &quot;1.2.840.10045.4.3.2&quot;, &quot;1.2.840.10045.4.3.3&quot;, &quot;1.2.840.10045.4.3.4&quot;,
                &quot;1.2.840.113549.1.1.1&quot;, &quot;1.2.840.113549.1.1.5&quot;, &quot;1.2.840.113549.1.1.7&quot;, &quot;1.2.840.113549.1.1.8&quot;, &quot;1.2.840.113549.1.1.9&quot;, &quot;1.2.840.113549.1.1.10&quot;, &quot;1.2.840.113549.1.1.11&quot;, &quot;1.2.840.113549.1.1.12&quot;, &quot;1.2.840.113549.1.1.13&quot;,
                &quot;1.2.840.113549.1.5.3&quot;, &quot;1.2.840.113549.1.5.10&quot;, &quot;1.2.840.113549.1.5.11&quot;, &quot;1.2.840.113549.1.5.12&quot;, &quot;1.2.840.113549.1.5.13&quot;, &quot;1.2.840.113549.1.7.1&quot;, &quot;1.2.840.113549.1.7.2&quot;, &quot;1.2.840.113549.1.7.3&quot;, &quot;1.2.840.113549.1.7.6&quot;,
                &quot;1.2.840.113549.1.9.1&quot;, &quot;1.2.840.113549.1.9.3&quot;, &quot;1.2.840.113549.1.9.4&quot;, &quot;1.2.840.113549.1.9.5&quot;, &quot;1.2.840.113549.1.9.6&quot;, &quot;1.2.840.113549.1.9.7&quot;, &quot;1.2.840.113549.1.9.14&quot;, &quot;1.2.840.113549.1.9.15&quot;, &quot;1.2.840.113549.1.9.16.1.4&quot;,
                &quot;1.2.840.113549.1.9.16.2.12&quot;, &quot;1.2.840.113549.1.9.16.2.14&quot;, &quot;1.2.840.113549.1.9.16.2.47&quot;, &quot;1.2.840.113549.1.9.20&quot;, &quot;1.2.840.113549.1.9.21&quot;, &quot;1.2.840.113549.1.9.22.1&quot;, &quot;1.2.840.113549.1.12.1.3&quot;, &quot;1.2.840.113549.1.12.1.5&quot;,
                &quot;1.2.840.113549.1.12.1.6&quot;, &quot;1.2.840.113549.1.12.10.1.1&quot;, &quot;1.2.840.113549.1.12.10.1.2&quot;, &quot;1.2.840.113549.1.12.10.1.3&quot;, &quot;1.2.840.113549.1.12.10.1.5&quot;, &quot;1.2.840.113549.1.12.10.1.6&quot;, &quot;1.2.840.113549.2.5&quot;, &quot;1.2.840.113549.2.7&quot;,
                &quot;1.2.840.113549.2.9&quot;, &quot;1.2.840.113549.2.10&quot;, &quot;1.2.840.113549.2.11&quot;, &quot;1.2.840.113549.3.2&quot;, &quot;1.2.840.113549.3.7&quot;, &quot;1.3.6.1.4.1.311.17.1&quot;, &quot;1.3.6.1.4.1.311.17.3.20&quot;, &quot;1.3.6.1.4.1.311.20.2.3&quot;, &quot;1.3.6.1.4.1.311.88.2.1&quot;,
                &quot;1.3.6.1.4.1.311.88.2.2&quot;, &quot;1.3.6.1.5.5.7.3.1&quot;, &quot;1.3.6.1.5.5.7.3.2&quot;, &quot;1.3.6.1.5.5.7.3.3&quot;, &quot;1.3.6.1.5.5.7.3.4&quot;, &quot;1.3.6.1.5.5.7.3.8&quot;, &quot;1.3.6.1.5.5.7.3.9&quot;, &quot;1.3.6.1.5.5.7.6.2&quot;, &quot;1.3.6.1.5.5.7.48.1&quot;, &quot;1.3.6.1.5.5.7.48.1.2&quot;,
                &quot;1.3.6.1.5.5.7.48.2&quot;, &quot;1.3.14.3.2.26&quot;, &quot;1.3.14.3.2.7&quot;, &quot;1.3.132.0.34&quot;, &quot;1.3.132.0.35&quot;, &quot;2.5.4.3&quot;, &quot;2.5.4.5&quot;, &quot;2.5.4.6&quot;, &quot;2.5.4.7&quot;, &quot;2.5.4.8&quot;, &quot;2.5.4.10&quot;, &quot;2.5.4.11&quot;, &quot;2.5.4.97&quot;, &quot;2.5.29.14&quot;, &quot;2.5.29.15&quot;, &quot;2.5.29.17&quot;, &quot;2.5.29.19&quot;,
                &quot;2.5.29.20&quot;, &quot;2.5.29.35&quot;, &quot;2.16.840.1.101.3.4.1.2&quot;, &quot;2.16.840.1.101.3.4.1.22&quot;, &quot;2.16.840.1.101.3.4.1.42&quot;, &quot;2.16.840.1.101.3.4.2.1&quot;, &quot;2.16.840.1.101.3.4.2.2&quot;, &quot;2.16.840.1.101.3.4.2.3&quot;, &quot;2.23.140.1.2.1&quot;, &quot;2.23.140.1.2.2&quot;,
            }.Select(s =&gt; new KeyValuePair&lt;string, string&gt;(s, s)).ToArray();
        _cd = new ConcurrentDictionary&lt;string, string&gt;(_pairs, StringComparer.OrdinalIgnoreCase);
    }

    [Benchmark]
    public int TryGetValue()
    {
        int count = 0;
        foreach (KeyValuePair&lt;string, string&gt; pair in _pairs)
        {
            if (_cd.TryGetValue(pair.Key, out _))
            {
                count++;
            }
        }

        return count;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>TryGetValue</td><td>.NET 7.0</td><td style="text-align: right">2.917 us</td><td style="text-align: right">1.00</td></tr><tr><td>TryGetValue</td><td>.NET 8.0</td><td style="text-align: right">1.462 us</td><td style="text-align: right">0.50</td></tr></tbody></table><p>The above benchmark also benefited from <a href="https://github.com/dotnet/runtime/pull/77005">dotnet/runtime#77005</a>, which tweaked another long-standing optimization in the type. <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> maintains a <code>Node</code> object for every key/value pair it stores. As multiple threads might be reading from the dictionary concurrent with updates happening, the dictionary needs to be really careful about how it mutates data stored in the collection. If an update is performed that needs to update a <code>TValue</code> in an existing node (e.g. <code>cd[existingKey] = newValue</code>), the dictionary needs to be very careful to avoid torn reads, such that one thread could be reading the value while another thread is writing the value, leading to the reader seeing part of the old value and part of the new value. It does this by only reusing that same <code>Node</code> for an update if it can write the <code>TValue</code> atomically. It can write it atomically if the <code>TValue</code> is a reference type, in which case it‚Äôs simply writing a pointer-sized reference, or if the <code>TValue</code> is a primitive value that‚Äôs defined by the platform to always be written atomically when written with appropriate alignment, e.g. <code>int</code>, or <code>long</code> when in a 64-bit process. To make this check efficient, <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> computes once whether a given <code>TValue</code> is writable atomically, storing it into a <code>static readonly</code> field, such that in tier 1 compilation, the JIT can treat the value as a <code>const</code>. However, this <code>const</code> trick doesn‚Äôt always work. The field was on <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> itself, and if one of those generic type parameters ended up being a reference type (e.g. <code>ConcurrentDictionary&lt;object, int&gt;</code>), accessing the <code>static readonly</code> field would require a generic lookup (the JIT isn‚Äôt currently able to see that the value stored in the field is only dependent on the <code>TValue</code> and not on the <code>TKey</code>). To fix this, the field was moved to a separate type where <code>TValue</code> is the only generic parameter, and a check for <code>typeof(TValue).IsValueType</code> (which is itself a JIT intrinsic that manifests as a <code>const</code>) is done separately.</p><p><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>‚Äòs <code>TryRemove</code> was also improved this release, via <a href="https://github.com/dotnet/runtime/pull/82004">dotnet/runtime#82004</a>. Mutation of a <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> requires taking a lock. However, in the case of <code>TryRemove</code>, we only actually need the lock if it‚Äôs possible the item being removed is contained. If the number of items protected by the given lock is 0, we know <code>TryRemove</code> will be a nop. Thus, this PR added a fast path to <code>TryRemove</code> that read the count for that lock and immediately bailed if it was 0.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Concurrent;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly ConcurrentDictionary&lt;int, int&gt; _empty = new();

    [Benchmark]
    public bool TryRemoveEmpty() =&gt; _empty.TryRemove(default, out _);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>TryRemoveEmpty</td><td>.NET 7.0</td><td style="text-align: right">26.963 ns</td><td style="text-align: right">1.00</td></tr><tr><td>TryRemoveEmpty</td><td>.NET 8.0</td><td style="text-align: right">5.853 ns</td><td style="text-align: right">0.22</td></tr></tbody></table><p>Another dictionary that‚Äôs been improved in .NET 8 is <code>ConditionalWeakTable&lt;TKey, TValue&gt;</code>. As background if you haven‚Äôt used this type before, <code>ConditionalWeakTable&lt;TKey, TValue&gt;</code> is a very specialized dictionary based on <code>DependentHandle</code>; think of it as every key being a weak reference (so if the GC runs, the key in the dictionary won‚Äôt be counted as a strong root that would keep the object alive), and that if the key is collected, the whole entry is removed from the table. It‚Äôs particularly useful in situations where additional data needs to be associated with an object but where for whatever reason you‚Äôre unable to modify that object to have a reference to the additional data. <a href="https://github.com/dotnet/runtime/pull/80059">dotnet/runtime#80059</a> improves the performance of lookups on a <code>ConditionalWeakTable&lt;TKey, TValue&gt;</code>, in particular for objects that <em>aren‚Äôt</em> in the collection, and even more specifically for an object that‚Äôs never been in any dictionary. Since <code>ConditionalWeakTable&lt;TKey, TValue&gt;</code> is about object references, unlike other dictionaries in .NET, it doesn‚Äôt use the default <code>EqualityComparer&lt;TKey&gt;.Default</code> to determine whether an object is in the collection; it just uses object reference equality. And that means to get a hash code for an object, it uses the same functionality that the base <code>object.GetHashCode</code> does. It can‚Äôt just call <code>GetHashCode</code>, as the method could have been overridden, so instead it directly calls to the same public <code>RuntimeHelpers.GetHashCode</code> that <code>object.GetHashCode</code> uses:</p><pre><code class="language-C#">public class Object
{
    public virtual int GetHashCode() =&gt; RuntimeHelpers.GetHashCode(this);
    ...
}</code></pre><p>This PR tweaks what <code>ConditionalWeakTable&lt;,&gt;</code> does here. It introduces a new internal <code>RuntimeHelpers.TryGetHashCode</code> that will avoid creating and storing a hash code for the object if the object doesn‚Äôt already have one. It then uses that method from <code>ConditionalWeakTable&lt;TKey, TValue&gt;</code> as part of <code>TryGetValue</code> (and <code>Remove</code>, and other related APIs). If <code>TryGetHashCode</code> returns a value indicating the object doesn‚Äôt yet have one, then the operation can early-exit, because for the object to have been stored into the collection, it must have had a hash code generated for it.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private ConditionalWeakTable&lt;SomeObject, Data&gt; _cwt;
    private List&lt;object&gt; _rooted;
    private readonly SomeObject _key = new();

    [GlobalSetup]
    public void Setup()
    {
        _cwt = new();
        _rooted = new();
        for (int i = 0; i &lt; 1000; i++)
        {
            SomeObject key = new();
            _rooted.Add(key);
            _cwt.Add(key, new());
        }
    }

    [Benchmark]
    public int GetValue() =&gt; _cwt.TryGetValue(_key, out Data d) ? d.Value : 0;

    private sealed class SomeObject { }

    private sealed class Data
    {
        public int Value;
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>GetValue</td><td>.NET 7.0</td><td style="text-align: right">4.533 ns</td><td style="text-align: right">1.00</td></tr><tr><td>GetValue</td><td>.NET 8.0</td><td style="text-align: right">3.028 ns</td><td style="text-align: right">0.67</td></tr></tbody></table><p>So, improvements to <code>Dictionary&lt;TKey, TValue&gt;</code>, <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>, <code>ConditionalWeakTable&lt;TKey, TValue&gt;</code>‚Ä¶ are those the ‚Äúend all be all‚Äù of hash table world? Don‚Äôt be silly‚Ä¶</p><h2 id="frozen-collections">Frozen Collections</h2><p>There are many specialized libraries available on NuGet, providing all manner of data structures with this or that optimization or targeted at this or that scenario. Our goal with the core .NET libraries has never been to provide all possible data structures (it‚Äôs actually been a goal not to), but rather to provide the most commonly needed data structures focused on the most commonly needed scenarios, and rely on the ecosystem to provide alternatives where something else is deemed valuable. As a result, we don‚Äôt add new collection types all that frequently; we continually optimize the ones that are there and we routinely augment them with additional functionality, but we rarely introduce brand new collection types. In fact, in the last several years, the only new general-purpose collection type introduced into the core libraries was <code>PriorityQueue&lt;TElement, TPriority&gt;</code> class, which was added in .NET 6. However, enough of a need has presented itself that .NET 8 sees the introduction of not one but two new collection types: <code>System.Collections.Frozen.FrozenDictionary&lt;TKey, TValue&gt;</code> and <code>System.Collections.Frozen.FrozenSet&lt;TKey, TValue&gt;</code>.</p><p>Beyond causing ‚ÄúLet It Go‚Äù to be stuck in your head for the rest of the day (‚Äúyou‚Äôre welcome‚Äù), what benefit do these new types provide, especially when we already have <code>System.Collections.Immutable.ImmutableDictionary&lt;TKey, TValue&gt;</code> and <code>System.Collections.Immutable.ImmutableSet&lt;T&gt;</code>? There are enough similarities between the existing immutable collections and the new frozen collections that the latter are actually included in the <code>System.Collections.Immutable</code> library, which means they‚Äôre also available as part of the <code>System.Collections.Immutable</code> NuGet package. But there are also enough differences to warrant us adding them. In particular, this is an example of where scenario and intended use make a big impact on whether a particular data structure makes sense for your needs.</p><p>Arguably, the existing <code>System.Collections.Immutable</code> collections were misnamed. Yes, they‚Äôre ‚Äúimmutable,‚Äù meaning that once you‚Äôve constructed an instance of one of the collection types, you can‚Äôt change its contents. However, that could have easily been achieved simply by wrapping an immutable facade around one of the existing mutable ones, e.g. an immutable dictionary type that just copied the data into a mutable <code>Dictionary&lt;TKey, TValue&gt;</code> and exposed only reading operations:</p><pre><code class="language-C#">public sealed class MyImmutableDictionary&lt;TKey, TValue&gt; :
    IReadOnlyDictionary&lt;TKey, TValue&gt;
    where TKey : notnull
{
    private readonly Dictionary&lt;TKey, TValue&gt; _data;

    public MyImmutableDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; source) =&gt; _data = source.ToDictionary();

    public bool TryGetValue(TKey key, [MaybeNullWhen(false)] out TValue value) =&gt; _data.TryGetValue(key, out value);

    ...
}</code></pre><p>Yet, if you look at the implementation of <code>ImmutableDictionary&lt;TKey, TValue&gt;</code>, you‚Äôll see a ton of code involved in making the type tick. Why? Because it and its friends are optimized for something very different. In academic nomenclature, the immutable collections are actually ‚Äúpersistent‚Äù collections. A persistent data structure is one that provides mutating operations on the collection (e.g. Add, Remove, etc.) but where those operations don‚Äôt actually change the existing instance, instead resulting in a new instance being created that contains that modification. So, for example, <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> ironically exposes an <code>Add(TKey key, TValue value)</code> method, but this method doesn‚Äôt actually modify the collection instance on which it‚Äôs called; instead, it creates and returns a brand new <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> instance, containing all of the key/value pairs from the original instance as well as the new key/value pair being added. Now, you could imagine that being done simply by copying all of the data to a new <code>Dictionary&lt;TKey, TValue&gt;</code> and adding in the new value, e.g.</p><pre><code class="language-C#">public sealed class MyPersistentDictionary&lt;TKey, TValue&gt; where TKey : notnull
{
    private readonly Dictionary&lt;TKey, TValue&gt; _data;

    public MyPersistentDictionary&lt;TKey, TValue&gt; Add(TKey key, TValue value)
    {
        var newDictionary = new Dictionary&lt;TKey, TValue&gt;(_data);
        newDictionary.Add(key, value);
        return newDictionary;
    }

    ...
}</code></pre><p>but while functional, that‚Äôs terribly inefficient from a memory consumption perspective, as every addition results in a brand new copy of all of the data being made, just to store that one additional pair in the new instance. It‚Äôs also terribly inefficient from an algorithmic complexity perspective, as adding N values would end up being an <code>O(n^2)</code> algorithm (each new item would result in copying all previous items). As such, <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> is optimized to share as much as possible between instances. Its implementation uses an <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL tree</a>, a self-balancing binary search tree. Adding into such a tree not only requires <code>O(log n)</code> time (whereas the full copy shown in <code>MyPersistentDictionary&lt;TKey, TValue&gt;</code> above is <code>O(n)</code>), it also enables reusing entire portions of a tree between instances of dictionaries. If adding a key/value pair doesn‚Äôt require mutating a particular subtree, then both the new and old dictionary instances can point to that same subtree, thereby avoiding significant memory increase. You can see this from a benchmark like the following:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Immutable;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private const int Items = 10_000;

    [Benchmark(Baseline = true)]
    public Dictionary&lt;int, int&gt; DictionaryAdds()
    {
        Dictionary&lt;int, int&gt; d = new();
        for (int i = 0; i &lt; Items; i++)
        {
            var newD = new Dictionary&lt;int, int&gt;(d);
            newD.Add(i, i);
            d = newD;
        }
        return d;
    }

    [Benchmark]
    public ImmutableDictionary&lt;int, int&gt; ImmutableDictionaryAdds()
    {
        ImmutableDictionary&lt;int, int&gt; d = ImmutableDictionary&lt;int, int&gt;.Empty;
        for (int i = 0; i &lt; Items; i++)
        {
            d = d.Add(i, i);
        }
        return d;
    }
}</code></pre><p>which when run on .NET 8 yields the following results for me:</p><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>DictionaryAdds</td><td style="text-align: right">478.961 ms</td><td style="text-align: right">1.000</td></tr><tr><td>ImmutableDictionaryAdds</td><td style="text-align: right">4.067 ms</td><td style="text-align: right">0.009</td></tr></tbody></table><p>That highlights that the tree-based nature of <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> makes it significantly more efficient (~120x better in both throughput and allocation in this run) for <em>this</em> example of performing lots of additions, when compared with using for the same purpose a <code>Dictionary&lt;TKey, TValue&gt;</code> treated as being immutable. And that‚Äôs why these immutable collections came into being in the first place. The C# compiler uses lots and lots of dictionaries and sets and the like, and it employs a lot of concurrency. It needs to enable one thread to ‚Äútear off‚Äù an immutable view of a collection even while other threads are updating the collection, and for such purposes it uses <code>System.Collections.Immutable</code>.</p><p>However, just because the above numbers look amazing doesn‚Äôt mean <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> is always the right tool for the immutable job‚Ä¶ it actually rarely is. Why? Because the exact thing that made it so fast and memory efficient for the above benchmark is also its downfall on one of the most common tasks needed for an ‚Äúimmutable‚Äù dictionary: reading. With its tree-based data structure, not only are adds <code>O(log n)</code>, but lookups are also <code>O(log n)</code>, which for a large dictionary can be extremely inefficient when compared to the <code>O(1)</code> access times of a type like <code>Dictionary&lt;TKey, TValue&gt;</code>. We can see this as well with a simple benchmark. Let‚Äôs say we‚Äôve built up our 10,000-element dictionary as in the previous example, and now we want to query it:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Immutable;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private const int Items = 1_000_000;

    private static readonly Dictionary&lt;int, int&gt; s_d = new Dictionary&lt;int, int&gt;(Enumerable.Range(0, Items).ToDictionary(x =&gt; x, x =&gt; x));
    private static readonly ImmutableDictionary&lt;int, int&gt; s_id = ImmutableDictionary.CreateRange(Enumerable.Range(0, Items).ToDictionary(x =&gt; x, x =&gt; x));

    [Benchmark]
    public int EnumerateDictionary()
    {
        int sum = 0;
        foreach (var pair in s_d) sum++;
        return sum;
    }

    [Benchmark]
    public int EnumerateImmutableDictionary()
    {
        int sum = 0;
        foreach (var pair in s_id) sum++;
        return sum;
    }

    [Benchmark]
    public int IndexerDictionary()
    {
        int sum = 0;
        for (int i = 0; i &lt; Items; i++)
        {
            sum += s_d[i];
        }
        return sum;
    }

    [Benchmark]
    public int IndexerImmutableDictionary()
    {
        int sum = 0;
        for (int i = 0; i &lt; Items; i++)
        {
            sum += s_id[i];
        }
        return sum;
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th></tr></thead><tbody><tr><td>EnumerateImmutableDictionary</td><td style="text-align: right">28.065 ms</td></tr><tr><td>EnumerateDictionary</td><td style="text-align: right">1.404 ms</td></tr><tr><td></td><td style="text-align: right"></td></tr><tr><td>IndexerImmutableDictionary</td><td style="text-align: right">46.538 ms</td></tr><tr><td>IndexerDictionary</td><td style="text-align: right">3.780 ms</td></tr></tbody></table><p>Uh oh. Our <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> in this example is ~12x as expensive for lookups and ~20x as expensive for enumeration as <code>Dictionary&lt;TKey, TValue&gt;</code>. If your process will be spending most of its time performing reads on the dictionary rather than creating it and/or performing mutation, that‚Äôs a lot of cycles being left on the table.</p><p>And that‚Äôs where frozen collections come in. The collections in <code>System.Collections.Frozen</code> are immutable, just as are those in <code>System.Collections.Immutable</code>, but they‚Äôre optimized for a different scenario. Whereas the purpose of a type like <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> is to enable efficient mutation (into a new instance), the purpose of <code>FrozenDictionary&lt;TKey, TValue&gt;</code> is to represent data that never changes, and thus it doesn‚Äôt expose any operations that suggest mutation, only operations for reading. Maybe you‚Äôre loading some configuration data into a dictionary once when your process starts (and then re-loading it only rarely when the configuration changes) and then querying that data over and over and over again. Maybe you‚Äôre creating a mapping from HTTP status codes to delegates representing how those status codes should be handled. Maybe you‚Äôre caching schema information about a set of dynamically-discovered types and then using the resulting parsed information every time you encounter those types later on. Whatever the scenario, you‚Äôre creating an immutable collection that you want to be optimized for reads, and you‚Äôre willing to spend some more cycles creating the collection (because you do it only once, or only once in a while) in order to make reads as fast as possible. That‚Äôs exactly what <code>FrozenDictionary&lt;TKey, TValue&gt;</code> and <code>FrozenSet&lt;T&gt;</code> provide.</p><p>Let‚Äôs update our previous example to now also include <code>FrozenDictionary&lt;TKey, TValue&gt;</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Frozen;
using System.Collections.Immutable;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private const int Items = 10_000;

    private static readonly Dictionary&lt;int, int&gt; s_d = new Dictionary&lt;int, int&gt;(Enumerable.Range(0, Items).ToDictionary(x =&gt; x, x =&gt; x));
    private static readonly ImmutableDictionary&lt;int, int&gt; s_id = ImmutableDictionary.CreateRange(Enumerable.Range(0, Items).ToDictionary(x =&gt; x, x =&gt; x));
    private static readonly FrozenDictionary&lt;int, int&gt; s_fd = FrozenDictionary.ToFrozenDictionary(Enumerable.Range(0, Items).ToDictionary(x =&gt; x, x =&gt; x));

    [Benchmark]
    public int DictionaryGets()
    {
        int sum = 0;
        for (int i = 0; i &lt; Items; i++)
        {
            sum += s_d[i];
        }
        return sum;
    }

    [Benchmark]
    public int ImmutableDictionaryGets()
    {
        int sum = 0;
        for (int i = 0; i &lt; Items; i++)
        {
            sum += s_id[i];
        }
        return sum;
    }

    [Benchmark(Baseline = true)]
    public int FrozenDictionaryGets()
    {
        int sum = 0;
        for (int i = 0; i &lt; Items; i++)
        {
            sum += s_fd[i];
        }
        return sum;
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>ImmutableDictionaryGets</td><td style="text-align: right">360.55 us</td><td style="text-align: right">13.89</td></tr><tr><td>DictionaryGets</td><td style="text-align: right">39.43 us</td><td style="text-align: right">1.52</td></tr><tr><td>FrozenDictionaryGets</td><td style="text-align: right">25.95 us</td><td style="text-align: right">1.00</td></tr></tbody></table><p>Now we‚Äôre talkin‚Äô. Whereas for this lookup test <code>Dictionary&lt;TKey, TValue&gt;</code> was ~9x faster than <code>ImmutableDictionary&lt;TKey, TValue&gt;</code>, <code>FrozenDictionary&lt;TKey, TValue&gt;</code> was 50% faster than even <code>Dictionary&lt;TKey, TValue&gt;</code>.</p><p>How does that improvement happen? Just as <code>ImmutableDictionary&lt;TKey, TValue&gt;</code> doesn‚Äôt just wrap a <code>Dictionary&lt;TKey, TValue&gt;</code>, <code>FrozenDictionary&lt;TKey, TValue&gt;</code> doesn‚Äôt just wrap one, either. It has a customized implementation focused on making read operations as fast as possible, both for lookups and for enumerations. In fact, it doesn‚Äôt have just one implementation; it has many implementations.</p><p>To start to see that, let‚Äôs change the example. In the United States, the Social Security Administration tracks the popularity of baby names. In 2022, the <a href="https://blog.ssa.gov/social-securitys-most-popular-baby-names-for-2022/">most popular baby names</a> for girls were Olivia, Emma, Charlotte, Amelia, Sophia, Isabella, Ava, Mia, Evelyn, and Luna. Here‚Äôs a benchmark that checks to see whether a name is one of those:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Frozen;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly HashSet&lt;string&gt; s_s = new(StringComparer.OrdinalIgnoreCase)
    {
         &quot;Olivia&quot;, &quot;Emma&quot;, &quot;Charlotte&quot;, &quot;Amelia&quot;, &quot;Sophia&quot;, &quot;Isabella&quot;, &quot;Ava&quot;, &quot;Mia&quot;, &quot;Evelyn&quot;, &quot;Luna&quot;
    };
    private static readonly FrozenSet&lt;string&gt; s_fs = s_s.ToFrozenSet(StringComparer.OrdinalIgnoreCase);

    [Benchmark(Baseline = true)]
    public bool HashSet_IsMostPopular() =&gt; s_s.Contains(&quot;Alexandria&quot;);

    [Benchmark]
    public bool FrozenSet_IsMostPopular() =&gt; s_fs.Contains(&quot;Alexandria&quot;);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>HashSet_IsMostPopular</td><td style="text-align: right">9.824 ns</td><td style="text-align: right">1.00</td></tr><tr><td>FrozenSet_IsMostPopular</td><td style="text-align: right">1.518 ns</td><td style="text-align: right">0.15</td></tr></tbody></table><p>Significantly faster. Internally, <code>ToFrozenSet</code> can pick an implementation based on the data supplied, both the type of the data and the exact values being used. In this case, if we print out the type of <code>s_fs</code>, we see:</p><pre><code class="language-text">System.Collections.Frozen.LengthBucketsFrozenSet</code></pre><p>That‚Äôs an implementation detail, but what we‚Äôre seeing here is that the <code>s_fs</code>, even though it‚Äôs strongly-typed as <code>FrozenSet&lt;string&gt;</code>, is actually a derived type named <code>LengthBucketsFrozenSet</code>. <code>ToFrozenSet</code> has analyzed the data supplied to it and chosen a strategy that it thinks will yield the best overall throughput. Part of that is just seeing that the type of the data is <code>string</code>, in which case all the <code>string</code>-based strategies are able to quickly discard queries that can‚Äôt possibly match. In this example, the set will have tracked that the longest string in the collection is ‚ÄúCharlotte‚Äù at only nine characters long; as such, when it‚Äôs asked whether the set contains ‚ÄúAlexandria‚Äù, it can immediately answer ‚Äúno,‚Äù because it does a quick length check and sees that ‚ÄúAlexandria‚Äù at 10 characters can‚Äôt possibly be contained.</p><p>Let‚Äôs take another example. Internal to the C# compiler, it has the notion of ‚Äúspecial types,‚Äù and it has a dictionary that maps from a string-based type name to an <code>enum</code> used to identify that special-type. As a simplified representation of this, I‚Äôve just extracted those strings to create a set:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Frozen;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly HashSet&lt;string&gt; s_s = new()
    {
        &quot;System.Object&quot;, &quot;System.Enum&quot;, &quot;System.MulticastDelegate&quot;, &quot;System.Delegate&quot;, &quot;System.ValueType&quot;, &quot;System.Void&quot;,
        &quot;System.Boolean&quot;, &quot;System.Char&quot;, &quot;System.SByte&quot;, &quot;System.Byte&quot;, &quot;System.Int16&quot;, &quot;System.UInt16&quot;, &quot;System.Int32&quot;,
        &quot;System.UInt32&quot;, &quot;System.Int64&quot;,&quot;System.UInt64&quot;, &quot;System.Decimal&quot;, &quot;System.Single&quot;, &quot;System.Double&quot;, &quot;System.String&quot;,
        &quot;System.IntPtr&quot;, &quot;System.UIntPtr&quot;, &quot;System.Array&quot;, &quot;System.Collections.IEnumerable&quot;, &quot;System.Collections.Generic.IEnumerable`1&quot;,
        &quot;System.Collections.Generic.IList`1&quot;, &quot;System.Collections.Generic.ICollection`1&quot;, &quot;System.Collections.IEnumerator&quot;,
        &quot;System.Collections.Generic.IEnumerator`1&quot;, &quot;System.Collections.Generic.IReadOnlyList`1&quot;, &quot;System.Collections.Generic.IReadOnlyCollection`1&quot;,
        &quot;System.Nullable`1&quot;, &quot;System.DateTime&quot;, &quot;System.Runtime.CompilerServices.IsVolatile&quot;, &quot;System.IDisposable&quot;, &quot;System.TypedReference&quot;,
        &quot;System.ArgIterator&quot;, &quot;System.RuntimeArgumentHandle&quot;, &quot;System.RuntimeFieldHandle&quot;, &quot;System.RuntimeMethodHandle&quot;, &quot;System.RuntimeTypeHandle&quot;,
        &quot;System.IAsyncResult&quot;, &quot;System.AsyncCallback&quot;, &quot;System.Runtime.CompilerServices.RuntimeFeature&quot;, &quot;System.Runtime.CompilerServices.PreserveBaseOverridesAttribute&quot;,
    };
    private static readonly FrozenSet&lt;string&gt; s_fs = s_s.ToFrozenSet();

    [Benchmark(Baseline = true)]
    public bool HashSet_IsSpecial() =&gt; s_s.Contains(&quot;System.Collections.Generic.IEnumerable`1&quot;);

    [Benchmark]
    public bool FrozenSet_IsSpecial() =&gt; s_fs.Contains(&quot;System.Collections.Generic.IEnumerable`1&quot;);
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>HashSet_IsSpecial</td><td style="text-align: right">15.228 ns</td><td style="text-align: right">1.00</td></tr><tr><td>FrozenSet_IsSpecial</td><td style="text-align: right">8.218 ns</td><td style="text-align: right">0.54</td></tr></tbody></table><p>Here the item we‚Äôre searching for is in the collection, so it‚Äôs not getting its performance boost from a fast path to fail out of the search. The concrete type of <code>s_fs</code> in this case sheds some light on it:</p><pre><code class="language-text">System.Collections.Frozen.OrdinalStringFrozenSet_RightJustifiedSubstring</code></pre><p>One of the biggest costs involved in looking up something in a hash table is often the cost of producing the hash in the first place. For a type like <code>int</code>, it‚Äôs trivial, as it‚Äôs literally just its value. But for a type like <code>string</code>, the hash is produced by looking at the string‚Äôs contents and factoring each character into the resulting value. The more characters need to be considered, the more it costs. In this case, the type has identified that in order to differentiate all of the items in the collection, only a subset of them needs to be hashed, such that it only needs to examine a subset of the incoming string to determine what a possible match might be in the collection.</p><p>A bunch of PRs went into making <code>System.Collections.Frozen</code> happen in .NET 8. It started as an internal project used by several services at Microsoft, and was then cleaned up and added as part of <a href="https://github.com/dotnet/runtime/pull/77799">dotnet/runtime#77799</a>. That provided the core types and initial strategy implementations, with <a href="https://github.com/dotnet/runtime/pull/79794">dotnet/runtime#79794</a> following it to provide additional strategies (although we subsequently backed out a few due to lack of motivating scenarios for what their optimizations were targeting).</p><p><a href="https://github.com/dotnet/runtime/pull/81021">dotnet/runtime#81021</a> then removed some virtual dispatch from the string-based implementations. As noted in the previous example, one approach the strategies take is to try to hash less, so there‚Äôs a phase of analysis where the implementation looks at the various substrings in each of the items and determines whether there‚Äôs an offset and length for substring that across all of the items provides an ideal differentiation. For example, consider the strings ‚Äú12a34‚Äù, ‚Äú12b34‚Äù, ‚Äú12c34‚Äù; the analyzer would determine that there‚Äôs no need to hash the whole string, it need only consider the character at index 2, as that‚Äôs enough to uniquely hash the relevant strings. This was initially achieved by using a custom comparer type, but that then meant that virtual dispatch was needed in order to invoke the hashing routine. Instead, this PR created more concrete derived types from <code>FrozenSet</code>/<code>FrozenDictionary</code>, such that the choice of hashing logic was dictated by the choice of concrete collection type to instantiate, saving on the per-operation dispatch.</p><p>In any good story, there‚Äôs a twist, and we encountered a twist with these frozen collection types as well. I‚Äôve already described the scenarios that drove the creation of these types: create once, use <em>a lot</em>. And as such, a lot of attention was paid to overheads involved in reading from the collection, but initially very little time was paid to optimizing construction time. In fact, improving construction time was initially a non-goal, with a willingness to spend as much time as was needed to eke out more throughput for reading. This makes sense if you‚Äôre focusing on long-lived services, where you‚Äôre happy to spend extra seconds once an hour or day or week to optimize something that will then be used many thousands of times per second. However, the equation changes a bit when types like this are exposed in the core libraries, such that the expected number of developers using them, the use cases they have for them, and the variations of data thrown at them grows by orders of magnitude. We started hearing from developers that they were excited to use <code>FrozenDictionary</code>/<code>FrozenSet</code> not just because of performance but also because they were truly immutable, both in implementation and in surface area (e.g. no <code>Add</code> method to confuse things), and that they‚Äôd be interested in employing them in object models, UIs, and so on. At that point, you‚Äôre no longer in the world of ‚Äúwe can take as much time for construction as we want,‚Äù and instead need to be concerned about construction taking inordinate amounts of time and resources.</p><p>As a stop-gap measure, <a href="https://github.com/dotnet/runtime/pull/81194">dotnet/runtime#81194</a> changed the existing <code>ToFrozenDictionary</code>/<code>ToFrozenSet</code> methods to not do any analysis of the incoming data, and instead have both construction time and read throughput in line with that of <code>Dictionary</code>/<code>HashSet</code>. It then added new overloads with a <code>bool optimizeForReading</code> argument, to enable developers to opt-in to those longer construction times in exchange for better read throughput. This wasn‚Äôt an ideal solution, as it meant that it took more discovery and more code for a developer to achieve the primary purpose of these types, but it also helped developers avoid pits of failure by using what looked like a harmless method but could result in significant increases in processing time (one degenerate example I created resulted in <code>ToFrozenDictionary</code> running literally for minutes).</p><p>We then set about to improve the overall performance of the collections, with a bunch of PRs geared towards driving down the costs:</p><ul><li><a href="https://github.com/dotnet/runtime/pull/81389">dotnet/runtime#81389</a> removed various allocations and a dependency from some of the optimizations on the generic math interfaces from .NET 7, such that the optimizations would apply downlevel as well, simplifying the code.</li><li><a href="https://github.com/dotnet/runtime/pull/81603">dotnet/runtime#81603</a> moved some code around to reduce how much code was in a generic context. With Native AOT, with type parameters involving value types, every unique set of type parameters used with these collections results in a unique copy of the code being made, and with all of the various strategies around just in case they‚Äôre necessary to optimize a given set, there‚Äôs potentially a lot of code that gets duplicated. This change was able to shave ~10Kb off each generic instantiation.</li><li><a href="https://github.com/dotnet/runtime/pull/86293">dotnet/runtime#86293</a> made a large number of tweaks, including limiting the maximum length substring that would be evaluated as part of determining the optimal hashing length to employ. This significantly reduced the worst-case running time when supplying problematic inputs.</li><li><a href="https://github.com/dotnet/runtime/pull/84301">dotnet/runtime#84301</a> added similar early-exit optimizations as were seen earlier with string, but for a host of other types, including all the primitives, <code>TimeSpan</code>, <code>Guid</code>, and such. For these types, when no comparer is provided, we can sort the inputs, quickly check whether a supplied input is greater than anything known to be in the collection, and when dealing with a small number of elements such that we don‚Äôt hash at all and instead just do a linear search, we can stop searching once we‚Äôve reached an item in the collection that‚Äôs larger than the one being tested (e.g. if the first item in the sorted list is larger than the one being tested, nothing will match). It‚Äôs interesting why we don‚Äôt just do this for an <code>IComparable&lt;T&gt;</code>; we did, initially, actually, but removed it because of several prominent <code>IComparable&lt;T&gt;</code> implementations that didn‚Äôt work for this purpose. <code>ValueTuple&lt;...&gt;</code>, for example, implements <code>IComparable&lt;ValueTuple&lt;...&gt;&gt;</code>, but the <code>T1</code>, <code>T2</code>, etc. types the <code>ValueTuple&lt;...&gt;</code> wraps may not, and the frozen collections didn‚Äôt have a good way to determine the viability of an <code>IComparable&lt;T&gt;</code> implementation. Instead, this PR added the optimization back with an allow list, such that all the relevant known good types that could be referenced were special-cased.</li><li><a href="https://github.com/dotnet/runtime/pull/87510">dotnet/runtime#87510</a> was the first in a series of PRs to focus significantly on driving down the cost of construction. Its main contribution in this regard was in how collisions are handled. One of the main optimizations employed in the general case by <code>ToFrozenDictionary</code>/<code>ToFrozenSet</code> is to try to drive down the number of collisions in the hash table, since the more collisions there are, the more work will need to be performed during lookups. It does this by populating the table and tracking the number of collisions, and then if there were too many, increasing the size of the table and trying again, repeatedly, until the table has grown large enough that collisions are no longer an issue. This process would hash everything, and then check to make sure it was as good as was desired. This PR changed that to instead bail the moment we knew there were enough collisions that we‚Äôd need to retry, rather than waiting until having processed everything.</li><li><a href="https://github.com/dotnet/runtime/pull/87630">dotnet/runtime#87630</a>, <a href="https://github.com/dotnet/runtime/pull/87688">dotnet/runtime#87688</a>, and <a href="https://github.com/dotnet/runtime/pull/88093">dotnet/runtime#88093</a> in particular improve collections keyed by <code>int</code>s, by avoiding unnecessary work. For example, as part of determining the ideal table size (to minimize collisions), the implementation generates a set of all unique hash codes, eliminating duplicate hash codes because they‚Äôd always collide regardless of the size of the table. But with <code>int</code>s, we can skip this step, because <code>int</code>s are their own hash codes, and so a set of unique <code>int</code>s is guaranteed to be a set of unique hash codes as well. This was then extended to also apply for <code>uint</code>, <code>short</code>/<code>ushort</code>, <code>byte</code>/<code>sbyte</code>, and <code>nint</code>/<code>nuint</code> (in 32-bit processes), as they all similarly use their own value as the hash code.</li><li><a href="https://github.com/dotnet/runtime/pull/87876">dotnet/runtime#87876</a> and <a href="https://github.com/dotnet/runtime/pull/87989">dotnet/runtime#87989</a> improve the ‚ÄúLengthBucket‚Äù strategy referenced in the earlier examples. This implementation buckets strings by their length and then does a lookup just within the strings of that length; if there are only a few strings per length, this can make searching very efficient. The initial implementation used an array of arrays, and this PR flattens that into a single array. This makes construction time much faster for this strategy, as there‚Äôs significantly less allocation involved.</li><li><a href="https://github.com/dotnet/runtime/pull/87960">dotnet/runtime#87960</a> is based on an observation that we would invariably need to resize at least once in order to obtain the desired minimal collision rate, so it simply starts at a higher initial count than was previously being used.</li></ul><p>With all of those optimizations in place, construction time has now improved to the point where it‚Äôs no longer a threat, and <a href="https://github.com/dotnet/runtime/pull/87989">dotnet/runtime#87989</a> effectively reverted <a href="https://github.com/dotnet/runtime/pull/81194">dotnet/runtime#81194</a>, getting rid of the <code>optimizeForReading</code>-based overloads, such that everything is now optimized for reading.</p><p>As an aside, it‚Äôs worth noting that for <code>string</code> keys in particular, the C# compiler has now also gotten in on the game of better optimizing based on the known characteristics of the data, such that if you know all of your <code>string</code> keys at compile-time, and you just need an ordinal, case-sensitive lookup, you might be best off simply writing a <code>switch</code> statement or expression. This is all thanks to <a href="https://github.com/dotnet/roslyn/pull/66081">dotnet/roslyn#66081</a>. Let‚Äôs take the name popularity example from earlier, and express it as a <code>switch</code> statement:</p><pre><code class="language-C#">static bool IsMostPopular(string name)
{
    switch (name)
    {
        case &quot;Olivia&quot;:
        case &quot;Emma&quot;:
        case &quot;Charlotte&quot;:
        case &quot;Amelia&quot;:
        case &quot;Sophia&quot;:
        case &quot;Isabella&quot;:
        case &quot;Ava&quot;:
        case &quot;Mia&quot;:
        case &quot;Evelyn&quot;:
        case &quot;Luna&quot;:
            return true;

        default:
            return false;
    }
}</code></pre><p>Previously compiling this would result in the C# compiler providing a lowered equivalent to this:</p><pre><code class="language-C#">static bool IsMostPopular(string name)
{
    uint num = &lt;PrivateImplementationDetails&gt;.ComputeStringHash(name);
    if (num &lt;= 1803517931)
    {
        if (num &lt;= 452280388)
        {
            if (num != 83419291)
            {
                if (num == 452280388 &amp;&amp; name == &quot;Isabella&quot;)
                    goto IL_012c;
            }
            else if (name == &quot;Olivia&quot;)
                goto IL_012c;
        }
        else if (num != 596915366)
        {
            if (num != 708112360)
            {
                if (num == 1803517931 &amp;&amp; name == &quot;Charlotte&quot;)
                    goto IL_012c;
            }
            else if (name == &quot;Evelyn&quot;)
                goto IL_012c;
        }
        else if (name == &quot;Mia&quot;)
            goto IL_012c;
    }
    else if (num &lt;= 2263917949u)
    {
        if (num != 2234485159u)
        {
            if (num == 2263917949u &amp;&amp; name == &quot;Ava&quot;)
                goto IL_012c;
        }
        else if (name == &quot;Luna&quot;)
            goto IL_012c;
    }
    else if (num != 2346269629u)
    {
        if (num != 3517830433u)
        {
            if (num == 3552467688u &amp;&amp; name == &quot;Amelia&quot;)
                goto IL_012c;
        }
        else if (name == &quot;Sophia&quot;)
            goto IL_012c;
    }
    else if (name == &quot;Emma&quot;)
        goto IL_012c;
    return false;

    IL_012c:
    return true;
}</code></pre><p>If you stare at that for a moment, you‚Äôll see the compiler has implemented a binary search tree. It hashes the name, and then having hashed all of the cases at build time, it does a binary search on the hash codes to find the the right case. Now with the recent improvements, it instead generates an equivalent of this:</p><pre><code class="language-C#">static bool IsMostPopular(string name)
{
    if (name != null)
    {
        switch (name.Length)
        {
            case 3:
                switch (name[0])
                {
                    case &#39;A&#39;:
                        if (name == &quot;Ava&quot;)
                            goto IL_012f;
                        break;
                    case &#39;M&#39;:
                        if (name == &quot;Mia&quot;)
                            goto IL_012f;
                        break;
                }
            case 4:
                switch (name[0])
                {
                    case &#39;E&#39;:
                        if (name == &quot;Emma&quot;)
                            goto IL_012f;
                        break;
                    case &#39;L&#39;:
                        if (name == &quot;Luna&quot;)
                            goto IL_012f;
                        break;
                }
            case 6:
                switch (name[0])
                {
                    case &#39;A&#39;:
                        if (name == &quot;Amelia&quot;)
                            goto IL_012f;
                        break;
                    case &#39;E&#39;:
                        if (name == &quot;Evelyn&quot;)
                            goto IL_012f;
                        break;
                    case &#39;O&#39;:
                        if (name == &quot;Olivia&quot;)
                            goto IL_012f;
                        break;
                    case &#39;S&#39;:
                        if (name == &quot;Sophia&quot;)
                            goto IL_012f;
                        break;
                }
            case 8:
                if (name == &quot;Isabella&quot;)
                    goto IL_012f;
                break;
            case 9:
                if (name == &quot;Charlotte&quot;)
                    goto IL_012f;
                break;
        }
    }
    return false;

    IL_012f:
    return true;
}</code></pre><p>Now what‚Äôs it doing? First, it‚Äôs bucketed the strings by their length; any string that comes in that‚Äôs not 3, 4, 6, 8, or 9 characters long will be immediately rejected. For 8 and 9 characters, there‚Äôs only one possible answer it could be for each, so it simply checks against that string. For the others, it‚Äôs recognized that each name in that length begins with a different letter, and switches over that. In this particular example, the first character in each bucket is a perfect differentiator, but if it wasn‚Äôt, the compiler will also consider other indices to see if any of those might be better differentiators. This is implementing the same basic strategy as the <code>System.Collections.Frozen.LengthBucketsFrozenSet</code> we saw earlier.</p><p>I was careful in my choice above to use a <code>switch</code>. If I‚Äôd instead written the possibly more natural <code>is</code> expression:</p><pre><code class="language-C#">static bool IsMostPopular(string name) =&gt;
    name is &quot;Olivia&quot; or
            &quot;Emma&quot; or
            &quot;Charlotte&quot; or
            &quot;Amelia&quot; or
            &quot;Sophia&quot; or
            &quot;Isabella&quot; or
            &quot;Ava&quot; or
            &quot;Mia&quot; or
            &quot;Evelyn&quot; or
            &quot;Luna&quot;;</code></pre><p>then up until recently the compiler wouldn‚Äôt even have output the binary search, and would have instead just generated a cascading <code>if</code>/<code>else if</code> as if I‚Äôd written:</p><pre><code class="language-C#">static bool IsMostPopular(string name) =&gt;
    name == &quot;Olivia&quot; ||
    name == &quot;Emma&quot; ||
    name == &quot;Charlotte&quot; ||
    name == &quot;Amelia&quot; ||
    name == &quot;Sophia&quot; ||
    name == &quot;Isabella&quot; ||
    name == &quot;Ava&quot; ||
    name == &quot;Mia&quot; ||
    name == &quot;Evelyn&quot; ||
    name == &quot;Luna&quot;;</code></pre><p>With <a href="https://github.com/dotnet/roslyn/pull/65874">dotnet/roslyn#65874</a> from <a href="https://github.com/alrz">@alrz</a>, however, the <code>is</code>-based version is now lowered the same as the <code>switch</code>-based version.</p><p>Back to frozen collections. As noted, <code>System.Collections.Frozen</code> types are in the <code>System.Collections.Immutable</code> library, and they‚Äôre not the only improvements to that library. A variety of new APIs have been added to help enable more productive and efficient use of the existing immutable collections‚Ä¶</p><h2 id="immutable-collections">Immutable Collections</h2><p>For years, developers have found the need to bypass an <code>ImmutableArray&lt;T&gt;</code>‚Äòs immutability. For example, the previously-discussed <code>FrozenDictionary&lt;TKey, TValue&gt;</code> exposes an <code>ImmutableArray&lt;TKey&gt;</code> for its keys and an <code>ImmutableArray&lt;TValue&gt;</code> for its values. It does this by creating a <code>TKey[]</code>, which it uses for a variety of purposes while building up the collection, and then it wants to wrap that as an <code>ImmutableArray&lt;TKey&gt;</code> to be exposed for consumption. But with the public APIs available on <code>ImmutableArray</code>/<code>ImmutableArray&lt;T&gt;</code>, there‚Äôs no way to transfer ownership like that; all the APIs that accept an input <code>T[]</code> or <code>IEnumerable&lt;T&gt;</code> allocate a new array and copy all of the data into it, so that the implementation can be sure no one else is still holding onto a reference to the array being wrapped (if someone was, they could use that mutable reference to mutate the contents of the immutable array, and guarding against that is one of the key differentiators between a read-only collection and an immutable collection). Enabling such wrapping of the original array is thus an ‚Äúunsafe‚Äù operation, albeit one that‚Äôs valuable to enable for developers willing to accept the responsibility. Previously, developers could achieve this by employing a hack that works but only because of implementation detail: using <code>Unsafe.As</code> to cast between the types. When a value type‚Äôs first field is a reference type, a reference to the beginning of the struct is also a reference to the reference type, since they‚Äôre both at the exact same memory location. Thus, because <code>ImmutableArray&lt;T&gt;</code> contains just a single field (for the <code>T[]</code> it wraps), a method like the following will successfully wrap an <code>ImmutableArray&lt;T&gt;</code> around a <code>T[]</code>:</p><pre><code class="language-C#">static ImmutableArray&lt;T&gt; UnsafeWrap&lt;T&gt;(T[] array) =&gt; Unsafe.As&lt;T[], ImmutableArray&lt;T&gt;&gt;(ref array);</code></pre><p>That, however, is both uintuitive and depends on <code>ImmutableArray&lt;T&gt;</code> having the array at a 0-offset from the start of the struct, making it a brittle solution. To provide something robust, <a href="https://github.com/dotnet/runtime/pull/85526">dotnet/runtime#85526</a> added the new <code>System.Runtime.InteropServices.ImmutableCollectionsMarshal</code> class, and on it two new methods: <code>AsImmutableArray</code> and <code>AsArray</code>. These methods support casting back and forth between a <code>T[]</code> and an <code>ImmutableArray&lt;T&gt;</code>, without allocation. They‚Äôre defined in <code>InteropServices</code> on a <code>Marshal</code> class, as that‚Äôs one of the ways we have to both hide more dangerous functionality and declare that something is inherently ‚Äúunsafe‚Äù in some capacity.</p><p>There are also new overloads exposed for constructing immutable collections with less allocation. All of the immutable collections have a corresponding static class that provides a <code>Create</code> method, e.g. <code>ImmutableList&lt;T&gt;</code> has the corresponding static class <code>ImmutableList</code> which provides a <code>static ImmutableList&lt;T&gt; Create&lt;T&gt;(params T[] items)</code> method. Now in .NET 8 as of <a href="https://github.com/dotnet/runtime/pull/87945">dotnet/runtime#87945</a>, these methods all have a new overload that takes a <code>ReadOnlySpan&lt;T&gt;</code>, e.g. <code>static ImmutableList&lt;T&gt; Create&lt;T&gt;(ReadOnlySpan&lt;T&gt; items)</code>. This means an immutable collection can be created without incurring the allocation required to either go through the associated builder (which is a reference type) or to allocate an array of the exact right size.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections.Immutable;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark(Baseline = true)]
    public ImmutableList&lt;int&gt; CreateArray() =&gt; ImmutableList.Create&lt;int&gt;(1, 2, 3, 4, 5);

    [Benchmark]
    public ImmutableList&lt;int&gt; CreateBuilder()
    {
        var builder = ImmutableList.CreateBuilder&lt;int&gt;();
        for (int i = 1; i &lt;= 5; i++) builder.Add(i);
        return builder.ToImmutable();
    }

    [Benchmark]
    public ImmutableList&lt;int&gt; CreateSpan() =&gt; ImmutableList.Create&lt;int&gt;(stackalloc int[] { 1, 2, 3, 4, 5 });
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>CreateBuilder</td><td style="text-align: right">132.22 ns</td><td style="text-align: right">1.42</td><td style="text-align: right">312 B</td><td style="text-align: right">1.00</td></tr><tr><td>CreateArray</td><td style="text-align: right">92.98 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">312 B</td><td style="text-align: right">1.00</td></tr><tr><td>CreateSpan</td><td style="text-align: right">85.54 ns</td><td style="text-align: right">0.92</td><td style="text-align: right">264 B</td><td style="text-align: right">0.85</td></tr></tbody></table><h3 id="bitarray">BitArray</h3><p><a href="https://github.com/dotnet/runtime/pull/81527">dotnet/runtime#81527</a> from <a href="https://github.com/lateapexearlyspeed">@lateapexearlyspeed</a> added two new methods to <code>BitArray</code>, <code>HasAllSet</code> and <code>HasAnySet</code>, which do exactly what their names suggest: <code>HasAllSet</code> returns whether all of the bits in the array are set, and <code>HasAnySet</code> returns whether any of the bits in the array are set. While useful, what I really like about these additions is that they make good use of the <code>ContainsAnyExcept</code> method introduced in .NET 8. <code>BitArray</code>‚Äòs storage is an <code>int[]</code>, where each element in the array represents 32 bits (for the purposes of this discussion, I‚Äôm ignoring the corner-case it needs to deal with of the last element‚Äôs bits not all being used because the count of the collection isn‚Äôt a multiple of 32). Determining whether any bits are set is then simply a matter of doing <code>_array.AsSpan().ContainsAnyExcept(0)</code>. Similarly, determining whether all bits are set is simply a matter of doing <code>!_array.AsSpan().ContainsAnyExcept(-1)</code>. The bit pattern for <code>-1</code> is all 1s, so <code>ContainsAnyExcept(-1)</code> will return true if and only if it finds any integer that doesn‚Äôt have all of its bits set; thus if the call doesn‚Äôt find any, all bits are set. The net result is <code>BitArray</code> gets to maintain simple code that‚Äôs also vectorized and optimized, thanks to delegating to these shared helpers. You can see examples of these methods being used in <a href="https://github.com/dotnet/runtime/pull/82057">dotnet/runtime#82057</a>, which replaced bespoke implementations of the same functionality with the new built-in helpers.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Collections;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly BitArray _bitArray = new BitArray(1024);

    [Benchmark(Baseline = true)]
    public bool HasAnySet_Manual()
    {
        for (int i = 0; i &lt; _bitArray.Length; i++)
        {
            if (_bitArray[i])
            {
                return true;
            }
        }

        return false;
    }

    [Benchmark]
    public bool HasAnySet_BuiltIn() =&gt; _bitArray.HasAnySet();
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>HasAnySet_Manual</td><td style="text-align: right">731.041 ns</td><td style="text-align: right">1.000</td></tr><tr><td>HasAnySet_BuiltIn</td><td style="text-align: right">5.423 ns</td><td style="text-align: right">0.007</td></tr></tbody></table><h3 id="collection-expressions">Collection Expressions</h3><p>With <a href="https://github.com/dotnet/roslyn/pull/68831">dotnet/roslyn#68831</a> and then a myriad of subsequent PRs, C# 12 introduces a new terse syntax for constructing collections: ‚Äúcollection expressions.‚Äù Let‚Äôs say I want to construct a <code>List&lt;int&gt;</code>, for example, with the elements 1, 2, and 3. I could do it like so:</p><pre><code class="language-C#">var list = new List&lt;int&gt;();
list.Add(1);
list.Add(2);
list.Add(3);</code></pre><p>or utilizing collection initializers that were added in C# 3:</p><pre><code class="language-C#">var list = new List&lt;int&gt;() { 1, 2, 3 };</code></pre><p>Now in C# 12, I can write that as:</p><pre><code class="language-C#">List&lt;int&gt; list = [1, 2, 3];</code></pre><p>I can also use ‚Äúspreads,‚Äù where enumerables can be used in the syntax and have all of their contents splat into the collection. For example, instead of:</p><pre><code class="language-C#">var list = new List&lt;int&gt;() { 1, 2 };
foreach (int i in GetData())
{
    list.Add(i);
}
list.Add(3);</code></pre><p>or:</p><pre><code class="language-C#">var list = new List&lt;int&gt;() { 1, 2 };
list.AddRange(GetData());
list.Add(3);</code></pre><p>I can simply write:</p><pre><code class="language-C#">List&lt;int&gt; list = [1, 2, ..GetData(), 3];</code></pre><p>If it were just a simpler syntax for collections, it wouldn‚Äôt be worth discussing in this particular post. What makes it relevant from a performance perspective, however, is that the C# compiler is free to optimize this however it sees fit, and it goes to great lengths to write the best code it can for the given circumstance; some optimizations are already in the compiler, more will be in place by the time .NET 8 and C# 12 are released, and even more will come later, with the language specified in such a way that gives the compiler the freedom to innovate here. Let‚Äôs take a few examples‚Ä¶</p><p>If you write:</p><pre><code class="language-C#">IEnumerable&lt;int&gt; e = [];</code></pre><p>the compiler won‚Äôt just translate that into:</p><pre><code class="language-C#">IEnumerable&lt;int&gt; e = new int[0];</code></pre><p>After all, we have a perfectly good singleton for this in the way of <code>Array.Empty&lt;int&gt;()</code>, something the compiler already emits use of for things like <code>params T[]</code>, and it can emit the same thing here:</p><pre><code class="language-C#">IEnumerable&lt;int&gt; e = Array.Empty&lt;int&gt;();</code></pre><p>Ok, what about the optimizations we previously saw around the compiler lowering the creation of an array involving only constants and storing that directly into a <code>ReadOnlySpan&lt;T&gt;</code>? Yup, that applies here, too. So, instead of writing:</p><pre><code class="language-C#">ReadOnlySpan&lt;int&gt; daysToMonth365 = new int[] { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };</code></pre><p>you can write:</p><pre><code class="language-C#">ReadOnlySpan&lt;int&gt; daysToMonth365 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];</code></pre><p>and the exact same code results.</p><p>What about <code>List&lt;T&gt;</code>? Earlier in the discussion of collections we saw that <code>List&lt;T&gt;</code> now sports an <code>AddRange(ReadOnlySpan&lt;T&gt;)</code>, and the compiler is free to use that. For example, if you write this:</p><pre><code class="language-C#">Span&lt;int&gt; source1 = ...;
IList&lt;int&gt; source2 = ...;
List&lt;int&gt; result = [1, 2, ..source1, ..source2];</code></pre><p>the compiler could emit the equivalent of this:</p><pre><code class="language-C#">Span&lt;int&gt; source1 = ...;
IList&lt;int&gt; source2 = ...;
List&lt;int&gt; result = new List&lt;int&gt;(2 + source1.Length + source2.Count);
result.Add(1);
result.Add(2);
result.AddRange(source1);
result.AddRange(source2);</code></pre><p>One of my favorite optimizations it achieves, though, is with spans and the use of the <code>[InlineArray]</code> attribute we already saw. If you write:</p><pre><code class="language-C#">int a = ..., b = ..., c = ..., d = ..., e = ..., f = ..., g = ..., h = ...;
Span&lt;int&gt; span = [a, b, c, d, e, f, g, h];</code></pre><p>the compiler can lower that to code along the lines of this:</p><pre><code class="language-C#">int a = ..., b = ..., c = ..., d = ..., e = ..., f = ..., g = ..., h = ...;
&lt;&gt;y__InlineArray8&lt;int&gt; buffer = default;
Span&lt;int&gt; span = buffer;
span[0] = a;
span[1] = b;
span[2] = c;
span[3] = d;
span[4] = e;
span[5] = f;
span[6] = g;
span[7] = h;
...
[InlineArray(8)]
internal struct &lt;&gt;y__InlineArray8&lt;T&gt;
{
    private T _element0;
}</code></pre><p>In short, this collection expression syntax becomes <em>the</em> way to utilize <code>[InlineArray]</code> in the vast majority of situations, allowing the compiler to create a shared definition for you.</p><p>That optimization also feeds into another, which is both an optimization and a functional improvement over what‚Äôs in C# 11. Let‚Äôs say you have this code‚Ä¶ what do you expect it to print?</p><pre><code class="language-C#">// dotnet run -f net8.0

using System.Collections.Immutable;

ImmutableArray&lt;int&gt; array = new ImmutableArray&lt;int&gt; { 1, 2, 3 };
foreach (int i in array)
{
    Console.WriteLine(i);
}</code></pre><p>Unless you‚Äôre steeped in <code>System.Collections.Immutable</code> and how collection initializers work, you likely didn‚Äôt predict the (unfortunate) answer:</p><pre><code class="language-text">Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.
   at System.Collections.Immutable.ImmutableArray`1.get_IsEmpty()
   at System.Collections.Immutable.ImmutableArray`1.Add(T item)
   at Program.&lt;Main&gt;$(String[] args)</code></pre><p><code>ImmutableArray&lt;T&gt;</code> is a struct, so this will end up using its default initialization, which contains a <code>null</code> array. But even if that was made to work, the C# compiler will have lowered the code I wrote to the equivalent of this:</p><pre><code class="language-C#">ImmutableArray&lt;int&gt; immutableArray = default;
immutableArray.Add(1);
immutableArray.Add(2);
immutableArray.Add(3);
foreach (int i in immutableArray)
{
    Console.WriteLine(enumerator.Current);
}</code></pre><p>which is ‚Äúwrong‚Äù in multiple ways. <code>ImmutableArray&lt;int&gt;.Add</code> doesn‚Äôt actually mutate the original collection, but instead returns a new instance that contains the additional element, so when we enumerate <code>immutableArray</code>, we wouldn‚Äôt see any of the additions. Plus, we‚Äôre doing all this work and allocation to create the results of <code>Add</code>, only to drop those results on the floor.</p><p>Collection expressions fix this. Now you can write this:</p><pre><code class="language-C#">// dotnet run -f net8.0

using System.Collections.Immutable;

ImmutableArray&lt;int&gt; array = [1, 2, 3];
foreach (int i in array)
{
    Console.WriteLine(i);
}</code></pre><p>and running it successfully produces:</p><pre><code class="language-text">1
2
3</code></pre><p>Why? Because <a href="https://github.com/dotnet/runtime/pull/88470">dotnet/runtime#88470</a> added a new <code>[CollectionBuilder]</code> attribute that‚Äôs recognized by the C# compiler. That attribute is placed on a type and points to a factory method for creating that type, accepting a <code>ReadOnlySpan&lt;T&gt;</code> and returning the instance constructed from that data. That PR also tagged <code>ImmutableArray&lt;T&gt;</code> with this attribute:</p><pre><code class="language-C#">[CollectionBuilder(typeof(ImmutableArray), nameof(ImmutableArray.Create))]</code></pre><p>such that when the compiler sees an <code>ImmutableArray&lt;T&gt;</code> being constructed from a collection expression, it runs to use <code>ImmutableArray.Create&lt;T&gt;(ReadOnlySpan&lt;T&gt;)</code>. Not only that, it‚Äôs able to use the <code>[InlineArray]</code>-based optimization we just talked about for creating that input. As such, the code the compiler generates for this example as of today is equivalent to this:</p><pre><code class="language-C#">&lt;&gt;y__InlineArray3&lt;int&gt; buffer = default;
buffer._element = 1;
Unsafe.Add(ref buffer._element, 1) = 2;
Unsafe.Add(ref buffer._element, 2) = 3;
ImmutableArray&lt;int&gt; array = ImmutableArray.Create(buffer);
foreach (int i in array)
{
    Console.WriteLine(array);
}</code></pre><p><code>ImmutableList&lt;T&gt;</code>, <code>ImmutableStack&lt;T&gt;</code>, <code>ImmutableQueue&lt;T&gt;</code>, <code>ImmutableHashSet&lt;T&gt;</code>, and <code>ImmutableSortedSet&lt;T&gt;</code> are all similarly attributed such that they all work with collection expressions as well.</p><p>Of course, the compiler could actually do a bit better for <code>ImmutableArray&lt;T&gt;</code>. As was previously noted, the compiler is free to optimize these how it sees fit, and we already mentioned the new <code>ImmutableCollectionsMarshal.AsImmutableArray</code> method. As I write this, the compiler doesn‚Äôt currently employ that method, but in the future the compiler can special-case <code>ImmutableArray&lt;T&gt;</code>, such that it could then generate code equivalent to the following:</p><pre><code class="language-C#">ImmutableArray&lt;int&gt; array = ImmutableCollectionsMarshal.AsImmutableArray(new[] { 1, 2, 3 });</code></pre><p>saving on both stack space as well as an extra copy of the data. This is just one of the additional optimizations possible.</p><p>In short, collection expressions are intended to be a great way to express the collection you want built, and the compiler will ensure it‚Äôs done efficiently.</p><h2 id="file-i-o">File I/O</h2><p>.NET 6 overhauled how file I/O is implemented in .NET, rewriting <code>FileStream</code>, introducing the <code>RandomAccess</code> class, and a multitude of other changes. .NET 8 continues to improve performance with file I/O further.</p><p>One of the more interesting ways performance of a system can be improved is cancellation. After all, the fastest work is work you don‚Äôt have to do at all, and cancellation is about stopping doing unneeded work. The original patterns for asynchrony in .NET were based on a non-cancelable model (see <a href="https://devblogs.microsoft.com/dotnet/how-async-await-really-works/">How Async/Await Really Works in C#</a> for an in-depth history and discussion), and over time as all of that support has shifted to the <code>Task</code>-based model based on <code>CancellationToken</code>, more and more implementations have become fully cancelable as well. As of .NET 7, the vast majority of code paths that accepted a <code>CancellationToken</code> actually respected it, more than just doing an up-front check to see whether cancellation was already requested but then not paying attention to it during the operation. Most of the holdouts have been very corner-case, but there‚Äôs one notable exception: <code>FileStream</code>s created without <code>FileOptions.Asynchronous</code>.</p><p><code>FileStream</code> inherited the bifurcated model of asynchrony from Windows, where at the time you open a file handle you need to specify whether it‚Äôs being opened for synchronous or asynchronous (‚Äúoverlapped‚Äù) access. A file handle opened for overlapped access requires that all operations be asynchronous, and vice versa if it‚Äôs opened for non-overlapped access requires that all operations be synchronous. That causes some friction with <code>FileStream</code>, which exposes both synchronous (e.g. <code>Read</code>) and asynchronous (e.g. <code>ReadAsync</code>) methods, as it means that one set of those needs to emulate the behavior. If the <code>FileStream</code> is opened for asynchronous access, then <code>Read</code> needs to do the operation asynchronously and block waiting for it complete (a pattern we less-than-affectionately refer to as <a href="https://devblogs.microsoft.com/pfxteam/should-i-expose-synchronous-wrappers-for-asynchronous-methods/">‚Äúsync-over-async‚Äù</a>), and if the <code>FileStream</code> is opened for synchronous access, then <code>ReadAsync</code> needs to queue a work item that will do the operation synchronously (<a href="https://devblogs.microsoft.com/pfxteam/should-i-expose-asynchronous-wrappers-for-synchronous-methods/">‚Äúasync-over-sync‚Äù</a>). Even though that <code>ReadAsync</code> method accepts a <code>CancellationToken</code>, the actual synchronous <code>Read</code> that ends up being invoked as part of a <code>ThreadPool</code> work item hasn‚Äôt been cancelable. Now in .NET 8, thanks to <a href="https://github.com/dotnet/runtime/pull/87103">dotnet/runtime#87103</a>, it is, at least on Windows.</p><p>In .NET 7, <code>PipeStream</code> was fixed for this same case, relying on an internal <code>AsyncOverSyncWithIoCancellation</code> helper that would use the Win32 <code>CancelSynchronousIo</code> to interrupt pending I/O, while also using appropriate synchronization to ensure that only the intended associated work was interrupted and not work that happened to be running on the same worker thread before or after (Linux already fully supported <code>PipeStream</code> cancellation as of .NET 5). This PR adapted that same helper to then be usable as well inside of <code>FileStream</code> on Windows, in order to gain the same benefits. The same PR also further improved the implementation of that helper to reduce allocation and to further streamline the processing, such that the existing support in <code>PipeStream</code> gets leaner as well.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.IO.Pipes;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly CancellationTokenSource _cts = new();
    private readonly byte[] _buffer = new byte[1];
    private AnonymousPipeServerStream _server;
    private AnonymousPipeClientStream _client;

    [GlobalSetup]
    public void Setup()
    {
        _server = new AnonymousPipeServerStream(PipeDirection.Out);
        _client = new AnonymousPipeClientStream(PipeDirection.In, _server.ClientSafePipeHandle);
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        _server.Dispose();
        _client.Dispose();
    }

    [Benchmark(OperationsPerInvoke = 100_000)]
    public async Task ReadWriteAsync()
    {
        for (int i = 0; i &lt; 100_000; i++)
        {
            ValueTask&lt;int&gt; read = _client.ReadAsync(_buffer, _cts.Token);
            await _server.WriteAsync(_buffer, _cts.Token);
            await read;
        }
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>ReadWriteAsync</td><td>.NET 7.0</td><td style="text-align: right">3.863 us</td><td style="text-align: right">1.00</td><td style="text-align: right">181 B</td><td style="text-align: right">1.00</td></tr><tr><td>ReadWriteAsync</td><td>.NET 8.0</td><td style="text-align: right">2.941 us</td><td style="text-align: right">0.76</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>Interacting with paths via <code>Path</code> and <code>File</code> has also improved in various ways. <a href="https://github.com/dotnet/runtime/pull/74855">dotnet/runtime#74855</a> improved <code>Path.GetTempFileName()</code> on Windows both functionally and for performance; in many situations in the past, we‚Äôve made the behavior of .NET on Unix match the behavior of .NET on Windows, but this PR interestingly goes in the other direction. On Unix, <code>Path.GetTempFileName()</code> uses the libc <code>mkstemp</code> function, which accepts a template that must end in ‚ÄúXXXXXX‚Äù (6 <code>X</code>s), and it populates those <code>X</code>s with random values, using the resulting name for a new file that gets created. On Windows, <code>GetTempFileName()</code> was using the Win32 <code>GetTempFileNameW</code> function, which uses a similar pattern but with only 4 <code>X</code>s. With the characters Windows will fill in, that enables only 65,536 possible names, and as the temp directory fills up, it becomes more and more likely there will be conflicts, leading to longer and longer times for creating a temp file (it also means that on Windows <code>Path.GetTempFileName()</code> has been limited to creating 65,536 simultaneously-existing files). This PR changes the format on Windows to match that used on Unix, and avoids the use of <code>GetTempFileNameW</code>, instead doing the random name assignment and retries-on-conflict itself. The net result is more consistency across OSes, a much larger number of temporary files possible (a billion instead of tens of thousands), as well as a better-performing method:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0
// NOTE: The results for this benchmark will vary wildly based on how full the temp directory is.

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly List&lt;string&gt; _files = new();

    // NOTE: The performance of this benchmark is highly influenced by what&#39;s currently in your temp directory.
    [Benchmark]
    public void GetTempFileName()
    {
        for (int i = 0; i &lt; 1000; i++) _files.Add(Path.GetTempFileName());
    }

    [IterationCleanup]
    public void Cleanup()
    {
        foreach (string path in _files) File.Delete(path);
        _files.Clear();
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>GetTempFileName</td><td>.NET 7.0</td><td style="text-align: right">1,947.8 ms</td><td style="text-align: right">1.00</td></tr><tr><td>GetTempFileName</td><td>.NET 8.0</td><td style="text-align: right">276.5 ms</td><td style="text-align: right">0.34</td></tr></tbody></table><p><code>Path.GetFileName</code> is another on the list of methods that improves, thanks to making use of <code>IndexOf</code> methods. Here, <a href="https://github.com/dotnet/runtime/pull/75318">dotnet/runtime#75318</a> uses <code>LastIndexOf</code> (on Unix, where the only directory separator is <code>&#39;/&#39;</code>) or <code>LastIndexOfAny</code> (on Windows, where both <code>&#39;/&#39;</code> and <code>&#39;\&#39;</code> can be a directory separator) to search for the beginning of the file name.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private string _path = Path.Join(Path.GetTempPath(), &quot;SomeFileName.cs&quot;);

    [Benchmark]
    public ReadOnlySpan&lt;char&gt; GetFileName() =&gt; Path.GetFileName(_path.AsSpan());
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>GetFileName</td><td>.NET 7.0</td><td style="text-align: right">9.465 ns</td><td style="text-align: right">1.00</td></tr><tr><td>GetFileName</td><td>.NET 8.0</td><td style="text-align: right">4.733 ns</td><td style="text-align: right">0.50</td></tr></tbody></table><p>Related to <code>File</code> and <code>Path</code>, various methods on <code>Environment</code> also return paths. <code>Microsoft.Extensions.Hosting.HostingHostBuilderExtensions</code> had been using <code>Environment.GetSpecialFolder(Environment.SpecialFolder.System)</code> to get the system path, but this was leading to noticeable overhead when starting up an ASP.NET application. <a href="https://github.com/dotnet/runtime/pull/83564">dotnet/runtime#83564</a> changed this to use <code>Environment.SystemDirectory</code> directly, which on Windows takes advantage of the much more efficient path (and resulting in simpler code), but then <a href="https://github.com/dotnet/runtime/pull/83593">dotnet/runtime#83593</a> also fixed <code>Environment.GetSpecialFolder(Environment.SpecialFolder.System)</code> on Windows to use <code>Environment.SystemDirectory</code>, such that its performance accrues to the higher-level uses as well.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark]
    public string GetFolderPath() =&gt; Environment.GetFolderPath(Environment.SpecialFolder.System);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>GetFolderPath</td><td>.NET 7.0</td><td style="text-align: right">1,560.87 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">88 B</td><td style="text-align: right">1.00</td></tr><tr><td>GetFolderPath</td><td>.NET 8.0</td><td style="text-align: right">45.76 ns</td><td style="text-align: right">0.03</td><td style="text-align: right">64 B</td><td style="text-align: right">0.73</td></tr></tbody></table><p><a href="https://github.com/dotnet/runtime/pull/73983">dotnet/runtime#73983</a> improves <code>DirectoryInfo</code> and <code>FileInfo</code>, making the <code>FileSystemInfo.Name</code> property lazy. Previously when constructing the info object if only the full name existed (and not the name of just the directory or file itself), the constructor would promptly create the <code>Name</code> string, even if the info object is never used (as is often the case when it‚Äôs returned from a method like <code>CreateDirectory</code>). Now, that <code>Name</code> string is lazily created on first use of the <code>Name</code> property.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly string _path = Environment.CurrentDirectory;

    [Benchmark]
    public DirectoryInfo Create() =&gt; new DirectoryInfo(_path);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Create</td><td>.NET 7.0</td><td style="text-align: right">225.0 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">240 B</td><td style="text-align: right">1.00</td></tr><tr><td>Create</td><td>.NET 8.0</td><td style="text-align: right">170.1 ns</td><td style="text-align: right">0.76</td><td style="text-align: right">200 B</td><td style="text-align: right">0.83</td></tr></tbody></table><p><code>File.Copy</code> has gotten a whole lot faster on macOS, thanks to <a href="https://github.com/dotnet/runtime/pull/79243">dotnet/runtime#79243</a> from <a href="https://github.com/hamarb123">@hamarb123</a>. <code>File.Copy</code> now employs the OS‚Äôs <code>clonefile</code> function (if available) to perform the copy, and if both the source and destination are on the same volume, <code>clonefile</code> creates a copy-on-write clone of the file in the destination; this makes the copy at the OS level much faster, incurring the majority cost of actually duplicating the data only occurring if one of the files is subsequently written to.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;Min&quot;, &quot;Max&quot;)]
public class Tests
{
    private string _source;
    private string _dest;

    [GlobalSetup]
    public void Setup()
    {
        _source = Path.GetTempFileName();
        File.WriteAllBytes(_source, Enumerable.Repeat((byte)42, 1_000_000).ToArray());
        _dest = Path.GetRandomFileName();
    }

    [Benchmark]
    public void FileCopy() =&gt; File.Copy(_source, _dest, overwrite: true);

    [GlobalCleanup]
    public void Cleanup()
    {
        File.Delete(_source);
        File.Delete(_dest);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>FileCopy</td><td>.NET 7.0</td><td style="text-align: right">1,624.8 us</td><td style="text-align: right">1.00</td></tr><tr><td>FileCopy</td><td>.NET 8.0</td><td style="text-align: right">366.7 us</td><td style="text-align: right">0.23</td></tr></tbody></table><p>Some more specialized changes have been incorporated as well. <code>TextWriter</code> is a core abstraction for writing text to an arbitrary destination, but sometimes you want that destination to be nowhere, a la <code>/dev/null</code> on Linux. For this, <code>TextWriter</code> provides the <code>TextWriter.Null</code> property, which returns a <code>TextWriter</code> instance that nops on all of its members. Or, at least that‚Äôs the visible behavior. In practice, only a subset of its members were actually overridden, which meant that although nothing would end up being output, some work might still be incurred and then the fruits of that labor thrown away. <a href="https://github.com/dotnet/runtime/pull/83293">dotnet/runtime#83293</a> ensures that all of the writing methods are overridden in order to do away with all of that wasted work.</p><p>Further, one of the places <code>TextWriter</code> ends up being used is in <code>Console</code>, where <code>Console.SetOut</code> allows you to replace <code>stdout</code> with your own writer, at which point all of the writing methods on <code>Console</code> output to that <code>TextWriter</code> instead. In order to provide thread-safety of writes, <code>Console</code> synchronizes access to the underlying writer, but if the writer is doing nops anyway, there‚Äôs no need for that synchronization. <a href="https://github.com/dotnet/runtime/pull/83296">dotnet/runtime#83296</a> does away with it in that case, such that if you want to temporarily silence <code>Console</code>, you can simply set its output to go to <code>TextWriter.Null</code>, and the overhead of operations on <code>Console</code> will be minimized.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly string _value = &quot;42&quot;;

    [GlobalSetup]
    public void Setup() =&gt; Console.SetOut(TextWriter.Null);

    [Benchmark]
    public void WriteLine() =&gt; Console.WriteLine(&quot;The value was {0}&quot;, _value);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>WriteLine</td><td>.NET 7.0</td><td style="text-align: right">80.361 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">56 B</td><td style="text-align: right">1.00</td></tr><tr><td>WriteLine</td><td>.NET 8.0</td><td style="text-align: right">1.743 ns</td><td style="text-align: right">0.02</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><h2 id="networking">Networking</h2><p>Networking is the heart and soul of most modern services and applications, which makes it all the more important that .NET‚Äôs networking stack shine.</p><h3 id="networking-primitives">Networking Primitives</h3><p>Let‚Äôs start at the bottom of the networking stack, looking at some primitives. Most of these improvements are around formatting, parsing, and manipulation as bytes. Take <a href="https://github.com/dotnet/runtime/pull/75872">dotnet/runtime#75872</a>, for example, which improved the performance of various such operations on <code>IPAddress</code>. <code>IPAddress</code> stores a <code>uint</code> that‚Äôs used as the address when it‚Äôs representing an IPv4 address, and it stores a <code>ushort[8]</code> that‚Äôs used when it‚Äôs representing an IPv6 address. A <code>ushort</code> is two bytes, so a <code>ushort[8]</code> is 16 bytes, or 128 bits. ‚Äú128 bits‚Äù is a very convenient number when performing certain operations, as such a value can be manipulated as a <code>Vector128&lt;&gt;</code> (accelerating computation on systems that accelerate it, which is most). This PR takes advantage of that to optimize common operations with an <code>IPAddress</code>. The <code>IPAddress</code> constructor, for example, is handed a <code>ReadOnlySpan&lt;byte&gt;</code> for an IPv6 address, which it needs to read into its <code>ushort[8]</code>; previously that was done with a loop over the input, but now it‚Äôs handled with a single vector: load the single vector, possibly reverse the endianness (which can be done in just three instructions: OR together the vector shifted left by one byte and shifted right by one byte), and store it.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly IPAddress _addr = IPAddress.Parse(&quot;2600:141b:13:781::356e&quot;);
    private readonly byte[] _ipv6Bytes = IPAddress.Parse(&quot;2600:141b:13:781::356e&quot;).GetAddressBytes();

    [Benchmark] public IPAddress NewIPv6() =&gt; new IPAddress(_ipv6Bytes, 0);
    [Benchmark] public bool WriteBytes() =&gt; _addr.TryWriteBytes(_ipv6Bytes, out _);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>NewIPv6</td><td>.NET 7.0</td><td style="text-align: right">36.720 ns</td><td style="text-align: right">1.00</td></tr><tr><td>NewIPv6</td><td>.NET 8.0</td><td style="text-align: right">16.715 ns</td><td style="text-align: right">0.45</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>WriteBytes</td><td>.NET 7.0</td><td style="text-align: right">14.443 ns</td><td style="text-align: right">1.00</td></tr><tr><td>WriteBytes</td><td>.NET 8.0</td><td style="text-align: right">2.036 ns</td><td style="text-align: right">0.14</td></tr></tbody></table><p><code>IPAddress</code> now also implements <code>ISpanFormattable</code> and <code>IUtf8SpanFormattable</code>, thanks to <a href="https://github.com/dotnet/runtime/pull/82913">dotnet/runtime#82913</a> and <a href="https://github.com/dotnet/runtime/pull/84487">dotnet/runtime#84487</a>. That means, for example, that using an <code>IPAddress</code> as part of string interpolation no longer needs to allocate an intermediate string. As part of this, some changes were made to <code>IPAddress</code> formatting to streamline it. It‚Äôs a bit harder to measure these changes, though, because <code>IPAddress</code> caches a string it creates, such that subsequent <code>ToString</code> calls just return the previous string created. To work around that, we can use private reflection to null out the field (<em>never</em> do this in a real code; private reflection against the core libraries is very much unsupported).</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;
using System.Reflection;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private IPAddress _address;
    private FieldInfo _toStringField;

    [GlobalSetup]
    public void Setup()
    {
        _address = IPAddress.Parse(&quot;123.123.123.123&quot;);
        _toStringField = typeof(IPAddress).GetField(&quot;_toString&quot;, BindingFlags.NonPublic | BindingFlags.Instance);
    }

    [Benchmark]
    public string NonCachedToString()
    {
        _toStringField.SetValue(_address, null);
        return _address.ToString();
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>NonCachedToString</td><td>.NET 7.0</td><td style="text-align: right">92.63 ns</td><td style="text-align: right">1.00</td></tr><tr><td>NonCachedToString</td><td>.NET 8.0</td><td style="text-align: right">75.53 ns</td><td style="text-align: right">0.82</td></tr></tbody></table><p>Unfortunately, such use of reflection has a non-trivial amount of overhead associated with it, which then decreases the perceived benefit from the improvement. Instead, we can use reflection emit either directly or via <code>System.Linq.Expression</code> to emit a custom helper that makes it less expensive to null out that private field.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Linq.Expressions;
using System.Net;
using System.Reflection;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private IPAddress _address;
    private Action&lt;IPAddress, string&gt; _setter;

    [GlobalSetup]
    public void Setup()
    {
        _address = IPAddress.Parse(&quot;123.123.123.123&quot;);
        _setter = BuildSetter&lt;IPAddress, string&gt;(typeof(IPAddress).GetField(&quot;_toString&quot;, BindingFlags.NonPublic | BindingFlags.Instance));
    }

    [Benchmark]
    public string NonCachedToString()
    {
        _setter(_address, null);
        return _address.ToString();
    }

    private static Action&lt;TSource, TArg&gt; BuildSetter&lt;TSource, TArg&gt;(FieldInfo field)
    {
        ParameterExpression target = Expression.Parameter(typeof(TSource));
        ParameterExpression value = Expression.Parameter(typeof(TArg));
        return Expression.Lambda&lt;Action&lt;TSource, TArg&gt;&gt;(
            Expression.Assign(Expression.Field(target, field), value),
            target,
            value).Compile();
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>NonCachedToString</td><td>.NET 7.0</td><td style="text-align: right">48.39 ns</td><td style="text-align: right">1.00</td></tr><tr><td>NonCachedToString</td><td>.NET 8.0</td><td style="text-align: right">36.30 ns</td><td style="text-align: right">0.75</td></tr></tbody></table><p>But .NET 8 actually includes a feature that streamlines this; the feature‚Äôs primary purpose is in support of scenarios like source generators with Native AOT, but it‚Äôs useful for this kind of benchmarking, too. The new <code>UnsafeAccessor</code> attribute (introduced in and supported by <a href="https://github.com/dotnet/runtime/pull/86932">dotnet/runtime#86932</a>, <a href="https://github.com/dotnet/runtime/pull/88626">dotnet/runtime#88626</a>, and <a href="https://github.com/dotnet/runtime/pull/88925">dotnet/runtime#88925</a>) lets you define an <code>extern</code> method that bypasses visibility. In this case, I‚Äôve used it to get a <code>ref</code> to the private field, at which point I can just assign <code>null</code> through the <code>ref</code>.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly IPAddress _address = IPAddress.Parse(&quot;123.123.123.123&quot;);

    [Benchmark]
    public string NonCachedToString()
    {
        _toString(_address) = null;
        return _address.ToString();

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = &quot;_toString&quot;)]
        extern static ref string _toString(IPAddress c);
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th></tr></thead><tbody><tr><td>NonCachedToString</td><td style="text-align: right">34.42 ns</td></tr></tbody></table><p><code>Uri</code> is another networking primitive that saw multiple improvements. <a href="https://github.com/dotnet/runtime/pull/80469">dotnet/runtime#80469</a> removed a variety of allocations, primarily around substrings that were instead replaced by spans. <a href="https://github.com/dotnet/runtime/pull/90087">dotnet/runtime#90087</a> replaced unsafe code as part of scheme parsing with safe span-based code, making it both safer and faster. But <a href="https://github.com/dotnet/runtime/pull/88012">dotnet/runtime#88012</a> is more interesting, as it made <code>Uri</code> implement <code>ISpanFormattable</code>. That means that when, for example, a <code>Uri</code> is used as an argument to an interpolated string, the <code>Uri</code> can now format itself directly to the underlying buffer rather than needing to allocate a temporary string that‚Äôs then added in. This can be particularly useful for reducing the costs of logging and other forms of telemetry. It‚Äôs a little difficult to isolate just the formatting aspect of a <code>Uri</code> for benchmarking purposes, as <code>Uri</code> caches information gathered in the process, but even with constructing a new one each time you can see gains:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    [Benchmark]
    public string Interpolate() =&gt; $&quot;Uri: {new Uri(&quot;http://dot.net&quot;)}&quot;;
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Interpolate</td><td>.NET 7.0</td><td style="text-align: right">356.3 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">296 B</td><td style="text-align: right">1.00</td></tr><tr><td>Interpolate</td><td>.NET 8.0</td><td style="text-align: right">278.4 ns</td><td style="text-align: right">0.78</td><td style="text-align: right">240 B</td><td style="text-align: right">0.81</td></tr></tbody></table><p>Other networking primitives improved in other ways. <a href="https://github.com/dotnet/runtime/pull/82095">dotnet/runtime#82095</a> reduced the overhead of the <code>GetHashCode</code> methods of several networking types, like <code>Cookie</code>. <code>Cookie.GetHashCode</code> was previously allocating and is now allocation-free. Same for <code>DnsEndPoint.GetHashCode</code>.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly Cookie _cookie = new Cookie(&quot;Cookie&quot;, &quot;Monster&quot;);
    private readonly DnsEndPoint _dns = new DnsEndPoint(&quot;localhost&quot;, 80);

    [Benchmark]
    public int CookieHashCode() =&gt; _cookie.GetHashCode();

    [Benchmark]
    public int DnsHashCode() =&gt; _dns.GetHashCode();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>CookieHashCode</td><td>.NET 7.0</td><td style="text-align: right">105.30 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">160 B</td><td style="text-align: right">1.00</td></tr><tr><td>CookieHashCode</td><td>.NET 8.0</td><td style="text-align: right">22.51 ns</td><td style="text-align: right">0.21</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>DnsHashCode</td><td>.NET 7.0</td><td style="text-align: right">136.78 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">192 B</td><td style="text-align: right">1.00</td></tr><tr><td>DnsHashCode</td><td>.NET 8.0</td><td style="text-align: right">12.92 ns</td><td style="text-align: right">0.09</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><p>And <code>HttpUtility</code> improved in <a href="https://github.com/dotnet/runtime/pull/78240">dotnet/runtime#78240</a>. This is a quintessential example of code doing its own manual looping looking for something (in this case, the four characters that require encoding) when it could have instead just used a well-placed <code>IndexOfAny</code>.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Web;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    [Benchmark]
    public string HtmlAttributeEncode() =&gt;
        HttpUtility.HtmlAttributeEncode(&quot;To encode, or not to encode: that is the question&quot;);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>HtmlAttributeEncode</td><td>.NET 7.0</td><td style="text-align: right">32.688 ns</td><td style="text-align: right">1.00</td></tr><tr><td>HtmlAttributeEncode</td><td>.NET 8.0</td><td style="text-align: right">6.734 ns</td><td style="text-align: right">0.21</td></tr></tbody></table><p>Moving up the stack to <code>System.Net.Sockets</code>, there are some nice improvements in .NET 8 here as well.</p><h2 id="sockets">Sockets</h2><p><a href="https://github.com/dotnet/runtime/pull/86524">dotnet/runtime#86524</a> and <a href="https://github.com/dotnet/runtime/pull/89808">dotnet/runtime#89808</a> are for Windows only because the problem they address doesn‚Äôt manifest on other operatings systems, due to how asynchronous operations are implemented on the various platforms.</p><p>On Unix operatings systems, the typical approach to asynchrony is to put the socket into non-blocking mode. Issuing an operation like <code>recv</code> (<code>Socket.Receive{Async}</code>) when there‚Äôs nothing to receive then fails immediately with an <code>errno</code> value of <code>EWOULDBLOCK</code> or <code>EAGAIN</code>, informing the caller that no data was available to receive yet and it‚Äôs not going to wait for said data because it‚Äôs been told not to. At that point, the caller can choose how it wants to wait for data to become available. <code>Socket</code> does what many other systems do, which is to use <code>epoll</code> (on Linux) or <code>kqueues</code> (on macOS). These mechanisms allow for a single thread to wait efficiently for any number of registered file descriptors to signal that something has changed. As such, <code>Socket</code> has one or more dedicated threads that sit in a wait loop, waiting on the <code>epoll</code>/<code>kqueue</code> to signal that there‚Äôs something to do, and when there is, queueing off the associated work, and then looping around to wait for the next notification. In the case of a <code>ReceiveAsync</code>, that queued work will end up reissuing the <code>recv</code>, which will now succeed as data will be available. The interesting thing here is that during that interim period while waiting for data to become available, there was no pending call from .NET to <code>recv</code> or anything else that would require a managed buffer (e.g. an array) be available. That‚Äôs not the case on Windows‚Ä¶</p><p>On Windows, the OS provides dedicated asynchronous APIs (‚Äúoverlapped I/O‚Äù), with <code>ReceiveAsync</code> being a thin wrapper around the Win32 <code>WSARecv</code> function. <code>WSARecv</code> accepts a pointer to the buffer to write into and a pointer to a callback that will be invoked when the operation has completed. That means that while waiting for data to be available, <code>WSARecv</code> actually needs a pointer to the buffer it‚Äôll write the data into (unless 0 bytes have been requested, which we‚Äôll talk more about in a bit). In .NET world, buffers are typically on the managed heap, which means they can be moved around by the GC, and thus in order to pass a pointer to such a buffer down to <code>WSARecv</code>, that buffer needs to be ‚Äúpinned,‚Äù telling the GC ‚Äúdo not move this.‚Äù For synchronous operations, such pinning is best accomplished with the C# <code>fixed</code> keyword; for asynchronous operations, <code>GCHandle</code> or something that wraps it (like <code>Memory.Pin</code> and <code>MemoryHandle</code>) are the answers. So, on Windows, <code>Socket</code> uses a <code>GCHandle</code> for any buffers it supplies to the OS to span an asynchronous operation‚Äôs lifetime.</p><p>For the last 20 years, though, it‚Äôs been overaggressive in doing so. There‚Äôs a buffer passed to various Win32 methods, including <code>WSAConnect</code> (<code>Socket.ConnectAsync</code>), to represent the target IP address. Even though these are asynchronous operations, it turns out that data is only required as part of the synchronous part of the call to these APIs; only a <code>ReceiveFromAsync</code> operation (which is typically only used with connectionless protocols, and in particular UDP) that receives not only payload data but also the sender‚Äôs address actually needs the address buffer pinned over the lifetime of the operation. <code>Socket</code> was pinning the buffer using a <code>GCHandle</code>, and in fact doing so for the lifetime of the <code>Socket</code>, even though a <code>GCHandle</code> wasn‚Äôt actually needed at all for these calls, and a <code>fixed</code> would suffice around just the Win32 call itself. The first PR fixed that, the net effect of which is that a <code>GCHandle</code> that was previously pinning a buffer for the lifetime of every <code>Socket</code> on Windows then only did so for <code>Socket</code>s issuing <code>ReceiveFromAsync</code> calls. The second PR then fixed <code>ReceiveFromAsync</code>, using a native buffer instead of a managed one that would need to be permanently pinned. The primary benefit of these changes is that it helps to avoid a lot of fragmentation that can result at scale in the managed heap. We can see this most easily by looking at the runtime‚Äôs tracing, which I consume in this example via an <code>EventListener</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0
// dotnet run -c Release -f net8.0

using System.Net;
using System.Net.Sockets;
using System.Diagnostics.Tracing;

using var setCountListener = new GCHandleListener();
Thread.Sleep(1000);

using Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
listener.Bind(new IPEndPoint(IPAddress.Loopback, 0));
listener.Listen();

for (int i = 0; i &lt; 10_000; i++)
{
    using Socket client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

    await client.ConnectAsync(listener.LocalEndPoint!);
    listener.Accept().Dispose();
}

Thread.Sleep(1000);
Console.WriteLine($&quot;{Environment.Version} GCHandle count: {setCountListener.SetGCHandleCount}&quot;);

sealed class GCHandleListener : EventListener
{
    public int SetGCHandleCount = 0;

    protected override void OnEventSourceCreated(EventSource eventSource)
    {
        if (eventSource.Name == &quot;Microsoft-Windows-DotNETRuntime&quot;)
            EnableEvents(eventSource, EventLevel.Informational, (EventKeywords)0x2);
    }

    protected override void OnEventWritten(EventWrittenEventArgs eventData)
    {
        // https://learn.microsoft.com/dotnet/fundamentals/diagnostics/runtime-garbage-collection-events#setgchandle-event
        if (eventData.EventId == 30 &amp;&amp; eventData.Payload![2] is (uint)3)
            Interlocked.Increment(ref SetGCHandleCount);
    }
}</code></pre><p>When I run this on .NET 7 on Windows, I get this:</p><pre><code class="language-text">7.0.9 GCHandle count: 10000</code></pre><p>When I run this on .NET 8, I get this:</p><pre><code class="language-text">8.0.0 GCHandle count: 0</code></pre><p>Nice.</p><p>I mentioned UDP above, with <code>ReceiveFromAsync</code>. We‚Äôve invested a lot over the last several years in making the networking stack in .NET very efficient‚Ä¶ for TCP. While most of the improvements there accrue to UDP as well, UDP has additional costs that hadn‚Äôt been addressed and that made it suboptimal from a performance perspective. The primary issues there are now addressed in .NET 8, thanks to <a href="https://github.com/dotnet/runtime/pull/88970">dotnet/runtime#88970</a> and <a href="https://github.com/dotnet/runtime/pull/90086">dotnet/runtime#90086</a>. The key problem here with the UDP-related APIs, namely <code>SendTo{Async}</code> and <code>ReceiveFrom{Async}</code>, is that the API is based on <code>EndPoint</code> but the core implementation is based on <code>SocketAddress</code>. Every call to <code>SendToAsync</code>, for example, would accept the provided <code>EndPoint</code> and then call <code>EndPoint.Serialize</code> to produce a <code>SocketAddress</code>, which internally has its own <code>byte[]</code>; that <code>byte[]</code> contains the address actually passed down to the underlying OS APIs. The inverse happens on the <code>ReceiveFromAsync</code> side: the received data includes an address that would be deserialized into an <code>EndPoint</code> which is then returned to the consumer. You can see these allocations show up by profiling a simple repro:</p><pre><code class="language-C#">using System.Net;
using System.Net.Sockets;

var client = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
var server = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

EndPoint endpoint = new IPEndPoint(IPAddress.Loopback, 12345);
server.Bind(endpoint);

Memory&lt;byte&gt; buffer = new byte[1];

for (int i = 0; i &lt; 10_000; i++)
{
    ValueTask&lt;SocketReceiveFromResult&gt; result = server.ReceiveFromAsync(buffer, endpoint);
    await client.SendToAsync(buffer, endpoint);
    await result;
}</code></pre><p>The .NET allocation profiler in Visual Studio shows this:</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/SocketUdpAllocationsInNet7.png" alt="Allocations in a UDP benchmark in .NET 7" /></p><p>So for each send/receive pair, we see three <code>SocketAddress</code>es which in turn leads to three <code>byte[]</code>s, and an <code>IPEndPoint</code> which in turn leads to an <code>IPAddress</code>. These costs are very difficult to address efficiently purely in implementation, as they‚Äôre directly related to what‚Äôs surfaced in the corresponding APIs. Even so, with the exact same code, it does improve a bit in .NET 8:</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/SocketUdpAllocationsInNet8.png" alt="Allocations in a UDP benchmark in .NET 8" /></p><p>So with zero code changes, we‚Äôve managed to eliminate one of the <code>SocketAddress</code> allocations and its associated <code>byte[]</code>, and to shrink the size of the remaining instances (in part due to <a href="https://github.com/dotnet/runtime/pull/78860">dotnet/runtime#78860</a>). But, we can do much better‚Ä¶</p><p>.NET 8 introduces a new set of overloads. In .NET 7, we had these:</p><pre><code class="language-C#">public int SendTo(byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);
public int ReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP);

public ValueTask&lt;int&gt; SendToAsync(ReadOnlyMemory&lt;byte&gt; buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = default)
public ValueTask&lt;SocketReceiveFromResult&gt; ReceiveFromAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, EndPoint remoteEndPoint, CancellationToken cancellationToken = default);</code></pre><p>and now in .NET 8 we also have these:</p><pre><code class="language-C#">public int SendTo(ReadOnlySpan&lt;byte&gt; buffer, SocketFlags socketFlags, SocketAddress socketAddress);
public int ReceiveFrom(Span&lt;byte&gt; buffer, SocketFlags socketFlags, SocketAddress receivedAddress);

public ValueTask&lt;int&gt; SendToAsync(ReadOnlyMemory&lt;byte&gt; buffer, SocketFlags socketFlags, SocketAddress socketAddress, CancellationToken cancellationToken = default);
public ValueTask&lt;int&gt; ReceiveFromAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, SocketAddress receivedAddress, CancellationToken cancellationToken = default);</code></pre><p>Key things to note:</p><ul><li>The new APIs no longer work in terms of <code>EndPoint</code>. They now operate on <code>SocketAddress</code> directly. That means the implementation no longer needs to call <code>EndPoint.Serialize</code> to produce a <code>SocketAddress</code> and can just use the provided one directly.</li><li>There‚Äôs no more <code>ref EndPoint</code> argument in the synchronous <code>ReceiveFrom</code> and no more <code>SocketReceiveFromResult</code> in the asynchronous <code>ReceiveFromAsync</code>. Both of these existed in order to pass back an <code>IPEndPoint</code> that represented the address of the received data‚Äôs sender. <code>SocketAddress</code>, however, is just a strongly-typed wrapper around a <code>byte[]</code> buffer, which means these methods can just mutate that provided instance, avoiding needing to instantiate anything to represent the received address.</li></ul><p>Let‚Äôs change our code sample to use these new APIs:</p><pre><code class="language-C#">using System.Net;
using System.Net.Sockets;

var client = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
var server = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

EndPoint endpoint = new IPEndPoint(IPAddress.Loopback, 12345);
server.Bind(endpoint);

Memory&lt;byte&gt; buffer = new byte[1];
SocketAddress receiveAddress = endpoint.Serialize();
SocketAddress sendAddress = endpoint.Serialize();

for (int i = 0; i &lt; 10_000; i++)
{
    ValueTask&lt;int&gt; result = server.ReceiveFromAsync(buffer, SocketFlags.None, receiveAddress);
    await client.SendToAsync(buffer, SocketFlags.None, sendAddress);
    await result;
}</code></pre><p>When I profile that, and again look for objects created at least once per iteration, I now see this:</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/SocketUdpAllocationsInNet8WithNewOverloads.png" alt="Allocations in a UDP benchmark in .NET 8 with new overloads" /></p><p>That‚Äôs not a mistake; I didn‚Äôt accidentally crop the screenshot incorrectly. It‚Äôs empty because there are no allocations per iteration; the whole program incurs only three <code>SocketAddress</code> allocations as part of the up-front setup. We can see that more clearly with a standard BenchmarkDotNet repro:</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;
using System.Net.Sockets;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly Memory&lt;byte&gt; _buffer = new byte[1];
    SocketAddress _sendAddress, _receiveAddress;
    IPEndPoint _ep;
    Socket _client, _server;

    [GlobalSetup]
    public void Setup()
    {
        _client = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
        _server = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

        _ep = new IPEndPoint(IPAddress.Loopback, 12345);
        _server.Bind(_ep);

        _sendAddress = _ep.Serialize();
        _receiveAddress = _ep.Serialize();
    }

    [Benchmark(OperationsPerInvoke = 1_000, Baseline = true)]
    public async Task ReceiveFromSendToAsync_EndPoint()
    {
        for (int i = 0; i &lt; 1_000; i++)
        {
            var result = _server.ReceiveFromAsync(_buffer, SocketFlags.None, _ep);
            await _client.SendToAsync(_buffer, SocketFlags.None, _ep);
            await result;
        }
    }

    [Benchmark(OperationsPerInvoke = 1_000)]
    public async Task ReceiveFromSendToAsync_SocketAddress()
    {
        for (int i = 0; i &lt; 1_000; i++)
        {
            var result = _server.ReceiveFromAsync(_buffer, SocketFlags.None, _receiveAddress);
            await _client.SendToAsync(_buffer, SocketFlags.None, _sendAddress);
            await result;
        }
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>ReceiveFromSendToAsync_EndPoint</td><td style="text-align: right">32.48 us</td><td style="text-align: right">1.00</td><td style="text-align: right">216 B</td><td style="text-align: right">1.00</td></tr><tr><td>ReceiveFromSendToAsync_SocketAddress</td><td style="text-align: right">31.78 us</td><td style="text-align: right">0.98</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr></tbody></table><h2 id="tls">TLS</h2><p>Moving up the stack further, <code>SslStream</code> has received some love in this release. While in previous releases work was done to reduce allocation, .NET 8 sees it reduced further:</p><ul><li><a href="https://github.com/dotnet/runtime/pull/74619">dotnet/runtime#74619</a> avoids some allocations related to ALPN. Application-Layer Protocol Negotation is a mechanism that allows higher-level protocols to piggyback on the roundtrips already being performed as part of a TLS handshake. It‚Äôs used by an HTTP client and server to negotiate which HTTP version to use (e.g. HTTP/2 or HTTP/1.1). Previously, the implementation would end up allocating a <code>byte[]</code> for use with this HTTP version selection, but now with this PR, the implementation precomputes <code>byte[]</code>s for the most common protocol selections, avoiding the need to re-allocate those <code>byte[]</code>s on each new connection.</li><li><a href="https://github.com/dotnet/runtime/pull/81096">dotnet/runtime#81096</a> removes a delegate allocation by moving some code around between the main <code>SslStream</code> implementation and the Platform Abstraction Layer (PAL) that‚Äôs used to handle OS-specific code (everything in the <code>SslStream</code> layer is compiled into <code>System.Net.Security.dll</code> regardless of OS, and then depending on the target OS, a different version of the <code>SslStreamPal</code> class is compiled in).</li><li><a href="https://github.com/dotnet/runtime/pull/84690">dotnet/runtime#84690</a> from <a href="https://github.com/am11">@am11</a> avoids a gigantic <code>Dictionary&lt;TlsCipherSuite, TlsCipherSuiteData&gt;</code> that was being created to enable querying for information about a particular cipher suite for use with TLS. Instead of a dictionary mapping a <code>TlsCipherSuite</code> enum to a <code>TlsCipherSuiteData</code> struct (which contained details like an <code>ExchangeAlgorithmType</code> enum value, a <code>CipherAlgorithmType</code> enum value, an <code>int</code><code>CipherAlgorithmStrength</code>, etc.), a <code>switch</code> statement is used, mapping that same <code>TlsCipherSuite</code> enum to an <code>int</code> that‚Äôs packed with all the same information. This not only avoids the run-time costs associated with allocating that dictionary and populating it, it also shaves almost 20Kb off a published Native AOT binary, due to all of the code that was necessary to populate the dictionary. <a href="https://github.com/dotnet/runtime/pull/84921">dotnet/runtime#84921</a> from <a href="https://github.com/am11">@am11</a> uses a similar <code>switch</code> for well-known OIDs.</li><li><a href="https://github.com/dotnet/runtime/pull/86163">dotnet/runtime#86163</a> changed an internal <code>ProtocolToken</code> class into a struct, passing it around by <code>ref</code> instead.</li><li><a href="https://github.com/dotnet/runtime/pull/74695">dotnet/runtime#74695</a> avoids some <code>SafeHandle</code> allocation in interop as part of certificate handling on Linux. <code>SafeHandle</code>s are a valuable reliability feature in .NET: they wrap a native handle / file descriptor, providing the finalizer that ensures the resource isn‚Äôt leaked, but also providing ref counting to ensure that the resource isn‚Äôt closed while it‚Äôs still being used, leading to use-after-free and handle recycling bugs. They‚Äôre particularly helpful when a handle or file descriptor needs to be passed around and shared between multiple components, often as part of some larger object model (e.g. a <code>FileStream</code> wraps a <code>SafeFileHandle</code>). However, in some cases they‚Äôre unnecessary overhead. If you have a pattern like:
<pre><code class="language-C#">SafeHandle handle = GetResource();
try { Use(handle); }
finally { handle.Dispose(); }</code></pre><p>such that the resource is provably used and freed correctly, you can avoid the <code>SafeHandle</code> and instead just use the resource directly:</p><pre><code class="language-C#">IntPtr handle = GetResource();
try { Use(handle); }
finally { Free(handle); }</code></pre><p>thereby saving on the allocation of a finalizable object (which is more expensive than a normal allocation as synchronization is required to add that object to a finalization queue in the GC) as well as on ref-counting overhead associated with using a <code>SafeHandle</code> in interop.</p></li></ul><p>This benchmark repeatedly creates new <code>SslStream</code>s and performs handshakes:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security.Authentication;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private NetworkStream _client, _server;
    private readonly SslServerAuthenticationOptions _options = new SslServerAuthenticationOptions
    {
        ServerCertificateContext = SslStreamCertificateContext.Create(GetCertificate(), null),
    };

    [GlobalSetup]
    public void Setup()
    {
        using var listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        listener.Bind(new IPEndPoint(IPAddress.Loopback, 0));
        listener.Listen(1);

        var client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp) { NoDelay = true };
        client.Connect(listener.LocalEndPoint);

        Socket serverSocket = listener.Accept();
        serverSocket.NoDelay = true;
        _server = new NetworkStream(serverSocket, ownsSocket: true);
        _client = new NetworkStream(client, ownsSocket: true);
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        _client.Dispose();
        _server.Dispose();
    }

    [Benchmark]
    public async Task Handshake()
    {
        using var client = new SslStream(_client, leaveInnerStreamOpen: true, delegate { return true; });
        using var server = new SslStream(_server, leaveInnerStreamOpen: true, delegate { return true; });

        await Task.WhenAll(
            client.AuthenticateAsClientAsync(&quot;localhost&quot;, null, SslProtocols.Tls12, checkCertificateRevocation: false),
            server.AuthenticateAsServerAsync(_options));
    }

    private static X509Certificate2 GetCertificate()
    {
        X509Certificate2 cert;
        using (RSA rsa = RSA.Create())
        {
            var certReq = new CertificateRequest(&quot;CN=localhost&quot;, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            certReq.CertificateExtensions.Add(new X509BasicConstraintsExtension(false, false, 0, false));
            certReq.CertificateExtensions.Add(new X509EnhancedKeyUsageExtension(new OidCollection { new Oid(&quot;1.3.6.1.5.5.7.3.1&quot;) }, false));
            certReq.CertificateExtensions.Add(new X509KeyUsageExtension(X509KeyUsageFlags.DigitalSignature, false));
            cert = certReq.CreateSelfSigned(DateTimeOffset.UtcNow.AddMonths(-1), DateTimeOffset.UtcNow.AddMonths(1));
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                cert = new X509Certificate2(cert.Export(X509ContentType.Pfx));
            }
        }
        return cert;
    }
}</code></pre><p>It shows an ~13% reduction in overall allocation as part of the <code>SslStream</code> lifecycle:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Handshake</td><td>.NET 7.0</td><td style="text-align: right">828.5 us</td><td style="text-align: right">1.00</td><td style="text-align: right">7.07 KB</td><td style="text-align: right">1.00</td></tr><tr><td>Handshake</td><td>.NET 8.0</td><td style="text-align: right">769.0 us</td><td style="text-align: right">0.93</td><td style="text-align: right">6.14 KB</td><td style="text-align: right">0.87</td></tr></tbody></table><p>My favorite <code>SslStream</code> improvement in .NET 8, though, is <a href="https://github.com/dotnet/runtime/pull/87563">dotnet/runtime#87563</a>, which teaches <code>SslStream</code> to do ‚Äúzero-byte reads‚Äù in order to minimize buffer use and pinning. This has been a long time coming, and is the result of multiple users of <code>SslStream</code> reporting significant heap fragmentation.</p><p>When a read is issued to <code>SslStream</code>, it in turn needs to issue a read on the underlying <code>Stream</code>; the data it reads has a header, which gets peeled off, and then the remaining data is decrypted and stored into the user‚Äôs buffer. Since there‚Äôs manipulation of the data read from the underlying <code>Stream</code>, including not giving all of it to the user, <code>SslStream</code> doesn‚Äôt just pass the user‚Äôs buffer to the underlying <code>Stream</code>, but instead passes its own buffer down. That means it needs a buffer to pass. With performance improvements in recent .NET releases, <code>SslStream</code> rents said buffer on demand from the <code>ArrayPool</code> and returns it as soon as that temporary buffer has been drained of all the data read into it. There are two issues with this, though. On Windows, a buffer is being provided to <code>Socket</code>, which needs to pin the buffer in order to give a pointer to that buffer to the Win32 overlapped I/O operation; that pinning means the GC can‚Äôt move the buffer on the heap, which can mean gaps end up being left on the heap that aren‚Äôt usable (aka ‚Äúfragmentation‚Äù), and that in turn can lead to sporadic out-of-memory conditions. As noted earlier, the <code>Socket</code> implementation on Linux and macOS doesn‚Äôt need to do such pinning, however there‚Äôs still a problem here. Imagine you have a thousand open connections, or a million open connections, all of which are sitting in a read waiting for data; even if there‚Äôs no pinning, if each of those connections has an <code>SslStream</code> that‚Äôs rented a buffer of any meaningful size, that‚Äôs a whole lot of wasted memory just sitting there.</p><p>An answer to this that .NET has been making more and more use of over the last few years is ‚Äúzero-byte reads.‚Äù If you need to read 100 bytes, rather than handing down your 100-byte buffer, at which point it needs to be pinned, you instead issue a read for 0 bytes, handing down an empty buffer, at which point nothing needs to be pinned. When there‚Äôs data available, that zero-byte read completes (without consuming anything), and then you issue the actual read for the 100 bytes, which is much more likely to be synchronously satisfiable at that point. As of .NET 6, <code>SslStream</code> is already capable of passing along zero-byte reads, e.g. if you do <code>sslStream.ReadAsync(emptyBuffer)</code> and it doesn‚Äôt have any data buffered already, it‚Äôll in turn issue a zero-byte read on the underlying <code>Stream</code>. However, today <code>SslStream</code> itself doesn‚Äôt <em>create</em> zero-byte reads, e.g. if you do <code>sslStream.ReadAsync(someNonEmptyBuffer)</code> and it doesn‚Äôt have enough data buffered, it in turn will issue a non-zero-byte read, and we‚Äôre back to pinning per operation at the <code>Socket</code> layer, plus needing a buffer to pass down, which means renting one.</p><p><a href="https://github.com/dotnet/runtime/pull/87563">dotnet/runtime#87563</a> teaches <code>SslStream</code> how to create zero-byte reads. Now when you do <code>sslStream.ReadAsync(someNonEmptyBuffer)</code> and the <code>SslStream</code> doesn‚Äôt have enough data buffered, rather than immediately renting a buffer and passing that down, it instead issues a zero-byte read on the underlying <code>Stream</code>. Only once that operation completes does it then proceed to actually rent a buffer and issue another read, this time with the rented buffer. The primary downside to this is a bit more overhead, in that it can lead to an extra syscall; however, our measurements show that overhead to largely be in the noise, with very meaningful upside in reduced fragmentation, working set reduction, and <code>ArrayPool</code> stability.</p><p>The <code>GCHandle</code> reduction on Windows is visible with this app, a variation of one showed earlier:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0
// dotnet run -c Release -f net8.0

using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography;
using System.Diagnostics.Tracing;

var listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
var client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
listener.Bind(new IPEndPoint(IPAddress.Loopback, 0));
listener.Listen();

client.Connect(listener.LocalEndPoint!);
Socket server = listener.Accept();
listener.Dispose();

X509Certificate2 cert;
using (RSA rsa = RSA.Create())
{
    var certReq = new CertificateRequest(&quot;CN=localhost&quot;, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
    certReq.CertificateExtensions.Add(new X509BasicConstraintsExtension(false, false, 0, false));
    certReq.CertificateExtensions.Add(new X509EnhancedKeyUsageExtension(new OidCollection { new Oid(&quot;1.3.6.1.5.5.7.3.1&quot;) }, false));
    certReq.CertificateExtensions.Add(new X509KeyUsageExtension(X509KeyUsageFlags.DigitalSignature, false));
    cert = certReq.CreateSelfSigned(DateTimeOffset.UtcNow.AddMonths(-1), DateTimeOffset.UtcNow.AddMonths(1));
    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
    {
        cert = new X509Certificate2(cert.Export(X509ContentType.Pfx));
    }
}

var clientStream = new SslStream(new NetworkStream(client, ownsSocket: true), false, delegate { return true; });
var serverStream = new SslStream(new NetworkStream(server, ownsSocket: true), false, delegate { return true; });
await Task.WhenAll(
    clientStream.AuthenticateAsClientAsync(&quot;localhost&quot;, null, false),
    serverStream.AuthenticateAsServerAsync(cert, false, false));

using var setCountListener = new GCHandleListener();

Memory&lt;byte&gt; buffer = new byte[1];
for (int i = 0; i &lt; 100_000; i++)
{
    ValueTask&lt;int&gt; read = clientStream.ReadAsync(buffer);
    await serverStream.WriteAsync(buffer);
    await read;
}

Thread.Sleep(1000);
Console.WriteLine($&quot;{Environment.Version} GCHandle count: {setCountListener.SetGCHandleCount:N0}&quot;);

sealed class GCHandleListener : EventListener
{
    public int SetGCHandleCount = 0;

    protected override void OnEventSourceCreated(EventSource eventSource)
    {
        if (eventSource.Name == &quot;Microsoft-Windows-DotNETRuntime&quot;)
            EnableEvents(eventSource, EventLevel.Informational, (EventKeywords)0x2);
    }

    protected override void OnEventWritten(EventWrittenEventArgs eventData)
    {
        // https://learn.microsoft.com/dotnet/fundamentals/diagnostics/runtime-garbage-collection-events#setgchandle-event
        if (eventData.EventId == 30 &amp;&amp; eventData.Payload[2] is (uint)3)
            Interlocked.Increment(ref SetGCHandleCount);
    }
}</code></pre><p>On .NET 7, this outputs:</p><pre><code class="language-text">7.0.9 GCHandle count: 100,000</code></pre><p>whereas on .NET 8, I now get:</p><pre><code class="language-text">8.0.0 GCHandle count: 0</code></pre><p>So pretty.</p><h2 id="http">HTTP</h2><p>The primary consumer of <code>SslStream</code> in .NET itself is the HTTP stack, so let‚Äôs move up the stack now to <code>HttpClient</code>, which has seen important gains of its own in .NET 8. As with <code>SslStream</code>, there were a bunch of improvements here that all joined to make for a measurable end-to-end improvement (many of the opportunities here were found as part of improving <a href="https://github.com/microsoft/reverse-proxy">YARP</a>):</p><ul><li><a href="https://github.com/dotnet/runtime/pull/74393">dotnet/runtime#74393</a> streamlined how HTTP/1.1 response headers are parsed, including making better use of <code>IndexOfAny</code> to speed up searching for various delimiters demarcating portions of the response.</li><li><a href="https://github.com/dotnet/runtime/pull/79525">dotnet/runtime#79525</a> and <a href="https://github.com/dotnet/runtime/pull/79524">dotnet/runtime#79524</a> restructured buffer management for reading and writing on HTTP/1.1 connections.</li><li><a href="https://github.com/dotnet/runtime/pull/81251">dotnet/runtime#81251</a> reduced the size of <code>HttpRequestMessage</code> by 8 bytes and <code>HttpRequestHeaders</code> by 16 bytes (on 64-bit). <code>HttpRequestMessage</code> had a <code>Boolean</code> field that was replaced by using a bit from an existing <code>int</code> field that wasn‚Äôt using all of its bits; as the rest of the message‚Äôs fields fit neatly into a multiple of 8 bytes, that extra <code>Boolean</code>, even though only a byte in size, required the object to grow by 8 bytes. For <code>HttpRequestHeaders</code>, it already had an optimization where some uncommonly used headers were pushed off into a contingently-allocated array; there were additional rarely used fields that made more sense to be contingent.</li><li><a href="https://github.com/dotnet/runtime/pull/83640">dotnet/runtime#83640</a> shrunk the size of various strongly typed <code>HeaderValue</code> types. For example, <code>ContentRangeHeaderValue</code> has three public properties <code>From</code>, <code>To</code>, and <code>Length</code>, all of which are <code>long?</code> aka <code>Nullable&lt;long&gt;</code>. Each of these properties was backed by a <code>Nullable&lt;long&gt;</code> field. Because of packing and alignment, <code>Nullable&lt;long&gt;</code> ends up consuming 16 bytes, 8 bytes for the <code>long</code> and then 8 bytes for the <code>bool</code> indicating whether the nullable has a value (<code>bool</code> is stored as a single byte, but because of alignment and packing, it‚Äôs rounded up to 8). Instead of storing these as <code>Nullable&lt;long&gt;</code>, they can just be <code>long</code>, using whether they contain a negative value to indicate whether they were initialized, reducing the size of the object from 72 bytes down to 48 bytes. Similar improvements were made to six other such <code>HeaderValue</code> types.</li><li><a href="https://github.com/dotnet/runtime/pull/81253">dotnet/runtime#81253</a> tweaked how ‚ÄúTransfer-Encoding: chunked‚Äù is stored internally, special-casing it to avoid several allocations.</li><li>When <code>Activity</code> is in use in order to enable the correlation of tracing information across end-to-end usage, every HTTP request ends up creating a new <code>Activity.Id</code>, which incurs not only the <code>string</code> for that ID, but also in the making of it temporary <code>string</code> and a temporary <code>string[6]</code> array. <a href="https://github.com/dotnet/runtime/pull/86685">dotnet/runtime#86685</a> removes both of those intermediate allocations by making better use of spans.</li><li><a href="https://github.com/dotnet/runtime/pull/79484">dotnet/runtime#79484</a> is specific to HTTP/2 and applies to it similar changes to what was discussed for <code>SslStream</code>: it now rents buffers from the <code>ArrayPool</code> on demand, returning those buffers when idle, and it issues zero-byte reads to the underlying transport <code>Stream</code>. The net result of these changes is it can reduce the memory usage of an idle HTTP/2 connection by up to 80Kb.</li></ul><p>We can use the following simple GET-request benchmark to how some of these changes accrue to reduced overheads with <code>HttpClient</code>:</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;
using System.Net.Sockets;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private static readonly Socket s_listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    private static readonly HttpMessageInvoker s_client = new(new SocketsHttpHandler());
    private static Uri s_uri;

    [Benchmark]
    public async Task HttpGet()
    {
        var m = new HttpRequestMessage(HttpMethod.Get, s_uri);
        using (HttpResponseMessage r = await s_client.SendAsync(m, default))
        using (Stream s = r.Content.ReadAsStream())
            await s.CopyToAsync(Stream.Null);
    }

    [GlobalSetup]
    public void CreateSocketServer()
    {
        s_listener.Bind(new IPEndPoint(IPAddress.Loopback, 0));
        s_listener.Listen(int.MaxValue);
        var ep = (IPEndPoint)s_listener.LocalEndPoint;
        s_uri = new Uri($&quot;http://{ep.Address}:{ep.Port}/&quot;);

        Task.Run(async () =&gt;
        {
            while (true)
            {
                Socket s = await s_listener.AcceptAsync();
                _ = Task.Run(() =&gt;
                {
                    using (var ns = new NetworkStream(s, true))
                    {
                        byte[] buffer = new byte[1024];
                        int totalRead = 0;
                        while (true)
                        {
                            int read = ns.Read(buffer, totalRead, buffer.Length - totalRead);
                            if (read == 0) return;
                            totalRead += read;
                            if (buffer.AsSpan(0, totalRead).IndexOf(&quot;\r\n\r\n&quot;u8) == -1)
                            {
                                if (totalRead == buffer.Length) Array.Resize(ref buffer, buffer.Length * 2);
                                continue;
                            }

                            ns.Write(&quot;HTTP/1.1 200 OK\r\nDate: Sun, 05 Jul 2020 12:00:00 GMT \r\nServer: Example\r\nContent-Length: 5\r\n\r\nHello&quot;u8);

                            totalRead = 0;
                        }
                    }
                });
            }
        });
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>HttpGet</td><td>.NET 7.0</td><td style="text-align: right">151.7 us</td><td style="text-align: right">1.00</td><td style="text-align: right">1.52 KB</td><td style="text-align: right">1.00</td></tr><tr><td>HttpGet</td><td>.NET 8.0</td><td style="text-align: right">136.0 us</td><td style="text-align: right">0.90</td><td style="text-align: right">1.41 KB</td><td style="text-align: right">0.93</td></tr></tbody></table><p><code>WebSocket</code> also sees improvements in .NET 8. With <a href="https://github.com/dotnet/runtime/pull/87329">dotnet/runtime#87329</a>, <code>ManagedWebSocket</code> (the implementation that‚Äôs used by <code>ClientWebSocket</code> and that‚Äôs returned from <code>WebSocket.CreateFromStream</code>) gets in on the zero-byte reads game. In .NET 7, you could perform a zero-byte <code>ReceiveAsync</code> on <code>ManagedWebSocket</code>, but doing so would still issue a <code>ReadAsync</code> to the underlying stream with the receive header buffer. That in turn could cause the underlying <code>Stream</code> to rent and/or pin a buffer. By special-casing zero-byte reads now in .NET 8, <code>ClientWebSocket</code> can take advantage of any special-casing in the base stream, and hopefully make it so that when the actual read is performed, the data necessary to satisfy it synchronously is already available.</p><p>And with <a href="https://github.com/dotnet/runtime/pull/75025">dotnet/runtime#75025</a>, allocation with <code>ClientWebSocket.ConnectAsync</code> is reduced. This is a nice example of really needing to pay attention to defaults. <code>ClientWebSocket</code> has an optimization where it maintains a shared singleton <code>HttpMessageInvoker</code> that it reuses between <code>ClientWebSocket</code> instances. However, it can only reuse them when the settings of the <code>ClientWebSocket</code> match the settings of that shared singleton; by default <code>ClientWebSocketOptions.Proxy</code> is set, and that‚Äôs enough to knock it off the path that lets it use the shared handler. This PR adds a second shared singleton for when <code>Proxy</code> is set, such that requests using the default proxy can now use a shared handler rather than creating one a new.</p><h2 id="json">JSON</h2><p>A significant focus for <code>System.Text.Json</code> in .NET 8 was on improving support for trimming and source-generated <code>JsonSerializer</code> implementations, as its usage ends up on critical code paths in a multitude of services and applications, including those that are a primary focus area for Native AOT. Thus, a lot of work went into adding features to the source generator that might otherwise prevent a developer from prefering to use it. <a href="https://github.com/dotnet/runtime/pull/79828">dotnet/runtime#79828</a>, for example, added support for <code>required</code> and <code>init</code> properties in C#, <a href="https://github.com/dotnet/runtime/pull/83631">dotnet/runtime#83631</a> added support for ‚Äúunspeakable‚Äù types (such as the compiler-generated types used to implement iterator methods), and <a href="https://github.com/dotnet/runtime/pull/84768">dotnet/runtime#84768</a> added better support for boxed values. <a href="https://github.com/dotnet/runtime/pull/79397">dotnet/runtime#79397</a> also added support for weakly-typed but trimmer-safe <code>Serialize</code>/<code>Deserialize</code> methods, taking <code>JsonTypeInfo</code>, that make it possible for ASP.NET and other such consumers to cache JSON contract metadata appropriately. All of these improvements are functionally valuable on their own, but also accrue to the overall goals of reducing deployed binary size, improving startup time, and generally being able to be successful with Native AOT and gaining the benefits it brings.</p><p>Even with that focus, however, there were still some nice throughput-focused improvements that made their way into .NET 8. In particular, a key improvement in .NET 8 is that the <code>JsonSerializer</code> is now able to utilize generated ‚Äúfast-path‚Äù methods even when streaming.</p><p>One of the main things the JSON source generator does is generate at build-time all of the things <code>JsonSerializer</code> would otherwise need reflection to access at run-time, e.g. discovering the shape of a type, all of its members, their names, attributes that control their serialization, and so on. With just that, however, the serializer would still be using generic routines to perform operations like serialization, just doing so without needing to use reflection. Instead, the source generator can emit a customized serialization routine specific to the data in question, in order to optimize writing it out. For example, given the following types:</p><pre><code class="language-C#">public class Rectangle
{
    public int X, Y, Width, Height;
    public Color Color;
}

public struct Color
{
    public byte R, G, B, A;
}

[JsonSerializable(typeof(Rectangle))]
[JsonSourceGenerationOptions(IncludeFields = true)]
private partial class JsonContext : JsonSerializerContext { }</code></pre><p>the source generator will include the following serialization routines in the generated code:</p><pre><code class="language-C#">private void RectangleSerializeHandler(global::System.Text.Json.Utf8JsonWriter writer, global::Tests.Rectangle? value)
{
    if (value == null)
    {
        writer.WriteNullValue();
        return;
    }

    writer.WriteStartObject();

    writer.WriteNumber(PropName_X, ((global::Tests.Rectangle)value).X);
    writer.WriteNumber(PropName_Y, ((global::Tests.Rectangle)value).Y);
    writer.WriteNumber(PropName_Width, ((global::Tests.Rectangle)value).Width);
    writer.WriteNumber(PropName_Height, ((global::Tests.Rectangle)value).Height);
    writer.WritePropertyName(PropName_Color);
    ColorSerializeHandler(writer, ((global::Tests.Rectangle)value).Color);

    writer.WriteEndObject();
}

private void ColorSerializeHandler(global::System.Text.Json.Utf8JsonWriter writer, global::Tests.Color value)
{
    writer.WriteStartObject();

    writer.WriteNumber(PropName_R, value.R);
    writer.WriteNumber(PropName_G, value.G);
    writer.WriteNumber(PropName_B, value.B);
    writer.WriteNumber(PropName_A, value.A);

    writer.WriteEndObject();
}</code></pre><p>The serializer can then just invoke these routines to write the data directly to the <code>Utf8JsonWriter</code>.</p><p>However, in the past these routines weren‚Äôt used when serializing with one of the streaming routines (e.g. all of the <code>SerializeAsync</code> methods), in part because of the complexity of refactoring the implementation to accommodate them, but in larger part out of concern that an individual instance being serialized might need to write more data than should be buffered; these fast paths are synchronous-only today, and so can‚Äôt perform asynchronous flushes efficiently. This is particularly unfortunate because these streaming overloads are the primary ones used by ASP.NET, which means ASP.NET wasn‚Äôt benefiting from these fast paths. Thanks to <a href="https://github.com/dotnet/runtime/pull/78646">dotnet/runtime#78646</a>, in .NET 8 they now do benefit. The PR does the necessary refactoring internally and also puts in place various heuristics to minimize chances of over-buffering. The net result is these existing optimizations now kick in for a much broader array of use cases, including the primary ones higher in the stack, and the wins are significant.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Json;
using System.Text.Json.Serialization;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public partial class Tests
{
    private readonly Rectangle _data = new()
    {
        X = 1, Y = 2,
        Width = 3, Height = 4,
        Color = new Color { R = 5, G = 6, B = 7, A = 8 }
    };

    [Benchmark]
    public void Serialize() =&gt; JsonSerializer.Serialize(Stream.Null, _data, JsonContext.Default.Rectangle);

    [Benchmark]
    public Task SerializeAsync() =&gt; JsonSerializer.SerializeAsync(Stream.Null, _data, JsonContext.Default.Rectangle);

    public class Rectangle
    {
        public int X, Y, Width, Height;
        public Color Color;
    }

    public struct Color
    {
        public byte R, G, B, A;
    }

    [JsonSerializable(typeof(Rectangle))]
    [JsonSourceGenerationOptions(IncludeFields = true)]
    private partial class JsonContext : JsonSerializerContext { }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Serialize</td><td>.NET 7.0</td><td style="text-align: right">613.3 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">488 B</td><td style="text-align: right">1.00</td></tr><tr><td>Serialize</td><td>.NET 8.0</td><td style="text-align: right">205.9 ns</td><td style="text-align: right">0.34</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>SerializeAsync</td><td>.NET 7.0</td><td style="text-align: right">654.2 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">488 B</td><td style="text-align: right">1.00</td></tr><tr><td>SerializeAsync</td><td>.NET 8.0</td><td style="text-align: right">259.6 ns</td><td style="text-align: right">0.40</td><td style="text-align: right">32 B</td><td style="text-align: right">0.07</td></tr></tbody></table><p>The fast-path routines are better leveraged in additional scenarios now, as well. Another case where they weren‚Äôt used, even when not streaming, was when combining multiple source-generated contexts: if you have your <code>JsonSerializerContext</code>-derived type for your own types to be serialized, and someone passes to you another <code>JsonSerializerContext</code>-derived type for a type they‚Äôre giving you to serialize, you need to combine those contexts together into something you can give to <code>Serialize</code>. In doing so, however, the fast paths could get lost. <a href="https://github.com/dotnet/runtime/pull/80741">dotnet/runtime#80741</a> adds additional APIs and support to enable the fast paths to still be used.</p><p>Beyond <code>JsonSerializer</code>, there have been several other performance improvements. In <a href="https://github.com/dotnet/runtime/pull/88194">dotnet/runtime#88194</a>, for example, <code>JsonNode</code>‚Äòs implementation is streamlined, including avoiding allocating a delegate while setting values into the node, and in <a href="https://github.com/dotnet/runtime/pull/85886">dotnet/runtime#85886</a>, <code>JsonNode.To</code> is improved via a one-line change that stops unnecessarily calling <code>Memory&lt;byte&gt;.ToArray()</code> in order to pass it to a method that accepts a <code>ReadOnlySpan&lt;byte&gt;</code>: <code>Memory&lt;byte&gt;.Span</code> can and should be used instead, saving on a potentially large array allocation and copy.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Json.Nodes;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly JsonNode _node = JsonNode.Parse(&quot;&quot;&quot;{ &quot;Name&quot;: &quot;Stephen&quot; }&quot;&quot;&quot;u8);

    [Benchmark]
    public string ToJsonString() =&gt; _node.ToString();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>ToJsonString</td><td>.NET 7.0</td><td style="text-align: right">244.5 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">272 B</td><td style="text-align: right">1.00</td></tr><tr><td>ToJsonString</td><td>.NET 8.0</td><td style="text-align: right">189.6 ns</td><td style="text-align: right">0.78</td><td style="text-align: right">224 B</td><td style="text-align: right">0.82</td></tr></tbody></table><p>Lastly on the JSON front, there‚Äôs the new <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1869">CA1869</a> analyzer added in <a href="https://github.com/dotnet/roslyn-analyzers/pull/6850">dotnet/roslyn-analyzers#6850</a>.</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/CA1869.png" alt="CA1869" /></p><p>The <code>JsonSerializerOptions</code> type looks like something that should be relatively cheap to allocate, just a small options type you could allocate on each call to <code>JsonSerializer.Serialize</code> or <code>JsonSerializer.Deserialize</code> with little ramification:</p><pre><code class="language-C#">T value = JsonSerializer.Deserialize&lt;T&gt;(source, new JsonSerializerOptions { AllowTrailingCommas = true });</code></pre><p>That‚Äôs not the case, however. <code>JsonSerializer</code> may need to use reflection to analyze the type being serialized or deserialized in order to learn about its shape and then potentially even use reflection emit to generate custom processing code for using that type. The <code>JsonSerializerOptions</code> instance is then used not only as a simple bag for options information, but also as a place to store all of that state the serializer built up, enabling it to be shared from call to call. Prior to .NET 7, this meant that passing a new <code>JsonSerializerOptions</code> instance to each call resulted in a massive performance cliff. In .NET 7, the caching scheme was improved to combat the problems here, but even with those mitigations, there‚Äôs still significant overhead to using a new <code>JsonSerializerOptions</code> instance each time. Instead, a <code>JsonSerializerOptions</code> instance should be cached and reused.</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Text.Json;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly string _json = &quot;&quot;&quot;{ &quot;Title&quot;:&quot;Performance Improvements in .NET 8&quot;, &quot;Author&quot;:&quot;Stephen Toub&quot;, }&quot;&quot;&quot;;
    private readonly JsonSerializerOptions _options = new JsonSerializerOptions { AllowTrailingCommas = true };

    [Benchmark(Baseline = true)]
    public BlogData Deserialize_New() =&gt; JsonSerializer.Deserialize&lt;BlogData&gt;(_json, new JsonSerializerOptions { AllowTrailingCommas = true });

    [Benchmark]
    public BlogData Deserialize_Cached() =&gt; JsonSerializer.Deserialize&lt;BlogData&gt;(_json, _options);

    public struct BlogData
    {
        public string Title { get; set; }
        public string Author { get; set; }
    }
}</code></pre><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Deserialize_New</td><td style="text-align: right">736.5 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">358 B</td><td style="text-align: right">1.00</td></tr><tr><td>Deserialize_Cached</td><td style="text-align: right">290.2 ns</td><td style="text-align: right">0.39</td><td style="text-align: right">176 B</td><td style="text-align: right">0.49</td></tr></tbody></table><h2 id="cryptography">Cryptography</h2><p>Cryptography in .NET 8 sees a smattering of improvements, a few large ones and a bunch of smaller ones that contribute to removing some overhead across the system.</p><p>One of the larger improvements, specific to Windows because it‚Äôs about switching what functionality is employed from the underlying OS, comes from <a href="https://github.com/dotnet/runtime/pull/76277">dotnet/runtime#76277</a>. Windows CNG (‚ÄúNext Generation‚Äù) provides two libraries: <code>bcrypt.dll</code> and <code>ncrypt.dll</code>. The former provides support for ‚Äúephemeral‚Äù operations, ones where the cryptographic key is in-memory only and generated on the fly as part of an operation. The latter supports both ephemeral and persisted-key operations, and as a result much of the .NET support has been based on <code>ncrypt.dll</code> since it‚Äôs more universal. This, however, can add unnecessary expense, as all of the operations are handled out-of-process by the <code>lsass.exe</code> service, and thus require remote procedure calls, which add overhead. This PR switches <code>RSA</code> ephemeral operations over to using <code>bcrypt</code> instead of <code>ncrypt</code>, and the results are noteworthy (in the future, we expect other algorithms to also switch).</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
[SkipLocalsInit]
public class Tests
{
    private static readonly RSA s_rsa = RSA.Create();
    private static readonly byte[] s_signed = s_rsa.SignHash(new byte[256 / 8], HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
    private static readonly byte[] s_encrypted = s_rsa.Encrypt(new byte[3], RSAEncryptionPadding.OaepSHA256);
    private static readonly X509Certificate2 s_cert = new X509Certificate2(Convert.FromBase64String(&quot;&quot;&quot;
        MIIE7DCCA9SgAwIBAgITMwAAALARrwqL0Duf3QABAAAAsDANBgkqhkiG9w0BAQUFADB5MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMH
        UmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSMwIQYDVQQDExpNaWNyb3NvZnQgQ29kZSBTaWduaW5nIFBDQTAeFw0xMzAxMjQyMjMzMzlaFw0x
        NDA0MjQyMjMzMzlaMIGDMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0
        aW9uMQ0wCwYDVQQLEwRNT1BSMR4wHAYDVQQDExVNaWNyb3NvZnQgQ29ycG9yYXRpb24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDor1yiIA34KHy8BXt/
        re7rdqwoUz8620B9s44z5lc/pVEVNFSlz7SLqT+oN+EtUO01Fk7vTXrbE3aIsCzwWVyp6+HXKXXkG4Unm/P4LZ5BNisLQPu+O7q5XHWTFlJLyjPFN7Dz636o9UEVXAhl
        HSE38Cy6IgsQsRCddyKFhHxPuRuQsPWj/ov0DJpOoPXJCiHiquMBNkf9L4JqgQP1qTXclFed+0vUDoLbOI8S/uPWenSIZOFixCUuKq6dGB8OHrbCryS0DlC83hyTXEmm
        ebW22875cHsoAYS4KinPv6kFBeHgD3FN/a1cI4Mp68fFSsjoJ4TTfsZDC5UABbFPZXHFAgMBAAGjggFgMIIBXDATBgNVHSUEDDAKBggrBgEFBQcDAzAdBgNVHQ4EFgQU
        WXGmWjNN2pgHgP+EHr6H+XIyQfIwUQYDVR0RBEowSKRGMEQxDTALBgNVBAsTBE1PUFIxMzAxBgNVBAUTKjMxNTk1KzRmYWYwYjcxLWFkMzctNGFhMy1hNjcxLTc2YmMw
        NTIzNDRhZDAfBgNVHSMEGDAWgBTLEejK0rQWWAHJNy4zFha5TJoKHzBWBgNVHR8ETzBNMEugSaBHhkVodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2NybC9wcm9k
        dWN0cy9NaWNDb2RTaWdQQ0FfMDgtMzEtMjAxMC5jcmwwWgYIKwYBBQUHAQEETjBMMEoGCCsGAQUFBzAChj5odHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL2NlcnRz
        L01pY0NvZFNpZ1BDQV8wOC0zMS0yMDEwLmNydDANBgkqhkiG9w0BAQUFAAOCAQEAMdduKhJXM4HVncbr+TrURE0Inu5e32pbt3nPApy8dmiekKGcC8N/oozxTbqVOfsN
        4OGb9F0kDxuNiBU6fNutzrPJbLo5LEV9JBFUJjANDf9H6gMH5eRmXSx7nR2pEPocsHTyT2lrnqkkhNrtlqDfc6TvahqsS2Ke8XzAFH9IzU2yRPnwPJNtQtjofOYXoJto
        aAko+QKX7xEDumdSrcHps3Om0mPNSuI+5PNO/f+h4LsCEztdIN5VP6OukEAxOHUoXgSpRm3m9Xp5QL0fzehF1a7iXT71dcfmZmNgzNWahIeNJDD37zTQYx2xQmdKDku/
        Og7vtpU6pzjkJZIIpohmgg==
        &quot;&quot;&quot;));

    [Benchmark]
    public void Encrypt()
    {
        Span&lt;byte&gt; src = stackalloc byte[3];
        Span&lt;byte&gt; dest = stackalloc byte[s_rsa.KeySize &gt;&gt; 3];
        s_rsa.TryEncrypt(src, dest, RSAEncryptionPadding.OaepSHA256, out _);
    }

    [Benchmark]
    public void Decrypt()
    {
        Span&lt;byte&gt; dest = stackalloc byte[s_rsa.KeySize &gt;&gt; 3];
        s_rsa.TryDecrypt(s_encrypted, dest, RSAEncryptionPadding.OaepSHA256, out _);
    }

    [Benchmark]
    public void Verify()
    {
        Span&lt;byte&gt; hash = stackalloc byte[256 &gt;&gt; 3];
        s_rsa.VerifyHash(hash, s_signed, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
    }

    [Benchmark]
    public void VerifyFromCert()
    {
        using RSA rsa = s_cert.GetRSAPublicKey();
        Span&lt;byte&gt; sig = stackalloc byte[rsa.KeySize &gt;&gt; 3];
        ReadOnlySpan&lt;byte&gt; hash = sig.Slice(0, 256 &gt;&gt; 3);
        rsa.VerifyHash(hash, sig, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Encrypt</td><td>.NET 7.0</td><td style="text-align: right">132.79 us</td><td style="text-align: right">1.00</td><td style="text-align: right">56 B</td><td style="text-align: right">1.00</td></tr><tr><td>Encrypt</td><td>.NET 8.0</td><td style="text-align: right">19.72 us</td><td style="text-align: right">0.15</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Decrypt</td><td>.NET 7.0</td><td style="text-align: right">653.77 us</td><td style="text-align: right">1.00</td><td style="text-align: right">57 B</td><td style="text-align: right">1.00</td></tr><tr><td>Decrypt</td><td>.NET 8.0</td><td style="text-align: right">538.25 us</td><td style="text-align: right">0.82</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Verify</td><td>.NET 7.0</td><td style="text-align: right">94.92 us</td><td style="text-align: right">1.00</td><td style="text-align: right">56 B</td><td style="text-align: right">1.00</td></tr><tr><td>Verify</td><td>.NET 8.0</td><td style="text-align: right">16.09 us</td><td style="text-align: right">0.17</td><td style="text-align: right">‚Äì</td><td style="text-align: right">0.00</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>VerifyFromCert</td><td>.NET 7.0</td><td style="text-align: right">525.78 us</td><td style="text-align: right">1.00</td><td style="text-align: right">721 B</td><td style="text-align: right">1.00</td></tr><tr><td>VerifyFromCert</td><td>.NET 8.0</td><td style="text-align: right">31.60 us</td><td style="text-align: right">0.06</td><td style="text-align: right">696 B</td><td style="text-align: right">0.97</td></tr></tbody></table><p>For cases where implementations are still using <code>ncrypt</code>, there are however ways we can still avoid of some of the remote procedure calls. <a href="https://github.com/dotnet/runtime/pull/89599">dotnet/runtime#89599</a> does so by caching some information (in particular the key size) that doesn‚Äôt change but that still otherwise results in these remote procedure calls.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Security.Cryptography;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly byte[] _emptyDigest = new byte[256 / 8];
    private byte[] _rsaSignedHash, _ecdsaSignedHash;
    private RSACng _rsa;
    private ECDsaCng _ecdsa;

    [GlobalSetup]
    public void Setup()
    {
        _rsa = new RSACng(2048);
        _rsaSignedHash = _rsa.SignHash(_emptyDigest, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);

        _ecdsa = new ECDsaCng(256);
        _ecdsaSignedHash = _ecdsa.SignHash(_emptyDigest);
    }

    [Benchmark]
    public bool Rsa_VerifyHash() =&gt; _rsa.VerifyHash(_emptyDigest, _rsaSignedHash, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);

    [Benchmark]
    public bool Ecdsa_VerifyHash() =&gt; _ecdsa.VerifyHash(_emptyDigest, _ecdsaSignedHash);
}</code></pre><table><thead><tr><th>Method</th><th>Toolchain</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Rsa_VerifyHash</td><td>.NET 7.0</td><td style="text-align: right">130.27 us</td><td style="text-align: right">1.00</td></tr><tr><td>Rsa_VerifyHash</td><td>.NET 8.0</td><td style="text-align: right">75.30 us</td><td style="text-align: right">0.58</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Ecdsa_VerifyHash</td><td>.NET 7.0</td><td style="text-align: right">400.23 us</td><td style="text-align: right">1.00</td></tr><tr><td>Ecdsa_VerifyHash</td><td>.NET 8.0</td><td style="text-align: right">343.69 us</td><td style="text-align: right">0.86</td></tr></tbody></table><p>The <code>System.Format.Asn1</code> library provides the support used for encoding various data structures used in cryptographic protocols. For example, <code>AsnWriter</code> is used as part of <code>CertificateRequest</code> to create the <code>byte[]</code> that‚Äôs handed off to the <code>X509Certificate2</code>‚Äòs constructor. As part of this, it relies heavily on OIDs (object identifiers) used to uniquely identify things like specific cryptographic algorithms. <a href="https://github.com/dotnet/runtime/pull/75485">dotnet/runtime#75485</a> imbues <code>AsnReader</code> and <code>AsnWriter</code> with knowledge of the most-commonly used OIDs, making reading and writing with them significantly faster.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Formats.Asn1;
using System.Runtime.CompilerServices;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly AsnWriter _writer = new AsnWriter(AsnEncodingRules.DER);

    [Benchmark]
    public void Write()
    {
        _writer.Reset();
        _writer.WriteObjectIdentifier(&quot;1.2.840.10045.4.3.3&quot;); // ECDsa with SHA384
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Write</td><td>.NET 7.0</td><td style="text-align: right">608.50 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Write</td><td>.NET 8.0</td><td style="text-align: right">33.69 ns</td><td style="text-align: right">0.06</td></tr></tbody></table><p>Interestingly, this PR does most of its work in two large switch statements. The first is a nice example of using C# list patterns to <code>switch</code> over a span of bytes and efficiently match to a case. The second is a great example of the C# compiler optimization mentioned earlier around <code>switch</code>es and length bucketing. The internal <code>WellKnownOids.GetContents</code> function this adds to do the lookup is based on a giant switch with ~100 cases. The C# compiler ends up generating a <code>switch</code> over the length of the supplied OID string, and then in each length bucket, it either does a sequential scan through the small number of keys in that bucket, or it does a secondary switch over the character at a specific offset into the input, due to all of the keys having a discriminating character at that position.</p><p>Another interesting change comes in <code>RandomNumberGenerator</code>, which is the cryptographically-secure RNG in <code>System.Security.Cryptography</code> (as opposed to the non-cryptographically secure <code>System.Random</code>). <code>RandomNumberGenerator</code> provides a <code>GetNonZeroBytes</code> bytes method, which is the same as <code>GetBytes</code> but which promises not to yield any 0 values. It does so by using <code>GetBytes</code>, finding any produced 0s, removing them, and then calling <code>GetBytes</code> again to replace all of the 0 values (if that call happens to produce any 0s, then the process repeats). The previous implementation of <code>GetNonZeroBytes</code> was nicely using the vectorized <code>IndexOf((byte)0)</code> to search for a 0. Once it found one, however, it would shift down one at a time the rest of the bytes until the next zero. Since we expect 0s to be rare (on average, they should only occur once ever 256 generated bytes), it‚Äôs much more efficient to search for the next 0 using a vectorized operation, and then shift everything down using a vectorized memory move operation. And that‚Äôs exactly what <a href="https://github.com/dotnet/runtime/pull/81340">dotnet/runtime#81340</a> does.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Security.Cryptography;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private static readonly RandomNumberGenerator s_rng = RandomNumberGenerator.Create();
    private readonly byte[] _bytes = new byte[1024];

    [Benchmark]
    public void GetNonZeroBytes() =&gt; s_rng.GetNonZeroBytes(_bytes);
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>GetNonZeroBytes</td><td>.NET 7.0</td><td style="text-align: right">1,115.8 ns</td><td style="text-align: right">1.00</td></tr><tr><td>GetNonZeroBytes</td><td>.NET 8.0</td><td style="text-align: right">650.8 ns</td><td style="text-align: right">0.58</td></tr></tbody></table><p>Finally, a variety of changes went in to reduce allocation:</p><ul><li><code>AsnWriter</code> now also has a constructor that lets a caller presize its internal buffer, thanks to <a href="https://github.com/dotnet/runtime/pull/73535">dotnet/runtime#73535</a>. That new constructor is then used in <a href="https://github.com/dotnet/runtime/pull/81626">dotnet/runtime#81626</a> to improve throughput on other operations.</li><li><a href="https://github.com/dotnet/runtime/pull/75138">dotnet/runtime#75138</a> removes a <code>string</code> allocation as part of reading certificates on Linux. Stack allocation and spans are used along with <code>Encoding.ASCII.GetString(ReadOnlySpan&lt;byte&gt;, Span&lt;char&gt;)</code> instead of <code>Encoding.ASCII.GetString(byte[])</code> that produces a <code>string</code>.</li><li><code>ECDsa</code>‚Äòs <code>LegalKeySizes</code> don‚Äôt change. The property hands back a <code>KeySizes[]</code> array, and out of precaution the property needs to return a new array on each access, however the actual <code>KeySizes</code> instances are immutable. <a href="https://github.com/dotnet/runtime/pull/76156">dotnet/runtime#76156</a> caches these <code>KeySizes</code> instances.</li></ul><h2 id="logging">Logging</h2><p>Logging, along with telemetry, is the lifeblood of any service. The more logging one incorporates, the more information is available to diagnose issues. But of course the more logging one incorporates, the more resources are possibly spent on logging, and thus it‚Äôs desirable for logging-related code to be as efficient as possible.</p><p>One issue that‚Äôs plagued some applications is in <code>Microsoft.Extensions.Logging</code>‚Äòs <code>LoggerFactory.CreateLogger</code> method. Some libraries are passed an <code>ILoggerFactory</code>, call <code>CreateLogger</code> once, and then store and use that logger for all subsequent interactions; in such cases, the overhead of <code>CreateLogger</code> isn‚Äôt critical. However, other code paths, including some from ASP.NET, end up needing to ‚Äúcreate‚Äù a logger on demand each time it needs to log. That puts significant stress on <code>CreateLogger</code>, incurring its overhead as part of every logging operation. To reduce these overheads, <code>LoggerFactory.CreateLogger</code> has long maintained a <code>Dictionary&lt;TKey, TValue&gt;</code> cache of all logger instances it‚Äôs created: pass in the same <code>categoryName</code>, get back the same <code>ILogger</code> instance (hence why I put ‚Äúcreate‚Äù in quotes a few sentences back). However, that cache is also protected by a lock. That not only means every <code>CreateLogger</code> call is incurring the overhead of acquiring and releasing a lock, but if that lock is contended (meaning others are trying to access it at the same time), that contention can dramatically increase the costs associated with the cache. This is the perfect use case for a <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>, which is optimized with lock-free support for reads, and that‚Äôs exactly how <a href="https://github.com/dotnet/runtime/pull/87904">dotnet/runtime#87904</a> improves performance here. We still want to perform some work atomically when there‚Äôs a cache miss, so the change uses ‚Äúdouble-checked locking‚Äù: it performs a read on the dictionary, and only if the lookup fails does it then fall back to taking the lock, after which it checks the dictionary again, and only if that second read fails does it proceed to create the new logger and store it. The primary benefit of <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> here is it enables us to have that up-front read, which might execute concurrently with another thread mutating the dictionary; that‚Äôs not safe with <code>Dictionary&lt;,&gt;</code> but is with <code>ConcurrentDictionary&lt;,&gt;</code>. This measurably lowers the cost of even uncontended access, but dramatically reduces the overhead when there‚Äôs significant contention.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.Logging;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core70).WithNuGet(&quot;Microsoft.Extensions.Logging&quot;, &quot;7.0.0&quot;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80).WithNuGet(&quot;Microsoft.Extensions.Logging&quot;, &quot;8.0.0-rc.1.23419.4&quot;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;NuGetReferences&quot;)]
public class Tests
{
    private readonly LoggerFactory _factory = new();

    [Benchmark]
    public void Serial() =&gt; _factory.CreateLogger(&quot;test&quot;);

    [Benchmark]
    public void Concurrent()
    {
        Parallel.ForEach(Enumerable.Range(0, Environment.ProcessorCount), (i, ct) =&gt;
        {
            for (int j = 0; j &lt; 1_000_000; j++)
            {
                _factory.CreateLogger(&quot;test&quot;);
            }
        });
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Serial</td><td>.NET 7.0</td><td style="text-align: right">32.775 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Serial</td><td>.NET 8.0</td><td style="text-align: right">7.734 ns</td><td style="text-align: right">0.24</td></tr><tr><td></td><td></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td>Concurrent</td><td>.NET 7.0</td><td style="text-align: right">509,271,719.571 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Concurrent</td><td>.NET 8.0</td><td style="text-align: right">21,613,226.316 ns</td><td style="text-align: right">0.04</td></tr></tbody></table><p>(The same double-checked locking approach is also employed in <a href="https://github.com/dotnet/runtime/pull/73893">dotnet/runtime#73893</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a>, in that case for the Data Contract Serialization library. Similarly, <a href="https://github.com/dotnet/runtime/pull/82536">dotnet/runtime#82536</a> replaces a locked <code>Dictionary&lt;,&gt;</code> with a <code>ConcurrentDictionary&lt;,&gt;</code>, there in <code>System.ComponentModel.DataAnnotations</code>. In that case, it just uses <code>ConcurrentDictionary&lt;,&gt;</code>‚Äòs <code>GetOrAdd</code> method, which provides optimistic concurrency; the supplied delegate could be invoked multiple times in the case of contention to initialize a value for a given key, but only one such value will ever be published for all to consume.)</p><p>Also related to <code>CreateLogger</code>, there‚Äôs a <code>CreateLogger(this ILoggerFactory factory, Type type)</code> extension method and a <code>CreateLogger&lt;T&gt;(this ILoggerFactory factory)</code> extension method, both of which infer the category to use from specified type, using its pretty-printed name. Previously that pretty-printing involved always allocating both a <code>StringBuilder</code> to build up the name and the resulting <code>string</code>. However, those are only necessary for more complex types, e.g. generic types, array types, and generic type parameters. For the common case, <a href="https://github.com/dotnet/runtime/pull/79325">dotnet/runtime#79325</a> from <a href="https://github.com/benaadams">@benaadams</a> avoids those overheads, which were incurred even when the request for the logger could be satisfied from the cache, because the name was necessary to even perform the cache lookup.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.Logging;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core70).WithNuGet(&quot;Microsoft.Extensions.Logging&quot;, &quot;7.0.0&quot;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80).WithNuGet(&quot;Microsoft.Extensions.Logging&quot;, &quot;8.0.0-rc.1.23419.4&quot;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;NuGetReferences&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly LoggerFactory _factory = new();

    [Benchmark]
    public ILogger CreateLogger() =&gt; _factory.CreateLogger&lt;Tests&gt;();
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>CreateLogger</td><td>.NET 7.0</td><td style="text-align: right">156.77 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">160 B</td><td style="text-align: right">1.00</td></tr><tr><td>CreateLogger</td><td>.NET 8.0</td><td style="text-align: right">70.82 ns</td><td style="text-align: right">0.45</td><td style="text-align: right">24 B</td><td style="text-align: right">0.15</td></tr></tbody></table><p>There are also changes in .NET 8 to reduce overheads when logging actually does occur, and one such change makes use of a new .NET 8 feature we‚Äôve already talked about: <code>CompositeFormat</code>. <code>CompositeFormat</code> isn‚Äôt currently used in many places throughout the core libraries, as most of the formatting they do is either with strings known at build time (in which case they use interpolated strings) or are on exceptional code paths (in which case we generally don‚Äôt want to regress working set or startup in order to optimize error conditions). However, there is one key place <code>CompositeFormat</code> is now used: in <code>LoggerMessage.Define</code>. This method is similar in concept to <code>CompositeFormat</code>: rather than having to redo work every time you want to log something, instead spend some more resources to frontload and cache that work, in order to optimize subsequent usage‚Ä¶ that‚Äôs what <code>LoggerMessage.Define</code> does, just for logging. <code>Define</code> returns a strongly-typed delegate that can then be used any time logging should be performed. As of the same PR that introduced <code>CompositeFormat</code>, <code>LoggerMessage.Define</code> now also constructs a <code>CompositeFormat</code> under the covers, and uses that instance to perform any formatting work necessary based on the log message pattern provided (previously it would just call <code>string.Format</code> as part of every log operation that needed it).</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.Logging;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public class Tests
{
    private readonly Action&lt;ILogger, int, Exception&gt; _message = LoggerMessage.Define&lt;int&gt;(LogLevel.Critical, 1, &quot;The value is {0}.&quot;);
    private readonly ILogger _logger = new MyLogger();

    [Benchmark]
    public void Format() =&gt; _message(_logger, 42, null);

    sealed class MyLogger : ILogger
    {
        public IDisposable BeginScope&lt;TState&gt;(TState state) =&gt; null;
        public bool IsEnabled(LogLevel logLevel) =&gt; true;
        public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&lt;TState, Exception, string&gt; formatter) =&gt; formatter(state, exception);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Format</td><td>.NET 7.0</td><td style="text-align: right">127.04 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Format</td><td>.NET 8.0</td><td style="text-align: right">91.78 ns</td><td style="text-align: right">0.72</td></tr></tbody></table><p><code>LoggerMessage.Define</code> is used as part of the logging source generator, so the benefits there implicitly accrue not only to direct usage of <code>LoggerMessage.Define</code> but also to any use of the generator. We can see that in this benchmark here:</p><pre><code class="language-C#">// For this test, you&#39;ll also need to add:
//     &lt;PackageReference Include=&quot;Microsoft.Extensions.Logging.Abstractions&quot; Version=&quot;7.0.0&quot; /&gt;
// to the benchmarks.csproj&#39;s &lt;ItemGroup&gt;.
// dotnet run -c Release -f net7.0 --filter &quot;*&quot; --runtimes net7.0 net8.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.Logging;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public partial class Tests
{
    private readonly ILogger _logger = new MyLogger();

    [Benchmark]
    public void Log() =&gt; LogValue(42);

    [LoggerMessage(1, LogLevel.Critical, &quot;The value is {Value}.&quot;)]
    private partial void LogValue(int value);

    sealed class MyLogger : ILogger
    {
        public IDisposable BeginScope&lt;TState&gt;(TState state) =&gt; null;
        public bool IsEnabled(LogLevel logLevel) =&gt; true;
        public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&lt;TState, Exception, string&gt; formatter) =&gt; formatter(state, exception);
    }
}</code></pre><p>Note the <code>LogValue</code> method, which is declared as a <code>partial</code> method with the <code>LoggerMessage</code> attribute applied to it. The generator will see that and inject into my application the following implementation (the only changes I‚Äôve made to this copied code are removing the fully-qualified names, for readability), which as is visible here uses <code>LoggerMessage.Define</code>:</p><pre><code class="language-C#">partial class Tests
{
    [GeneratedCode(&quot;Microsoft.Extensions.Logging.Generators&quot;, &quot;7.0.0&quot;)]
    private static readonly Action&lt;ILogger, Int32, Exception?&gt; __LogValueCallback =
        LoggerMessage.Define&lt;Int32&gt;(LogLevel.Information, new EventId(1, nameof(LogValue)), &quot;The value is {Value}.&quot;, new LogDefineOptions() { SkipEnabledCheck = true });

    [GeneratedCode(&quot;Microsoft.Extensions.Logging.Generators&quot;, &quot;7.0.0&quot;)]
    private partial void LogValue(Int32 value)
    {
        if (_logger.IsEnabled(LogLevel.Information))
        {
            __LogValueCallback(_logger, value, null);
        }
    }
}</code></pre><p>When running the benchmark, then, we can see the improvements that use <code>CompositeFormat</code> end up translating nicely:</p><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>Log</td><td>.NET 7.0</td><td style="text-align: right">94.10 ns</td><td style="text-align: right">1.00</td></tr><tr><td>Log</td><td>.NET 8.0</td><td style="text-align: right">74.68 ns</td><td style="text-align: right">0.79</td></tr></tbody></table><p>Other changes have also gone into reducing overheads in logging. Here‚Äôs the same <code>LoggerMessage.Define</code> benchmark as before, but I‚Äôve tweaked two things:</p><ol><li>I‚Äôve added <code>[MemoryDiagnoser]</code> so that allocation is more visible.</li><li>I‚Äôve explicitly controlled which NuGet package version is used for which run.</li></ol><p>The <code>Microsoft.Extensions.Logging.Abstractions</code> package carries with it multiple ‚Äúassets‚Äù; the v7.0.0 package, even though it‚Äôs ‚Äú7.0.0,‚Äù carries with it a build for net7.0, for net6.0, for netstandard2.0, etc. Similarly, the v8.0.0 package, even though it‚Äôs ‚Äú8.0.0,‚Äù carries with it a build for net8.0, for net7.0, and so on. Each of those is created from compiling the source for that Target Framework Moniker (TFM). Changes that are specific to a particular TFM, such as the change to use <code>CompositeFormat</code>, are only compiled into that build, but other improvements that aren‚Äôt specific to a particular TFM end up in all of them. As such, to be able to see improvements that have gone into the general code in the last year, we need to actually compare the two different NuGet packages, and can‚Äôt just compare the net8.0 vs net7.0 assets in the same package version.</p><pre><code class="language-C#">// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.Logging;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core70).WithNuGet(&quot;Microsoft.Extensions.Logging&quot;, &quot;7.0.0&quot;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80).WithNuGet(&quot;Microsoft.Extensions.Logging&quot;, &quot;8.0.0-rc.1.23419.4&quot;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;NuGetReferences&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public class Tests
{
    private readonly Action&lt;ILogger, int, Exception&gt; _message = LoggerMessage.Define&lt;int&gt;(LogLevel.Critical, 1, &quot;The value is {0}.&quot;);
    private readonly ILogger _logger = new MyLogger();

    [Benchmark]
    public void Format() =&gt; _message(_logger, 42, null);

    sealed class MyLogger : ILogger
    {
        public IDisposable BeginScope&lt;TState&gt;(TState state) =&gt; null;
        public bool IsEnabled(LogLevel logLevel) =&gt; true;
        public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&lt;TState, Exception, string&gt; formatter) =&gt; formatter(state, exception);
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Format</td><td>.NET 7.0</td><td style="text-align: right">96.44 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">80 B</td><td style="text-align: right">1.00</td></tr><tr><td>Format</td><td>.NET 8.0</td><td style="text-align: right">46.75 ns</td><td style="text-align: right">0.48</td><td style="text-align: right">56 B</td><td style="text-align: right">0.70</td></tr></tbody></table><p>Notice that throughput has increased and allocation has dropped. That‚Äôs primarily due to <a href="https://github.com/dotnet/runtime/pull/88560">dotnet/runtime#88560</a>, which avoids boxing value type arguments as they‚Äôre being passed through the formatting logic.</p><p><a href="https://github.com/dotnet/runtime/pull/89160">dotnet/runtime#89160</a> is another interesting example, not because it‚Äôs a significant savings (it ends up saving an allocation per HTTP request made using an <code>HttpClient</code> created from an <code>HttpClientFactory</code>), but because of why the allocation is there in the first place. Consider this C# class:</p><pre><code class="language-C#">public class C
{
    public void M(int value)
    {
        Console.WriteLine(value);
        LocalFunction();

        void LocalFunction() =&gt; Console.WriteLine(value);
    }
}</code></pre><p>We‚Äôve got a method <code>M</code> that contains a local function <code>LocalFunction</code> that ‚Äúcloses over‚Äù <code>M</code>‚Äòs <code>int value</code> argument. How does <code>value</code> find its way into that <code>LocalFunction</code>? Let‚Äôs look at a decompiled version of the IL the compiler generates:</p><pre><code class="language-C#">public class C
{
    public void M(int value)
    {
        &lt;&gt;c__DisplayClass0_0 &lt;&gt;c__DisplayClass0_ = default(&lt;&gt;c__DisplayClass0_0);
        &lt;&gt;c__DisplayClass0_.value = value;
        Console.WriteLine(&lt;&gt;c__DisplayClass0_.value);
        &lt;M&gt;g__LocalFunction|0_0(ref &lt;&gt;c__DisplayClass0_);
    }

    [StructLayout(LayoutKind.Auto)]
    [CompilerGenerated]
    private struct &lt;&gt;c__DisplayClass0_0
    {
        public int value;
    }

    [CompilerGenerated]
    private static void &lt;M&gt;g__LocalFunction|0_0(ref &lt;&gt;c__DisplayClass0_0 P_0)
    {
        Console.WriteLine(P_0.value);
    }
}</code></pre><p>So, the compiler has emitted the <code>LocalFunction</code> as a static method, and it‚Äôs passed the state it needs by reference, with all of the state in a separate type (which the compiler refers to as a ‚Äúdisplay class‚Äù). Note that a) the instance of this type is constructed in <code>M</code> in order to store the <code>value</code> argument, and that all references to <code>value</code>, whether in <code>M</code> or in <code>LocalFunction</code>, are to the shared <code>value</code> on the display class, and b) that ‚Äúclass‚Äù is actually declared as a <code>struct</code>. That means we‚Äôre not going to incur any allocation as part of that data sharing. But now, let‚Äôs add a single keyword to our repro: add <code>async</code> to <code>LocalFunction</code> (I‚Äôve elided some irrelevant code here for clarity):</p><pre><code class="language-C#">public class C
{
    public void M(int value)
    {
        &lt;&gt;c__DisplayClass0_0 &lt;&gt;c__DisplayClass0_ = new &lt;&gt;c__DisplayClass0_0();
        &lt;&gt;c__DisplayClass0_.value = value;
        Console.WriteLine(&lt;&gt;c__DisplayClass0_.value);
        &lt;&gt;c__DisplayClass0_.&lt;M&gt;g__LocalFunction|0();
    }

    [CompilerGenerated]
    private sealed class &lt;&gt;c__DisplayClass0_0
    {
        [StructLayout(LayoutKind.Auto)]
        private struct &lt;&lt;M&gt;g__LocalFunction|0&gt;d : IAsyncStateMachine { ... }

        public int value;

        [AsyncStateMachine(typeof(&lt;&lt;M&gt;g__LocalFunction|0&gt;d))]
        internal void &lt;M&gt;g__LocalFunction|0()
        {
            &lt;&lt;M&gt;g__LocalFunction|0&gt;d stateMachine = default(&lt;&lt;M&gt;g__LocalFunction|0&gt;d);
            stateMachine.&lt;&gt;t__builder = AsyncVoidMethodBuilder.Create();
            stateMachine.&lt;&gt;4__this = this;
            stateMachine.&lt;&gt;1__state = -1;
            stateMachine.&lt;&gt;t__builder.Start(ref stateMachine);
        }
    }
}</code></pre><p>The code for <code>M</code> looks <em>almost</em> the same, but there‚Äôs a key difference: instead of <code>default(&lt;&gt;c__DisplayClass0_0)</code>, it has <code>new &lt;&gt;c__DisplayClass0_0()</code>. That‚Äôs because the display class now actually is a <code>class</code> rather than being a <code>struct</code>, and that‚Äôs because the state can no longer live on the stack; it‚Äôs being passed to an asynchronous method, which may need to continue to use it even after the stack has unwound. And that means it becomes more important avoiding these kinds of implicit closures when dealing with local functions that are asynchronous.</p><p>In this particular case, <code>LoggingHttpMessageHandler</code> (and <code>LoggingScopeHttpMessageHandler</code>) had a <code>SendCoreAsync</code> method that looked like this:</p><pre><code class="language-C#">private Task&lt;HttpResponseMessage&gt; SendCoreAsync(HttpRequestMessage request, bool useAsync, CancellationToken cancellationToken)
{
    ThrowHelper.ThrowIfNull(request);
    return Core(request, cancellationToken);

    async Task&lt;HttpResponseMessage&gt; Core(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        ...
        HttpResponseMessage response = useAsync ? ... : ...;
        ...
    }
}</code></pre><p>Based on the previous discussion, you likely see the problem here: <code>useAsync</code> is being implicitly closed over by the local function, resulting in this allocating a display class to pass that state in. The cited PR changed the code to instead be:</p><pre><code class="language-C#">private Task&lt;HttpResponseMessage&gt; SendCoreAsync(HttpRequestMessage request, bool useAsync, CancellationToken cancellationToken)
{
    ThrowHelper.ThrowIfNull(request);
    return Core(request, useAsync, cancellationToken);

    async Task&lt;HttpResponseMessage&gt; Core(HttpRequestMessage request, bool useAsync, CancellationToken cancellationToken)
    {
        ...
        HttpResponseMessage response = useAsync ? ... : ...;
        ...
    }
}</code></pre><p>and, voila, the allocation is gone.</p><p><code>EventSource</code> is another logging mechanism in .NET that‚Äôs lower-level and which is used by the core libraries for their logging needs. The runtime itself publishes its events for things like the GC and the JIT via an <code>EventSource</code>, something I relied on earlier in this post when tracking how many <code>GCHandle</code>s were created (search above for <code>GCHandleListener</code>). When eventing is enabled for a particular source, that <code>EventSource</code> publishes a manifest describing the possible events and the shape of the data associated with each. While in the future, we aim to use a source generator to create that manifest at build time, today it‚Äôs all generated at run-time, using reflection to analyze the events defined on the <code>EventSource</code>-derived type and to dynamically build up the description. That unfortunately has some cost, which can measurably impact startup. Thankfully, one of the main contributors here is the manifest for that runtime source, <code>NativeRuntimeEventSource</code>, as it‚Äôs ever present, but it‚Äôs not actually necessary, since tools that consume this information already know about the well-documented schema. As such, <a href="https://github.com/dotnet/runtime/pull/78213">dotnet/runtime#78213</a> stopped emitting the manifest for <code>NativeRuntimeEventSource</code> such that it doesn‚Äôt send a large amount of data across to the consumer that will subsequently ignore it. That prevented it from being sent, but it was still being created. <a href="https://github.com/dotnet/runtime/pull/86850">dotnet/runtime#86850</a> from <a href="https://github.com/n77y">@n77y</a> addressed a large chunk of that by reducing the costs of that generation. The effect of this is obvious if we do a .NET allocation profile of a simple nop console application.</p><pre><code class="language-C#">class Program { static void Main() { } }</code></pre><p>On .NET 7, we observe this:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/NativeRuntimeEventSourceAllocsNet7.png" alt="Allocation from the NativeRuntimeEventSource on .NET 7" />
And on .NET 8, that reduces to this:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/NativeRuntimeEventSourceAllocsNet8.png" alt="Allocation from the NativeRuntimeEventSource on .NET 8" />
(In the future, hopefully this whole thing will go away due to precomputing the manifest.)</p><p><code>EventSource</code> also relies heavily on interop, and as part of that it‚Äôs historically used delegate marshaling as part of implementing callbacks from native code. <a href="https://github.com/dotnet/runtime/pull/79970">dotnet/runtime#79970</a> switches it over to using function pointers, which is not only more efficient, it eliminates this as one of the last uses of delegate marshaling in the core libraries. That means for Native AOT, all of the code associated with supporting delegate marshaling can typically now be trimmed away, reducing application size further.</p><h2 id="configuration">Configuration</h2><p>Configuration support is critical for many services and applications, such that information necessary to the execution of the code can be extracted from the code, whether that be into a JSON file, environment variables, Azure Key Vault, wherever. This information then needs to be loaded into the application in a convenient manner, typically at startup but also potentially any time the configuration is seen to change. It‚Äôs thus not a typical candidate for throughput-focused optimization, but it is still valuable to drive associated costs down, especially to help with startup performance.</p><p>With <code>Microsoft.Extensions.Configuration</code>, configuration is handled primarily with a <code>ConfigurationBuilder</code>, an <code>IConfiguration</code>, and a ‚Äúbinder.‚Äù Using a <code>ConfigurationBuilder</code>, you add in the various sources of your configuration information (e.g. <code>AddEnvironmentVariables</code>, <code>AddAzureKeyVault</code>, etc.), and then you publish that as an <code>IConfiguration</code> instance. In typical use, you then extract from that <code>IConfiguration</code> the data you want by ‚Äúbinding‚Äù it to an object, meaning a <code>Bind</code> method populates the provided object with data from the configuration based on the shape of the object. Let‚Äôs measure the cost of that <code>Bind</code> specifically:</p><pre><code class="language-C#">// For this test, you&#39;ll also need to add:
//     &lt;EnableConfigurationBindingGenerator&gt;true&lt;/EnableConfigurationBindingGenerator&gt;
//     &lt;Features&gt;$(Features);InterceptorsPreview&lt;/Features&gt;
// to the PropertyGroup in the benchmarks.csproj file, and add:
//    &lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration&quot; Version=&quot;7.0.0&quot; /&gt;
//    &lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration.EnvironmentVariables&quot; Version=&quot;7.0.0&quot; /&gt;
//    &lt;PackageReference Include=&quot;Microsoft.Extensions.Configuration.Binder&quot; Version=&quot;8.0.0-rc.1.23419.4&quot; Condition=&quot;&#39;$(TargetFramework)&#39;==&#39;net8.0&#39;&quot; /&gt;
// to the ItemGroup.
// dotnet run -c Release -f net7.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.Configuration;

var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core70).WithNuGet(&quot;Microsoft.Extensions.Configuration&quot;, &quot;7.0.0&quot;).AsBaseline())
    .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80)
        .WithNuGet(&quot;Microsoft.Extensions.Configuration&quot;, &quot;8.0.0-rc.1.23419.4&quot;)
        .WithNuGet(&quot;Microsoft.Extensions.Configuration.Binder&quot;, &quot;8.0.0-rc.1.23419.4&quot;));
BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;, &quot;NuGetReferences&quot;)]
[MemoryDiagnoser(displayGenColumns: false)]
public partial class Tests
{
    private readonly MyConfigSection _data = new();
    private IConfiguration _config;

    [GlobalSetup]
    public void Setup()
    {
        Environment.SetEnvironmentVariable(&quot;MyConfigSection__Message&quot;, &quot;Hello World!&quot;);
        _config = new ConfigurationBuilder()
            .AddEnvironmentVariables()
            .Build();
    }

    [Benchmark]
    public void Load() =&gt; _config.Bind(&quot;MyConfigSection&quot;, _data);

    internal sealed class MyConfigSection
    {
        public string Message { get; set; }
    }
}</code></pre><table><thead><tr><th>Method</th><th>Runtime</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th><th style="text-align: right">Allocated</th><th style="text-align: right">Alloc Ratio</th></tr></thead><tbody><tr><td>Load</td><td>.NET 7.0</td><td style="text-align: right">1,747.15 ns</td><td style="text-align: right">1.00</td><td style="text-align: right">1328 B</td><td style="text-align: right">1.00</td></tr><tr><td>Load</td><td>.NET 8.0</td><td style="text-align: right">73.45 ns</td><td style="text-align: right">0.04</td><td style="text-align: right">112 B</td><td style="text-align: right">0.08</td></tr></tbody></table><p>Whoa.</p><p>Much of that cost in .NET 7 comes from what I alluded to earlier when I said ‚Äúbased on the shape of the object.‚Äù That <code>Bind</code> call is using this extension method defined in the <code>Microsoft.Extensions.Configuration.ConfigurationBinder</code> type:</p><pre><code class="language-C#">public static void Bind(this IConfiguration configuration, string key, object? instance)</code></pre><p>How does it know what data to extract from the configuration and where on the <code>object</code> to store it? Reflection, of course. That means that every <code>Bind</code> call is using reflection to walk the supplied <code>object</code>‚Äòs type information, and is using reflection to store the configuration data onto the instance. That‚Äôs not cheap.</p><p>What changes then in .NET 8? The mention of ‚ÄúEnableConfigurationBindingGenerator‚Äù in the benchmark code above probably gives it away, but the answer is there‚Äôs a new source generator for configuration in .NET 8. This source generator was initially introduced in <a href="https://github.com/dotnet/runtime/pull/82179">dotnet/runtime#82179</a> and was then improved upon in a multitude of PRs like <a href="https://github.com/dotnet/runtime/pull/84154">dotnet/runtime#84154</a>, <a href="https://github.com/dotnet/runtime/pull/86076">dotnet/runtime#86076</a>, <a href="https://github.com/dotnet/runtime/pull/86285">dotnet/runtime#86285</a>, and <a href="https://github.com/dotnet/runtime/pull/86365">dotnet/runtime#86365</a>. The crux of the idea behind the configuration source generator is to emit a <em>replacement</em> for that <code>Bind</code> method, one that knows exactly what type is being populated and can do all the examination of its shape at build-time rather than at run-time via reflection.</p><p>‚ÄúReplacement.‚Äù For anyone familiar with C# source generators, this might be setting off alarm bells in your head. Source generators plug into the compiler and are handed all the data the compiler has about the code being compiled; the source generator is then able to <em>augment</em> that data, generating additional code into separate files that the compiler then also compiles into the same assembly. Source generators are able to add code but they can‚Äôt rewrite the code. This is why you see source generators like the <code>Regex</code> source generator or the <code>LibraryImport</code> source generator or the <code>LoggerMessage</code> source generator relying on partial methods: the developer writes the partial method declaration for the method they then consume in their code, and then separately the generator emits a partial method definition to supply the implementation for that method. How then is this new configuration generator able to <em>replace</em> a call to an existing method? I‚Äôm glad you asked! It takes advantage of a new preview feature of the C# compiler, added primarily in <a href="https://github.com/dotnet/roslyn/pull/68564">dotnet/roslyn#68564</a>: interceptors.</p><p>Consider this program, defined in a <code>/home/stoub/benchmarks/Program.cs</code> file (and where the associated .csproj contains <code>&lt;Features&gt;$(Features);InterceptorsPreview&lt;/Features&gt;</code> to enable the preview feature):</p><pre><code class="language-C#">// dotnet run -c Release -f net8.0

using System.Runtime.CompilerServices;

Console.WriteLine(&quot;Hello World!&quot;);

// ----------------------------------

internal static class Helpers
{
    [InterceptsLocation(@&quot;/home/stoub/benchmarks/Program.cs&quot;, 5, 9)]
    internal static void NotTheRealWriteLine(string message) =&gt;
        Console.WriteLine($&quot;The message was &#39;{message}&#39;.&quot;);
}

namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(string filePath, int line, int column) { }
    }
}</code></pre><p>This is a ‚Äúhello world‚Äù application, except not quite the one-liner you‚Äôre used to. There‚Äôs a call to <code>Console.WriteLine</code>, but there‚Äôs also a method decorated with <code>InterceptsLocation</code>. That method has the same signature as the <code>Console.WriteLine</code> being used, and the attribute is pointing to the <code>WriteLine</code> method call in <code>Program.cs</code>‚Äòs line 5 column 9. When the compiler sees this, it will change that call from <code>Console.WriteLine(&quot;Hello World!&quot;)</code> to instead be <code>Helpers.NotTheRealWriteLine(&quot;Hello World!&quot;)</code>, allowing this other method in the same compilation unit to intercept the original call. This interceptor needn‚Äôt be in the same file, so a source generator can analyze the code handed to it, find a call it wants to intercept, and augment the compilation unit with such an interceptor.</p><p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/InterceptorHelloWorld.png" alt=""Decompiled "Hello" World" with Interceptors" /></p><p>That‚Äôs exactly what the configuration source generator does. In this benchmark, for example, the core of what the source generator emits is here (I‚Äôve elided stuff that‚Äôs not relevant to this discussion):</p><pre><code class="language-C#">[InterceptsLocationAttribute(@&quot;.../LoggerFilterConfigureOptions.cs&quot;, 21, 35)]
public static void Bind_TestsMyConfigSection(this IConfiguration configuration, string key, object? obj)
{
    ...
    var typedObj = (Tests.MyConfigSection)obj;
    BindCore(configuration.GetSection(key), ref typedObj, binderOptions: null);
}

public static void BindCore(IConfiguration configuration, ref Tests.MyConfigSection obj, BinderOptions? binderOptions)
{
    ...
    obj.Message = configuration[&quot;Message&quot;]!;
}</code></pre><p>We can see the generated <code>Bind</code> method is strongly typed for my <code>MyConfigSection</code> type, and the generated <code>Bind_TestsMyConfigSection</code> method it invokes extracts the <code>&quot;Message&quot;</code> value from the <code>configuration</code> and stores it directly into the property. No reflection anywhere in sight.</p><p>This is obviously great for throughput, but that actually wasn‚Äôt the primary goal for this particular source generator. Rather, it was in support of Native AOT and trimming. Without direct use of various portions of the object model for the bound object, the trimmer could see portions of it as being unused and trim them away (such as setters for properties that are only read by the application), at which point that data would not be available (because the deserializer would see the properties as being get-only). By having everything strongly typed in the generated source, that issue goes away. And as a bonus, if there isn‚Äôt other use of the reflection stack keeping it rooted, the trimmer can get rid of that, too.</p><p><code>Bind</code> isn‚Äôt the only method that‚Äôs replaceable. <code>ConfigurationBinder</code> provides other methods consumers can use, like <code>GetValue</code>, which just retrieves the value associated with a specific key, and the configuration source generator can emit replacements for those as well. <a href="https://github.com/dotnet/runtime/pull/87935">dotnet/runtime#87935</a> modified <code>Microsoft.Extensions.Logging.Configuration</code> to employ the config generator for this purpose, as it uses <code>GetValue</code> in its <code>LoadDefaultConfigValues</code> method:</p><pre><code class="language-C#">private void LoadDefaultConfigValues(LoggerFilterOptions options)
{
    if (_configuration == null)
    {
        return;
    }
    options.CaptureScopes = _configuration.GetValue(nameof(options.CaptureScopes), options.CaptureScopes);
    ...
}</code></pre><p>And if we look at what‚Äôs in the compiled binary (via <a href="https://github.com/icsharpcode/ILSpy">ILSpy</a>), we see this:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/09/ILSpyDecompiledLoadDefaultConfigValues.png" alt="ILSpy decompilation of LoadDefaultConfigValues" /></p><p>So, the code looks the same, but the actual target of the <code>GetValue</code> is the intercepting method emitted by the source generator. When that change merged, it knocked ~640Kb off the size of the ASP.NET app being used as an exemplar to track Native AOT app size!</p><p>Once data has been loaded from the configuration system into some kind of model, often the next step is to validate that the supplied data meets requirements. Whether a data model is populated once from configuration or per request for user input, a typical approach for achieving such validation is via the <code>System.ComponentModel.DataAnnotations</code> namespace. This namespace supplies attributes that can be applied to members of a type to indicate constraints the data must satisfy, such as <code>[Required]</code> to indicate the data must be supplied or <code>[MinLength(...)]</code> to indicate a minimum length for a string, and .NET 8 adds additional attributes via <a href="https://github.com/dotnet/runtime/pull/82311">dotnet/runtime#82311</a>, for example <code>[Base64String]</code>. On top of this, <code>Microsoft.Extensions.Options.DataAnnotationValidateOptions</code> provides an implementation of the <code>IValidateOptions&lt;TOptions&gt;</code> interface (an implementation of which is typically retrieved via DI) for validating models based on data annotations, and as you can probably guess, it does so via reflection. As is a trend you‚Äôre probably picking up on, for many such areas involving reflection, .NET has been moving to add source generators that can do at build-time what would have otherwise been done at run-time; that‚Äôs the case here as well. As of <a href="https://github.com/dotnet/runtime/pull/87587">dotnet/runtime#87587</a>, the <code>Microsoft.Extensions.Options</code> package in .NET 8 now includes a source generator that creates an implementation of <code>IValidateOptions&lt;TOptions&gt;</code> for a specific <code>TOptions</code> type.</p><p>For example, consider this benchmark:</p><pre><code class="language-C#">// For this test, you&#39;ll also need to add these:
//  &lt;PackageReference Include=&quot;Microsoft.Extensions.Options&quot; Version=&quot;8.0.0-rc.1.23419.4&quot; /&gt;
//  &lt;PackageReference Include=&quot;Microsoft.Extensions.Options.DataAnnotations&quot; Version=&quot;8.0.0-rc.1.23419.4&quot; /&gt;
// to the benchmarks.csproj&#39;s &lt;ItemGroup&gt;.
// dotnet run -c Release -f net8.0 --filter &quot;*&quot;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.Options;
using System.ComponentModel.DataAnnotations;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[HideColumns(&quot;Error&quot;, &quot;StdDev&quot;, &quot;Median&quot;, &quot;RatioSD&quot;)]
public partial class Tests
{
    private readonly DataAnnotationValidateOptions&lt;MyOptions&gt; _davo = new DataAnnotationValidateOptions&lt;MyOptions&gt;(null);
    private readonly MyOptionsValidator _ov = new();
    private readonly MyOptions _options = new() { Path = &quot;1234567890&quot;, Address = &quot;http://localhost/path&quot;, PhoneNumber = &quot;555-867-5309&quot; };

    [Benchmark(Baseline = true)]
    public ValidateOptionsResult WithReflection() =&gt; _davo.Validate(null, _options);

    [Benchmark]
    public ValidateOptionsResult WithSourceGen() =&gt; _ov.Validate(null, _options);

    public sealed class MyOptions
    {
        [Length(1, 10)]
        public string Path { get; set; }

        [Url]
        public string Address { get; set; }

        [Phone]
        public string PhoneNumber { get; set; }
    }

    [OptionsValidator]
    public partial class MyOptionsValidator : IValidateOptions&lt;MyOptions&gt; { }
}</code></pre><p>Note the <code>[OptionsValidator]</code> at the end. It‚Äôs applied to a <code>partial</code> class that implements <code>IValidatOptions&lt;MyOptions&gt;</code>, which tells the source generator to emit the implementation for this interface in order to validate <code>MyOptions</code>. It ends up emitting code like this (which I‚Äôve simplified a tad, e.g. removing fully-qualified namespaces, for the purposes of this post):</p><pre><code class="language-C#">[GeneratedCode(&quot;Microsoft.Extensions.Options.SourceGeneration&quot;, &quot;8.0.8.41903&quot;)]
public ValidateOptionsResult Validate(string? name, MyOptions options)
{
    var context = new ValidationContext(options);
    var validationResults = new List&lt;ValidationResult&gt;();
    var validationAttributes = new List&lt;ValidationAttribute&gt;(2);
    ValidateOptionsResultBuilder? builder = null;

    context.MemberName = &quot;Path&quot;;
    context.DisplayName = string.IsNullOrEmpty(name) ? &quot;MyOptions.Path&quot; : $&quot;{name}.Path&quot;;
    validationAttributes.Add(__OptionValidationStaticInstances.__Attributes.A1);
    validationAttributes.Add(__OptionValidationStaticInstances.__Attributes.A2);
    if (!Validator.TryValidateValue(options.Path, context, validationResults, validationAttributes))
        (builder ??= new()).AddResults(validationResults);

    context.MemberName = &quot;Address&quot;;
    context.DisplayName = string.IsNullOrEmpty(name) ? &quot;MyOptions.Address&quot; : $&quot;{name}.Address&quot;;
    validationResults.Clear();
    validationAttributes.Clear();
    validationAttributes.Add(__OptionValidationStaticInstances.__Attributes.A3);
    if (!Validator.TryValidateValue(options.Address, context, validationResults, validationAttributes))
        (builder ??= new()).AddResults(validationResults);

    context.MemberName = &quot;PhoneNumber&quot;;
    context.DisplayName = string.IsNullOrEmpty(name) ? &quot;MyOptions.PhoneNumber&quot; : $&quot;{name}.PhoneNumber&quot;;
    validationResults.Clear();
    validationAttributes.Clear();
    validationAttributes.Add(__OptionValidationStaticInstances.__Attributes.A4);
    if (!Validator.TryValidateValue(options.PhoneNumber, context, validationResults, validationAttributes))
        (builder ??= new()).AddResults(validationResults);

    return builder is not null ? builder.Build() : ValidateOptionsResult.Success;
}</code></pre><p>eliminating the need to use reflection to discover the relevant properties and their attribution. The benchmark results highlight the benefits:</p><table><thead><tr><th>Method</th><th style="text-align: right">Mean</th><th style="text-align: right">Ratio</th></tr></thead><tbody><tr><td>WithReflection</td><td style="text-align: right">2,926.2 ns</td><td style="text-align: right">1.00</td></tr><tr><td>WithSourceGen</td><td style="text-align: right">403.5 ns</td><td style="text-align: right">0.14</td></tr></tbody></table><h2 id="peanut-butter">Peanut Butter</h2><p>In every .NET release, there are a multitude of welcome PRs that make small improvements. These changes on their own typically don‚Äôt ‚Äúmove the needle,‚Äù don‚Äôt on their own make very measurable end-to-end changes. However, an allocation removed here, an unnecessary bounds check removed there, it all adds up. Constantly working to remove this ‚Äúpeanut butter,‚Äù as we often refer to it (a thin smearing of overhead across everything), helps improve the performance of the platform in the aggregate.</p><p>Here are some examples from the last year:</p><ul><li><a href="https://github.com/dotnet/runtime/pull/77832">dotnet/runtime#77832</a>. The <code>MemoryStream</code> type provides a convenient <code>ToArray()</code> method that gives you all the stream‚Äôs data as a new <code>byte[]</code>. But while convenient, it‚Äôs a potentially large allocation and copy. The lesser known <code>GetBuffer</code> and <code>TryGetBuffer</code> methods give one access to the <code>MemoryStream</code>‚Äòs buffer directly, without incurring an allocation or copy. This PR replaced use of <code>ToArray</code> in <code>System.Private.Xml</code> and in <code>System.Reflection.Metadata</code> that were better served by <code>GetBuffer()</code>. Not only did it remove unnecessary allocation, as a bonus it also resulted in less code.</li><li><a href="https://github.com/dotnet/runtime/pull/80523">dotnet/runtime#80523</a> and <a href="https://github.com/dotnet/runtime/pull/80389">dotnet/runtime#80389</a> removed string allocations from the <code>System.ComponentModel.Annotations</code> library. <code>CreditCardAttribute</code> was making two calls to <code>string.Replace</code> to remove <code>&#39;-&#39;</code> and <code>&#39; &#39;</code> characters, but it was then looping over every character in the input‚Ä¶ rather than creating new strings without those characters, the loop can simply skip over them. Similarly, <code>PhoneAttribute</code> contained 6 <code>string.Substring</code> calls, all of which could be replaced with simple <code>ReadOnlySpan&lt;char&gt;</code> slices.</li><li><a href="https://github.com/dotnet/runtime/pull/82041">dotnet/runtime#82041</a>, <a href="https://github.com/dotnet/runtime/pull/87479">dotnet/runtime#87479</a>, and <a href="https://github.com/dotnet/runtime/pull/80386">dotnet/runtime#80386</a> changed several hundred lines across <a href="https://github.com/dotnet/runtime">dotnet/runtime</a> to avoid various array and <code>string</code> allocation. In some cases it used <code>stackalloc</code>, in others <code>ArrayPool</code>, in others simply deleting arrays that were never used, in others using <code>ReadOnlySpan&lt;char&gt;</code> and slicing.</li><li><a href="https://github.com/dotnet/runtime/pull/82411">dotnet/runtime#82411</a> from <a href="https://github.com/xtqqczze">@xtqqczze</a> and <a href="https://github.com/dotnet/runtime/pull/82456">dotnet/runtime#82456</a> from <a href="https://github.com/xtqqczze">@xtqqczze</a> do a similar optimization to one discussed previously in the context of <code>SslStream</code>. Here, they‚Äôre removing <code>SafeHandle</code> allocations in places where a simple <code>try</code>/<code>finally</code> with the raw <code>IntPtr</code> for the handle suffices.</li><li><a href="https://github.com/dotnet/runtime/pull/82096">dotnet/runtime#82096</a> and <a href="https://github.com/dotnet/runtime/pull/83138">dotnet/runtime#83138</a> decreased some costs by using newer constructs: string interpolation instead of concatenation so as to avoid some intermediary string allocations, and <code>u8</code> instead of <code>Encoding.UTF8.GetBytes</code> to avoid the transcoding overhead.</li><li><a href="https://github.com/dotnet/runtime/pull/75850">dotnet/runtime#75850</a> removed some allocations as part of initializing a <code>Dictionary&lt;,&gt;</code>. The dictionary in <code>TypeConverter</code> gets populated with a fixed set of predetermined items, and as such it‚Äôs provided with a capacity so as to presize its internal arrays to avoid intermediate allocations as part of growing. However, the provided capacity was smaller than the number of items actually being added. This PR simply fixed the number, and voila, less allocation.</li><li><a href="https://github.com/dotnet/runtime/pull/81036">dotnet/runtime#81036</a> from <a href="https://github.com/xtqqczze">@xtqqczze</a> and <a href="https://github.com/dotnet/runtime/pull/81039">dotnet/runtime#81039</a> from <a href="https://github.com/xtqqczze">@xtqqczze</a> helped eliminate some bounds checking in various components across the core libraries. Today the JIT compiler recognizes the pattern <code>for (int i = 0; i &lt; arr.Length; i++) Use(arr[i]);</code>, understanding that the <code>i</code> can‚Äôt ever be negative nor greater than the <code>arr</code>‚Äòs length, and thus eliminates the bounds check it would have otherwise emitted on <code>arr[i]</code>. However, the compiler doesn‚Äôt currently recognize the same thing for <code>for (int i = 0; i != arr.Length; i++) Use(arr[i]);</code>. These PRs primarily replaced <code>!=</code>s with <code>&lt;</code>s in order to help in some such cases (it also makes the code more idiomatic, and so was welcomed even in cases where it wasn‚Äôt actually helping with bounds checks).</li><li><a href="https://github.com/dotnet/runtime/pull/89030">dotnet/runtime#89030</a> fixed a case where a <code>Dictionary&lt;T, T&gt;</code> was being used as a set. Changing it to instead be <code>HashSet&lt;T&gt;</code> saves on the internal storage for the values that end up being identical to the keys.</li><li><a href="https://github.com/dotnet/runtime/pull/78741">dotnet/runtime#78741</a> replaces a bunch of <code>Unsafe.SizeOf&lt;T&gt;()</code> with <code>sizeof(T)</code> and <code>Unsafe.As&lt;TFrom, TTo&gt;</code> with pointer manipulation. Most of these are with managed <code>T</code>s, such that it used to not be possible to do. However, as of C# 11, more of these operations are possible, with conditions that were previously always errors now being downgraded to warnings (which can then be suppressed) in an <code>unsafe</code> context. Such replacements generally won‚Äôt improve throughput, but they do make the binaries a bit smaller and require less work for the JIT, which can in turn help with startup time. <a href="https://github.com/dotnet/runtime/pull/78914">dotnet/runtime#78914</a> takes advantage of this as well, this time to be able to pass a span as input to a <code>string.Create</code> call.</li><li><a href="https://github.com/dotnet/runtime/pull/78737">dotnet/runtime#78737</a> from <a href="https://github.com/Poppyto">@Poppyto</a> and <a href="https://github.com/dotnet/runtime/pull/79345">dotnet/runtime#79345</a> from <a href="https://github.com/Poppyto">@Poppyto</a> remove some <code>char[]</code> allocations from <code>Microsoft.Win32.Registry</code> by replacing some code that was using <code>List&lt;string&gt;</code> to build up a result and then <code>ToArray</code> it at the end to get back a <code>string[]</code>. In the majority case, we know the exact required size ahead of time, and can avoid the extra allocations and copy by just using an array from the get-go.</li><li><a href="https://github.com/dotnet/runtime/pull/82598">dotnet/runtime#82598</a> from <a href="https://github.com/huoyaoyuan">@huoyaoyuan</a> also tweaked <code>Registry</code>, taking advantage of a Win32 function that was added after the original code was written, in order to reduce the number of system calls required to delete a subtree.</li><li>Multiple changes went into <code>System.Xml</code> and <code>System.Runtime.Serialization.Xml</code> to streamline away peanut butter related to strings and arrays. <a href="https://github.com/dotnet/runtime/pull/75452">dotnet/runtime#75452</a> from <a href="https://github.com/TrayanZapryanov">@TrayanZapryanov</a> replaces multiple <code>string.Trim</code> calls with span trimming and slicing, taking advantage of the C# language‚Äôs recently added support for using <code>switch</code> over <code>ReadOnlySpan&lt;char&gt;</code>. <a href="https://github.com/dotnet/runtime/pull/75946">dotnet/runtime#75946</a> removes some use of <code>ToCharArray</code> (these days, there‚Äôs almost always a better alternative than <code>string.ToCharArray</code>), while <a href="https://github.com/dotnet/runtime/pull/82006">dotnet/runtime#82006</a> replaces some <code>new char[]</code> with spans and <code>stackalloc char[]</code>. <a href="https://github.com/dotnet/runtime/pull/85534">dotnet/runtime#85534</a> removed an unnecessary dictionary lookup, replacing a use of <code>ContainsKey</code> followed by the indexer with just <code>TryGetValue</code>. <a href="https://github.com/dotnet/runtime/pull/84888">dotnet/runtime#84888</a> from <a href="https://github.com/mla-alm">@mla-alm</a> removed some synchronous I/O from the asynchronous code paths in <code>XsdValidatingReader</code>. <a href="https://github.com/dotnet/runtime/pull/74955">dotnet/runtime#74955</a> from <a href="https://github.com/TrayanZapryanov">@TrayanZapryanov</a> deleted the internal <code>XmlConvert.StrEqual</code> helper that was comparing the two inputs character by character with just using <code>SequenceEqual</code> and <code>StartsWith</code>. <a href="https://github.com/dotnet/runtime/pull/75812">dotnet/runtime#75812</a> from <a href="https://github.com/jlennox">@jlennox</a> replaced some manual UTF8 encoding with <code>&quot;...&quot;u8</code>. <a href="https://github.com/dotnet/runtime/pull/76436">dotnet/runtime#76436</a> from <a href="https://github.com/TrayanZapryanov">@TrayanZapryanov</a> removed intermediate <code>string</code> allocation when writing primitive types as part of XML serialization. And <a href="https://github.com/dotnet/runtime/pull/73336">dotnet/runtime#73336</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a> and <a href="https://github.com/dotnet/runtime/pull/71478">dotnet/runtime#71478</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a> improved <code>XmlDictionaryWriter</code> by using <code>Encoding.UTF8</code> for UTF8 encoding and by doing more efficient writing using spans.</li><li><a href="https://github.com/dotnet/runtime/pull/87905">dotnet/runtime#87905</a> makes a tiny tweak to the <code>ArrayPool</code>, but one that can lead to very measurable gains. The <code>ArrayPool&lt;T&gt;</code> instance returned from <code>ArrayPool&lt;T&gt;.Shared</code> currently is a multi-layered cache. The first layer is in thread-local storage. If renting can‚Äôt be satisfied by that layer, it falls through to the next layer, where there‚Äôs a ‚Äúpartition‚Äù per array size per core (by default). Each partition is an array of arrays. By default, this <code>T[][]</code> could store 8 arrays. Now with this PR, it can store 32 arrays, decreasing the chances that code will need to spend additional cycles searching other partitions. With <a href="https://github.com/dotnet/runtime/pull/86109">dotnet/runtime#86109</a>, that 32 value can also be changed, by setting the <code>DOTNET_SYSTEM_BUFFERS_SHAREDARRAYPOOL_MAXARRAYSPERPARTITION</code> environment variable to the desired maximum capacity. The <code>DOTNET_SYSTEM_BUFFERS_SHAREDARRAYPOOL_MAXPARTITIONCOUNT</code> environment variable can also be used to control how many partitions are employed.</li></ul><h2 id="whats-next">What‚Äôs Next?</h2><p>Whew! That was‚Ä¶ a lot! So, what‚Äôs next?</p><p>The .NET 8 Release Candidate is now available, and I encourage you to <a href="https://dotnet.microsoft.com/download/dotnet/8.0?wt.mc_id=net8perf">download it</a> and take it for a spin. As you can likely sense from my enthusiasm throughout this post, I‚Äôm thrilled about the potential .NET 8 has to improve your system‚Äôs performance just by upgrading, and I‚Äôm thrilled about new features .NET 8 offers to help you tweak your code to be even more efficient. We‚Äôre eager to hear from you about your experiences in doing so, and if you find something that can be improved even further, we‚Äôd love for you to make it better by contributing to the various .NET repos, whether it be issues with your thoughts or PRs with your coded improvements. Your efforts will benefit not only you but every other .NET developer around the world!</p><p>Thanks for reading, and happy coding!</p>